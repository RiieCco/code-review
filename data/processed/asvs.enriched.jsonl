{"chapter_id": "V1", "chapter_name": "Encoding and Sanitization", "section_id": "V1.1", "section_name": "Encoding and Sanitization Architecture", "req_id": "V1.1.1", "req_description": "Verify that input is decoded or unescaped into a canonical form only once, it is only decoded when encoded data in that form is expected, and that this is done before processing the input further, for example it is not performed after input validation or sanitization.", "level": "2", "explanation": "This requirement emphasizes the importance of handling input data correctly by ensuring that any decoding or unescaping of data occurs only once and at the appropriate time. This means that the application should decode input data only when it is certain that the data is in an encoded format and should do so before any validation or sanitization processes. This approach helps to prevent issues such as double decoding, which can lead to security vulnerabilities.", "threats_mitigated": ["Cross-Site Scripting (XSS)", "Injection Attacks", "Data Manipulation", "Security Misconfiguration"], "insecure_examples": [{"code": "String input = request.getParameter(\"user_input\");\nString decodedInput = URLDecoder.decode(input, \"UTF-8\");\n// Validation and sanitization performed after decoding\nif (isValid(decodedInput)) {\n    processInput(decodedInput);\n}", "description": "Decoding input before validation, which can lead to XSS if the input is malicious."}, {"code": "String input = request.getParameter(\"user_input\");\nString decodedInput = new String(Base64.getDecoder().decode(input));\n// No validation or sanitization before processing\nprocessInput(decodedInput);"}], "secure_examples": [{"code": "String input = request.getParameter(\"user_input\");\nif (isValid(input)) {\n    String decodedInput = URLDecoder.decode(input, \"UTF-8\");\n    processInput(decodedInput);\n}", "description": "Validating input before decoding it to ensure it is safe to decode."}, {"code": "String input = request.getParameter(\"user_input\");\nif (isValid(input)) {\n    String decodedInput = new String(Base64.getDecoder().decode(input));\n    processInput(decodedInput);\n}"}], "verification_steps": ["Check that input is only decoded once.", "Ensure decoding occurs before any validation or sanitization.", "Verify that decoding is done only when encoded data is expected.", "Review code paths to ensure no double decoding occurs."], "common_mistakes": ["Decoding input before validating it, leading to potential security issues.", "Failing to check if the input is in the expected encoded format before decoding.", "Not considering the context in which the decoded data will be used, leading to vulnerabilities."], "related_cwe": ["CWE-20: Improper Input Validation", "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "CWE-117: Improper Output Neutralization for Logs"], "related_capec": ["CAPEC-137: Cross-Site Scripting (XSS)", "CAPEC-114: SQL Injection", "CAPEC-153: Command Injection"], "attack_flow": "An attacker may submit encoded input that, if decoded improperly or at the wrong time, can lead to the execution of malicious scripts or commands. For example, if an application decodes user input before validating it, an attacker could inject a script that executes in the context of a user's browser, leading to XSS attacks."}
{"chapter_id": "V1", "chapter_name": "Encoding and Sanitization", "section_id": "V1.1", "section_name": "Encoding and Sanitization Architecture", "req_id": "V1.1.2", "req_description": "Verify that the application performs output encoding and escaping either as a final step before being used by the interpreter for which it is intended or by the interpreter itself.", "level": "2", "explanation": "This requirement emphasizes the importance of encoding and escaping output data to prevent injection attacks. Output encoding transforms data into a safe format that can be rendered by the browser or other interpreters without executing it as code. This ensures that any potentially harmful input is treated as data and not executable code.", "threats_mitigated": ["Cross-Site Scripting (XSS)", "Injection Attacks", "HTML Injection", "JavaScript Injection"], "insecure_examples": ["<script>alert('XSS');</script>", "<a href='javascript:alert(1)'>Click me</a>"], "secure_examples": ["&lt;script&gt;alert('XSS');&lt;/script&gt;", "<a href='javascript:void(0);'>Click me</a>"], "verification_steps": ["Check that all user-generated content is properly encoded before being rendered in the browser.", "Review the output encoding libraries or functions used in the application.", "Ensure that encoding is performed as the last step before output.", "Verify that the application does not rely on the browser's automatic encoding."], "common_mistakes": ["Failing to encode output for all contexts (HTML, JavaScript, URL, etc.).", "Using outdated or insecure encoding libraries.", "Assuming that input validation is sufficient without output encoding."], "related_cwe": ["CWE-79", "CWE-117", "CWE-20"], "related_capec": ["CAPEC-137", "CAPEC-118"], "attack_flow": "An attacker can inject malicious scripts into user input fields, which, if not properly encoded, will be executed by the browser when the data is rendered. By exploiting this vulnerability, the attacker can perform actions such as stealing cookies, session tokens, or redirecting users to malicious sites."}
{"chapter_id": "V1", "chapter_name": "Encoding and Sanitization", "section_id": "V1.2", "section_name": "Injection Prevention", "req_id": "V1.2.1", "req_description": "Verify that output encoding for an HTTP response, HTML document, or XML document is relevant for the context required, such as encoding the relevant characters for HTML elements, HTML attributes, HTML comments, CSS, or HTTP header fields, to avoid changing the message or document structure.", "level": "1", "explanation": "This requirement emphasizes the importance of properly encoding output data to ensure that it is interpreted correctly by the browser or client. By encoding special characters, such as '<', '>', '&', and others, we prevent them from being interpreted as code. This is crucial in preventing cross-site scripting (XSS) attacks and ensuring that the integrity of the document structure is maintained.", "threats_mitigated": ["Cross-Site Scripting (XSS)", "HTML Injection", "XML Injection"], "insecure_examples": ["<script>alert('XSS');</script>", "<div title=\"<img src='x' onerror='alert(1)'>\">"], "secure_examples": ["&lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt;", "<div title=\"&lt;img src='x' onerror='alert(1)'&gt;\">"], "verification_steps": ["Check if all output data is properly encoded based on the context.", "Review the use of output encoding libraries or functions.", "Ensure that data is not directly inserted into HTML without encoding.", "Test for XSS vulnerabilities using common payloads."], "common_mistakes": ["Failing to encode user-generated content before rendering it in the browser.", "Using the same encoding for all contexts instead of context-specific encoding.", "Neglecting to encode attributes, comments, or CSS contexts."], "related_cwe": ["CWE-79", "CWE-116", "CWE-20"], "related_capec": ["CAPEC-137", "CAPEC-105"], "attack_flow": "An attacker can inject malicious scripts into the output by submitting crafted input that is not properly encoded. If the application does not sanitize or encode this input before rendering it in the browser, the browser will execute the injected script, leading to unauthorized actions, data theft, or session hijacking."}
{"chapter_id": "V1", "chapter_name": "Encoding and Sanitization", "section_id": "V1.2", "section_name": "Injection Prevention", "req_id": "V1.2.2", "req_description": "Verify that when dynamically building URLs, untrusted data is encoded according to its context (e.g., URL encoding or base64url encoding for query or path parameters). Ensure that only safe URL protocols are permitted (e.g., disallow javascript: or data:).", "level": "1", "explanation": "This requirement emphasizes the importance of properly encoding untrusted data when constructing URLs to prevent injection attacks. Encoding transforms potentially harmful characters into a safe format, which helps to ensure that the data is treated as data rather than executable code. It also involves validating the protocols used in URLs to prevent the execution of malicious scripts.", "threats_mitigated": ["Cross-Site Scripting (XSS)", "Open Redirects", "Injection Attacks"], "insecure_examples": ["const userInput = 'http://example.com/?param=<script>alert(1)</script>';\nconst url = 'http://example.com/?param=' + userInput;", "const unsafeUrl = 'javascript:alert(\"XSS\")';\nwindow.location.href = unsafeUrl;"], "secure_examples": ["const userInput = encodeURIComponent('<script>alert(1)</script>');\nconst url = 'http://example.com/?param=' + userInput;", "const safeUrl = 'http://example.com';\nwindow.location.href = safeUrl;"], "verification_steps": ["Check that all user inputs used in URL construction are properly encoded.", "Ensure that only safe protocols (http, https) are allowed.", "Review code for instances of direct user input being appended to URLs without validation."], "common_mistakes": ["Failing to encode user input before appending it to a URL.", "Allowing unsafe protocols such as javascript: or data: in URLs.", "Not validating the structure of the URL before using it."], "related_cwe": ["CWE-20: Improper Input Validation", "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "CWE-117: Improper Output Neutralization for Logs"], "related_capec": ["CAPEC-137: URL Manipulation", "CAPEC-115: JavaScript Injection", "CAPEC-145: Cross-Site Scripting (XSS)"], "attack_flow": "An attacker could manipulate the input to include malicious scripts or redirect URLs. If the application fails to encode this input, the browser may execute the injected script or redirect to an unintended location, leading to potential data theft, session hijacking, or other malicious actions."}
{"chapter_id": "V1", "chapter_name": "Encoding and Sanitization", "section_id": "V1.2", "section_name": "Injection Prevention", "req_id": "V1.2.3", "req_description": "Verify that output encoding or escaping is used when dynamically building JavaScript content (including JSON), to avoid changing the message or document structure (to avoid JavaScript and JSON injection).", "level": "1", "explanation": "This requirement emphasizes the importance of properly encoding or escaping any data that is incorporated into JavaScript or JSON structures. When dynamic content is inserted without proper handling, it can lead to JavaScript injection attacks where an attacker can manipulate the execution of scripts in the context of the user's browser, potentially leading to data theft or unauthorized actions.", "threats_mitigated": ["JavaScript Injection", "Cross-Site Scripting (XSS)", "Data Manipulation"], "insecure_examples": [{"code": "var userInput = '<script>alert(\"XSS\");</script>';\nvar jsonData = '{\"data\": ' + userInput + '}';"}, {"code": "document.write('<div>' + userInput + '</div>');"}], "secure_examples": [{"code": "var userInput = '<script>alert(\"XSS\");</script>';\nvar jsonData = '{\"data\": ' + JSON.stringify(userInput) + '}';"}, {"code": "document.write('<div>' + escapeHtml(userInput) + '</div>');"}], "verification_steps": ["Check if all dynamic data inserted into JavaScript or JSON is properly encoded.", "Verify the use of functions like JSON.stringify for JSON data.", "Ensure that any user-generated content is sanitized and escaped before rendering."], "common_mistakes": ["Failing to encode user input when embedding in JavaScript.", "Using innerHTML instead of textContent or similar safe methods.", "Neglecting to sanitize JSON data before parsing or rendering."], "related_cwe": ["CWE-79", "CWE-20", "CWE-117"], "related_capec": ["CAPEC-137", "CAPEC-118"], "attack_flow": "An attacker crafts a malicious input that is inserted into a JavaScript context without proper encoding. When the script is executed in the user's browser, it can perform unauthorized actions, such as stealing cookies or redirecting the user to a malicious site."}
{"chapter_id": "V1", "chapter_name": "Encoding and Sanitization", "section_id": "V1.2", "section_name": "Injection Prevention", "req_id": "V1.2.4", "req_description": "Verify that data selection or database queries (e.g., SQL, HQL, NoSQL, Cypher) use parameterized queries, ORMs, entity frameworks, or are otherwise protected from SQL Injection and other database injection attacks. This is also relevant when writing stored procedures.", "level": "1", "explanation": "This requirement emphasizes the importance of using safe coding practices when interacting with databases. By utilizing parameterized queries or ORM frameworks, developers can ensure that user input is treated as data rather than executable code, significantly reducing the risk of SQL Injection and other injection attacks.", "threats_mitigated": ["SQL Injection", "NoSQL Injection", "Command Injection", "Stored Procedure Injection"], "insecure_examples": [{"code": "String query = \"SELECT * FROM users WHERE username = '\" + username + \"'\";", "description": "This concatenation of user input directly into the SQL query allows for SQL Injection."}, {"code": "db.execute(\"SELECT * FROM products WHERE id = \" + productId);", "description": "Directly injecting user input into the query without validation or parameterization."}], "secure_examples": [{"code": "String query = \"SELECT * FROM users WHERE username = ?\"; PreparedStatement pstmt = connection.prepareStatement(query); pstmt.setString(1, username);", "description": "Using a prepared statement to safely include user input."}, {"code": "db.execute(\"SELECT * FROM products WHERE id = ?\", productId);", "description": "Using parameterized queries to prevent injection."}], "verification_steps": ["Check for the use of parameterized queries in database interactions.", "Ensure that ORMs or entity frameworks are utilized where applicable.", "Review stored procedures for potential injection vulnerabilities.", "Validate user inputs before they are used in queries."], "common_mistakes": ["Using string concatenation to build SQL queries.", "Neglecting to sanitize user input before database operations.", "Assuming that ORM frameworks automatically protect against all injection attacks."], "related_cwe": ["CWE-89", "CWE-94", "CWE-77"], "related_capec": ["CAPEC-137", "CAPEC-144", "CAPEC-147"], "attack_flow": "An attacker can exploit this requirement by injecting malicious SQL code through user input fields. If the application constructs SQL queries by concatenating user input without proper sanitization, the attacker can manipulate the query to execute arbitrary SQL commands, potentially leading to data leakage, data manipulation, or even full database compromise."}
{"chapter_id": "V1", "chapter_name": "Encoding and Sanitization", "section_id": "V1.2", "section_name": "Injection Prevention", "req_id": "V1.2.5", "req_description": "Verify that the application protects against OS command injection and that operating system calls use parameterized OS queries or use contextual command line output encoding.", "level": "1", "explanation": "This requirement emphasizes the importance of preventing OS command injection vulnerabilities by ensuring that any operating system commands executed by the application are properly sanitized and parameterized. This means that user input should never be directly included in OS commands without proper validation and encoding, which can lead to arbitrary command execution by an attacker.", "threats_mitigated": ["OS Command Injection", "Arbitrary Code Execution", "Privilege Escalation"], "insecure_examples": [{"code": "String command = \"ls \" + userInput; Runtime.getRuntime().exec(command);"}, {"code": "Process process = Runtime.getRuntime().exec(\"ping \" + ipAddress);"}], "secure_examples": [{"code": "String command = \"ls\"; ProcessBuilder pb = new ProcessBuilder(command, userInput); pb.start();"}, {"code": "ProcessBuilder pb = new ProcessBuilder(\"ping\", ipAddress); pb.start();"}], "verification_steps": ["Review code for direct usage of user input in OS commands.", "Check for the use of parameterized queries or command builders.", "Ensure that all external inputs are validated and sanitized.", "Look for the use of libraries or frameworks that provide safe OS command execution."], "common_mistakes": ["Concatenating user input directly into command strings.", "Failing to validate or sanitize user inputs before using them in commands.", "Not using secure libraries or functions for executing OS commands."], "related_cwe": ["CWE-78", "CWE-89"], "related_capec": ["CAPEC-137", "CAPEC-158"], "attack_flow": "An attacker can exploit OS command injection by injecting malicious commands through user input fields. If the application does not properly sanitize or validate this input, the attacker can execute arbitrary commands on the server, potentially leading to data breaches, system compromise, or unauthorized access."}
{"chapter_id": "V1", "chapter_name": "Encoding and Sanitization", "section_id": "V1.2", "section_name": "Injection Prevention", "req_id": "V1.2.6", "req_description": "Verify that the application protects against LDAP injection vulnerabilities, or that specific security controls to prevent LDAP injection have been implemented.", "level": "2", "explanation": "This requirement mandates that applications must implement measures to prevent LDAP injection attacks, which occur when an attacker manipulates LDAP queries by injecting malicious input. Proper validation and sanitization of user inputs are essential to ensure that the application does not execute unintended commands or queries against the LDAP directory.", "threats_mitigated": ["Unauthorized access to sensitive directory information", "Data leakage from LDAP directories", "Privilege escalation through LDAP manipulation"], "insecure_examples": ["String ldapQuery = \"(&(uid=\" + userInput + \")(userPassword=\" + passwordInput + \"))\";", "ldapSearch(query); // where query is constructed from user input without sanitization"], "secure_examples": ["String ldapQuery = \"(&(uid=\" + sanitize(userInput) + \")(userPassword=\" + sanitize(passwordInput) + \"))\";", "ldapSearch(safeQuery); // where safeQuery is constructed using prepared statements or parameterized queries"], "verification_steps": ["Check for input validation on all user inputs that are used in LDAP queries.", "Review the code for the use of parameterized queries or prepared statements.", "Ensure that any output from LDAP queries is properly encoded before being displayed to users.", "Test the application with various LDAP injection payloads to confirm that it is resilient."], "common_mistakes": ["Failing to sanitize user input before using it in LDAP queries.", "Using string concatenation to build LDAP queries instead of prepared statements.", "Not validating the structure and format of LDAP inputs."], "related_cwe": ["CWE-90: LDAP Injection", "CWE-20: Improper Input Validation", "CWE-74: Injection"], "related_capec": ["CAPEC-127: LDAP Injection", "CAPEC-133: Directory Traversal via LDAP Injection"], "attack_flow": "An attacker crafts a malicious input that alters the structure of the LDAP query. If the application directly incorporates this input into the query without proper sanitization, the attacker can manipulate the LDAP query to bypass authentication or retrieve unauthorized data from the directory."}
{"chapter_id": "V1", "chapter_name": "Encoding and Sanitization", "section_id": "V1.2", "section_name": "Injection Prevention", "req_id": "V1.2.7", "req_description": "Verify that the application is protected against XPath injection attacks by using query parameterization or precompiled queries.", "level": "2", "explanation": "This requirement emphasizes the importance of preventing XPath injection attacks, which occur when untrusted input is directly included in XPath queries. By using query parameterization or precompiled queries, developers can ensure that user inputs are treated as data rather than executable code, effectively mitigating the risk of injection attacks.", "threats_mitigated": ["XPath Injection", "Data Leakage", "Unauthorized Data Access"], "insecure_examples": [{"code": "String query = \"//user[name='\" + userInput + \"']\"; // Vulnerable to XPath injection"}, {"code": "XPathExpression expr = xpath.compile(\"//user[name='\" + userInput + \"']\"); // Directly concatenating user input"}], "secure_examples": [{"code": "String query = \"//user[name=$name]\"; // Using parameterized query"}, {"code": "XPathExpression expr = xpath.compile(\"//user[name=$name]\"); // Using precompiled queries with parameter binding"}], "verification_steps": ["Check for the use of parameterized queries or precompiled queries in XPath expressions.", "Review the code for any direct concatenation of user inputs in XPath queries.", "Ensure that input validation and sanitization are applied to user inputs before they are used in XPath queries."], "common_mistakes": ["Using string concatenation to build XPath queries.", "Failing to validate or sanitize user inputs before including them in XPath queries.", "Assuming that input escaping is sufficient to prevent injection attacks."], "related_cwe": ["CWE-91", "CWE-20", "CWE-74"], "related_capec": ["CAPEC-137", "CAPEC-145"], "attack_flow": "An attacker can exploit this requirement by injecting malicious XPath code through user inputs that are not properly sanitized or parameterized. If the application directly concatenates user inputs into XPath queries, the attacker can manipulate the query to access unauthorized data, leading to potential data breaches or unauthorized actions within the application."}
{"chapter_id": "V1", "chapter_name": "Encoding and Sanitization", "section_id": "V1.2", "section_name": "Injection Prevention", "req_id": "V1.2.8", "req_description": "Verify that LaTeX processors are configured securely (such as not using the '--shell-escape' flag) and an allowlist of commands is used to prevent LaTeX injection attacks.", "level": "2", "explanation": "This requirement emphasizes the importance of configuring LaTeX processors in a secure manner to prevent potential injection attacks. The '--shell-escape' flag allows LaTeX to execute arbitrary shell commands, which can be exploited by attackers to execute malicious code. By using an allowlist of commands, developers can restrict the commands that can be executed, thereby reducing the attack surface.", "threats_mitigated": ["LaTeX Injection", "Remote Code Execution", "Arbitrary Command Execution"], "insecure_examples": [{"code": "\\documentclass{article}\n\\begin{document}\n\\immediate\\write18{malicious_command}\n\\end{document}"}, {"code": "\\documentclass{article}\n\\usepackage{graphicx}\n\\begin{document}\n\\includegraphics{\\detokenize{malicious_file}}\n\\end{document}"}], "secure_examples": [{"code": "\\documentclass{article}\n\\begin{document}\n% Secure configuration with no shell escape\n\\end{document}"}, {"code": "\\documentclass{article}\n\\usepackage{graphicx}\n\\begin{document}\n\\includegraphics{allowed_image}\n\\end{document}"}], "verification_steps": ["Check LaTeX configuration for the presence of the '--shell-escape' flag.", "Review the allowlist of commands to ensure only safe commands are permitted.", "Test LaTeX documents for injection vulnerabilities.", "Conduct a code review focusing on LaTeX processing sections."], "common_mistakes": ["Failing to disable the '--shell-escape' flag in production environments.", "Using overly permissive allowlists that include unsafe commands.", "Neglecting to validate input that is passed to LaTeX processors."], "related_cwe": ["CWE-20", "CWE-94", "CWE-77"], "related_capec": ["CAPEC-137", "CAPEC-163"], "attack_flow": "An attacker crafts a LaTeX document that includes malicious commands. If the LaTeX processor is configured with the '--shell-escape' flag enabled, the processor executes the commands, allowing the attacker to run arbitrary code on the server or client machine, leading to potential data theft, system compromise, or further attacks."}
{"chapter_id": "V1", "chapter_name": "Encoding and Sanitization", "section_id": "V1.2", "section_name": "Injection Prevention", "req_id": "V1.2.9", "req_description": "Verify that the application escapes special characters in regular expressions (typically using a backslash) to prevent them from being misinterpreted as metacharacters.", "level": "2", "explanation": "This requirement emphasizes the importance of properly escaping special characters in regular expressions to avoid unintended behavior. Special characters in regex can have specific meanings (like '.', '*', '?', etc.), and if not escaped, they can lead to vulnerabilities such as Regular Expression Denial of Service (ReDoS) or unintended matches that can compromise application logic.", "threats_mitigated": ["Regular Expression Denial of Service (ReDoS)", "Injection Attacks", "Logic Flaws due to unintended regex matches"], "insecure_examples": [{"code": "if (userInput.matches(\".*[a-zA-Z].*\")) { ... } // No escaping of user input"}, {"code": "Pattern pattern = Pattern.compile(\".*\" + userInput + \".*\"); // userInput not escaped"}], "secure_examples": [{"code": "if (userInput.matches(\".*[\\\\a-zA-Z].*\")) { ... } // Escaped special character"}, {"code": "Pattern pattern = Pattern.compile(\".*\" + Pattern.quote(userInput) + \".*\"); // Securely escaping userInput"}], "verification_steps": ["Review regex patterns in the codebase.", "Check if special characters in user input are properly escaped.", "Ensure that any dynamic regex components are handled using secure methods (e.g., Pattern.quote).", "Test regex patterns with various inputs to confirm they behave as expected."], "common_mistakes": ["Assuming user input will never contain special regex characters.", "Not using escaping functions when constructing regex patterns dynamically.", "Overlooking the need to review regex patterns during code reviews."], "related_cwe": ["CWE-20", "CWE-74", "CWE-117"], "related_capec": ["CAPEC-138", "CAPEC-139"], "attack_flow": "An attacker may input a string that contains special regex characters, which, if not properly escaped, can alter the intended logic of the regex. This can lead to excessive backtracking, causing performance issues (ReDoS) or allowing the attacker to bypass validation checks, ultimately compromising the application."}
{"chapter_id": "V1", "chapter_name": "Encoding and Sanitization", "section_id": "V1.2", "section_name": "Injection Prevention", "req_id": "V1.2.10", "req_description": "Verify that the application is protected against CSV and Formula Injection. The application must follow the escaping rules defined in RFC 4180 sections 2.6 and 2.7 when exporting CSV content. Additionally, when exporting to CSV or other spreadsheet formats (such as XLS, XLSX, or ODF), special characters (including '=', '+', '-', '@', '\\t' (tab), and '\\0' (null character)) must be escaped with a single quote if they appear as the first character in a field value.", "level": 3, "explanation": "This requirement focuses on preventing CSV and formula injection attacks by ensuring that any data exported to CSV or spreadsheet formats is properly sanitized. By escaping special characters that can be interpreted as formulas or commands, the application mitigates the risk of executing unintended actions when the CSV file is opened in spreadsheet applications. Following the guidelines in RFC 4180 ensures standardized handling of CSV files.", "threats_mitigated": ["CSV Injection", "Formula Injection", "Data Manipulation", "Information Disclosure"], "insecure_examples": [{"code": "return \"name, email, phone\\nJohn Doe, john@example.com, =SUM(A1:A10)\";"}, {"code": "return \"name, email\\n=HYPERLINK('http://malicious.com', 'Click here')\";"}], "secure_examples": [{"code": "return \"name, email, phone\\n'John Doe, john@example.com, '=SUM(A1:A10)\";"}, {"code": "return \"name, email\\n'=HYPERLINK('http://malicious.com', 'Click here')\";"}], "verification_steps": ["Review CSV export functionality for proper escaping of special characters.", "Check that any data that could be interpreted as a formula is prefixed with a single quote.", "Test CSV files in various spreadsheet applications to ensure no formulas are executed.", "Ensure compliance with RFC 4180 sections 2.6 and 2.7."], "common_mistakes": ["Failing to escape special characters when exporting data.", "Not validating or sanitizing user input before including it in CSV exports.", "Assuming spreadsheet applications will handle unescaped data safely."], "related_cwe": ["CWE-1236", "CWE-20", "CWE-74"], "related_capec": ["CAPEC-143", "CAPEC-147"], "attack_flow": "An attacker crafts a malicious input containing a formula (e.g., '=SUM(1+1)') or a link (e.g., '=HYPERLINK('http://malicious.com', 'Click here')'). When the CSV file is opened in a spreadsheet application, the application interprets the input as a formula or command, executing it and potentially leading to data manipulation or disclosure of sensitive information."}
{"chapter_id": "V1", "chapter_name": "Encoding and Sanitization", "section_id": "V1.3", "section_name": "Sanitization", "req_id": "V1.3.2", "req_description": "Verify that the application avoids the use of eval() or other dynamic code execution features such as Spring Expression Language (SpEL). Where there is no alternative, any user input being included must be sanitized before being executed.", "level": "1", "explanation": "This requirement emphasizes the importance of avoiding dynamic code execution, which can lead to severe security vulnerabilities such as code injection. The use of functions like eval() allows attackers to execute arbitrary code if they can control the input. Instead, developers should rely on safer alternatives and ensure that any user input is properly sanitized to prevent malicious content from being executed.", "threats_mitigated": ["Code Injection", "Remote Code Execution", "Cross-Site Scripting (XSS)"], "insecure_examples": [{"code": "eval(userInput);", "description": "Directly executing user input without any validation or sanitization."}, {"code": "String expression = \"result = \" + userInput; eval(expression);", "description": "Concatenating user input into a dynamic expression for execution."}], "secure_examples": [{"code": "if (isValidInput(userInput)) { executeSafeFunction(userInput); }", "description": "Using a validation function to ensure input is safe before execution."}, {"code": "String sanitizedInput = sanitize(userInput); executeSafeFunction(sanitizedInput);", "description": "Sanitizing user input before using it in any execution context."}], "verification_steps": ["Check code for instances of eval() or similar dynamic execution methods.", "Ensure that any dynamic code execution is avoided or properly sanitized.", "Review input validation and sanitization functions for effectiveness.", "Test the application with various malicious inputs to ensure they are properly handled."], "common_mistakes": ["Using eval() or similar functions without understanding the risks.", "Assuming that built-in sanitization functions are sufficient without custom validation.", "Failing to sanitize user input before including it in dynamic expressions."], "related_cwe": ["CWE-94", "CWE-20", "CWE-77"], "related_capec": ["CAPEC-137", "CAPEC-110"], "attack_flow": "An attacker can exploit this requirement by injecting malicious code into user input fields. If the application uses eval() or similar functions without proper sanitization, the attackerâ€™s code will be executed in the context of the application, potentially leading to unauthorized access, data breaches, or full system compromise."}
{"chapter_id": "V1", "chapter_name": "Encoding and Sanitization", "section_id": "V1.3", "section_name": "Sanitization", "req_id": "V1.3.3", "req_description": "Verify that data being passed to a potentially dangerous context is sanitized beforehand to enforce safety measures, such as only allowing characters which are safe for this context and trimming input which is too long.", "level": "2", "explanation": "This requirement emphasizes the importance of sanitizing user input before it is processed or used in potentially dangerous contexts, such as HTML, SQL, or command execution. Sanitization involves validating and cleaning the input to ensure it does not contain harmful characters or exceed length limits, thereby reducing the risk of injection attacks and other vulnerabilities.", "threats_mitigated": ["Cross-Site Scripting (XSS)", "SQL Injection", "Command Injection", "Buffer Overflow"], "insecure_examples": [{"code": "user_input = request.get('input');\nexecute_query('SELECT * FROM users WHERE username = ' + user_input);"}, {"code": "unsafe_output = '<div>' + user_input + '</div>';\ndocument.body.innerHTML = unsafe_output;"}], "secure_examples": [{"code": "user_input = request.get('input');\nexecute_query('SELECT * FROM users WHERE username = ?', [user_input]);"}, {"code": "safe_output = '<div>' + sanitize(user_input) + '</div>';\ndocument.body.innerHTML = safe_output;"}], "verification_steps": ["Check that all user inputs are validated against a whitelist of allowed characters.", "Ensure that input length is restricted to a reasonable limit.", "Review the sanitization functions used for effectiveness against known attack vectors.", "Confirm that the output is properly encoded for the context it will be displayed in."], "common_mistakes": ["Relying solely on client-side validation without server-side checks.", "Using regex patterns that are too permissive.", "Failing to sanitize input for all contexts where it is used.", "Not enforcing input length restrictions."], "related_cwe": ["CWE-20: Improper Input Validation", "CWE-74: Injection", "CWE-117: Improper Output Neutralization for Logs"], "related_capec": ["CAPEC-137: SQL Injection", "CAPEC-48: Command Injection", "CAPEC-118: Cross-Site Scripting (XSS)"], "attack_flow": "An attacker can exploit unsanitized input by injecting malicious code or scripts into the application. For example, if user input is directly included in a SQL query without sanitization, an attacker could manipulate the query to retrieve unauthorized data. Similarly, if user input is rendered in a web page without proper encoding, it could lead to XSS attacks, allowing the attacker to execute scripts in the context of other users' browsers."}
{"chapter_id": "V1", "chapter_name": "Encoding and Sanitization", "section_id": "V1.3", "section_name": "Sanitization", "req_id": "V1.3.4", "req_description": "Verify that user-supplied Scalable Vector Graphics (SVG) scriptable content is validated or sanitized to contain only tags and attributes (such as draw graphics) that are safe for the application, e.g., do not contain scripts and foreignObject.", "level": 2, "explanation": "This requirement emphasizes the importance of validating and sanitizing SVG content provided by users to prevent the execution of malicious scripts or unexpected behaviors in the application. By ensuring that only safe tags and attributes are allowed, the application can mitigate risks associated with SVG-based attacks.", "threats_mitigated": ["Cross-Site Scripting (XSS)", "Code Injection", "Denial of Service (DoS) via resource exhaustion"], "insecure_examples": ["<svg><script>alert('XSS');</script></svg>", "<svg><foreignObject><div>Malicious Content</div></foreignObject></svg>"], "secure_examples": ["<svg><circle cx='50' cy='50' r='40' stroke='black' stroke-width='3' fill='red' /></svg>", "<svg><rect width='100' height='100' style='fill:blue;' /></svg>"], "verification_steps": ["Review the SVG input handling code for validation mechanisms.", "Check for the presence of a whitelist of allowed SVG tags and attributes.", "Test user inputs with various SVG payloads to ensure that disallowed content is rejected.", "Verify that the application does not render any scripts or foreignObject elements."], "common_mistakes": ["Failing to implement a proper whitelist of allowed SVG tags and attributes.", "Relying solely on client-side validation without server-side checks.", "Not considering the potential for SVG to contain embedded scripts."], "related_cwe": ["CWE-79", "CWE-20", "CWE-117"], "related_capec": ["CAPEC-137", "CAPEC-147", "CAPEC-154"], "attack_flow": "An attacker crafts a malicious SVG containing scripts or foreignObject elements and submits it through a user input field. If the application fails to sanitize or validate this input, the SVG is rendered in the browser, executing the malicious script and potentially compromising user data or application integrity."}
{"chapter_id": "V1", "chapter_name": "Encoding and Sanitization", "section_id": "V1.3", "section_name": "Sanitization", "req_id": "V1.3.5", "req_description": "Verify that the application sanitizes or disables user-supplied scriptable or expression template language content, such as Markdown, CSS or XSL stylesheets, BBCode, or similar.", "level": "2", "explanation": "This requirement emphasizes the importance of sanitizing user input that can be interpreted as code or markup. It aims to prevent the execution of malicious scripts or styles that could lead to Cross-Site Scripting (XSS) or other injection attacks. Proper sanitization involves either removing potentially dangerous content or encoding it so that it cannot be executed by the browser.", "threats_mitigated": ["Cross-Site Scripting (XSS)", "Code Injection", "CSS Injection", "Template Injection"], "insecure_examples": ["<script>alert('XSS');</script>", "<style>body { background: url('http://malicious.com'); }</style>"], "secure_examples": ["const safeInput = sanitize(userInput); // Function that removes or encodes dangerous content", "const safeMarkdown = markdownToHtml(safeInput); // Converts sanitized input to HTML safely"], "verification_steps": ["Check if user input is being sanitized before rendering.", "Verify that any user-supplied content is encoded properly.", "Look for libraries or functions used for sanitization and check their effectiveness.", "Test the application with various payloads to ensure that malicious scripts are not executed."], "common_mistakes": ["Relying solely on client-side validation without server-side checks.", "Using outdated or ineffective sanitization libraries.", "Failing to sanitize all types of user input, especially in templating engines."], "related_cwe": ["CWE-79", "CWE-20", "CWE-117"], "related_capec": ["CAPEC-137", "CAPEC-148", "CAPEC-153"], "attack_flow": "An attacker submits a payload containing a script or style that is not properly sanitized. When the application processes this input, it renders the malicious content in the user's browser. This can lead to the execution of arbitrary scripts, data theft, or manipulation of the web page, compromising the security and integrity of the application."}
{"chapter_id": "V1", "chapter_name": "Encoding and Sanitization", "section_id": "V1.3", "section_name": "Sanitization", "req_id": "V1.3.6", "req_description": "Verify that the application protects against Server-side Request Forgery (SSRF) attacks, by validating untrusted data against an allowlist of protocols, domains, paths and ports and sanitizing potentially dangerous characters before using the data to call another service.", "level": 2, "explanation": "This requirement mandates that applications should not blindly trust user input when making requests to other services. It requires implementing strict validation mechanisms to ensure that any data used in such requests adheres to a predefined set of accepted values, effectively preventing attackers from manipulating requests to access internal services or sensitive data.", "threats_mitigated": ["Server-side Request Forgery (SSRF)", "Data Leakage", "Internal Network Scanning", "Unauthorized Access to Internal Services"], "insecure_examples": [{"code": "const url = req.body.url;\nfetch(url);"}, {"code": "const userInput = req.query.endpoint;\nhttp.get(userInput);"}], "secure_examples": [{"code": "const allowedProtocols = ['http:', 'https:'];\nif (allowedProtocols.includes(new URL(req.body.url).protocol)) {\n  fetch(req.body.url);\n}"}, {"code": "const allowedDomains = ['example.com', 'api.example.com'];\nif (allowedDomains.includes(new URL(userInput).hostname)) {\n  http.get(userInput);\n}"}], "verification_steps": ["Review the code for input validation mechanisms.", "Check if there is an allowlist for protocols, domains, and paths.", "Ensure that untrusted data is sanitized before use.", "Test the application for SSRF vulnerabilities using various payloads."], "common_mistakes": ["Failing to validate user input before using it in service calls.", "Using overly broad allowlists that do not adequately restrict input.", "Neglecting to sanitize input data, allowing special characters to pass through."], "related_cwe": ["CWE-918", "CWE-20", "CWE-74"], "related_capec": ["CAPEC-138", "CAPEC-177", "CAPEC-178"], "attack_flow": "An attacker crafts a request that includes malicious input, such as a URL pointing to an internal service. If the application does not validate or sanitize this input, it may make a request to the internal service, potentially exposing sensitive data or allowing further exploitation of the internal network."}
{"chapter_id": "V1", "chapter_name": "Encoding and Sanitization", "section_id": "V1.3", "section_name": "Sanitization", "req_id": "V1.3.7", "req_description": "Verify that the application protects against template injection attacks by not allowing templates to be built based on untrusted input. Where there is no alternative, any untrusted input being included dynamically during template creation must be sanitized or strictly validated.", "level": 2, "explanation": "This requirement emphasizes the importance of ensuring that any dynamic content incorporated into templates is either validated or sanitized to prevent template injection attacks. Template injection occurs when an attacker can manipulate the template engine to execute arbitrary code or access sensitive data. By strictly controlling the input that can be included in templates, applications can mitigate the risk of such attacks.", "threats_mitigated": ["Template Injection", "Code Injection", "Cross-Site Scripting (XSS)"], "insecure_examples": ["const template = `Hello, ${userInput}`; // userInput is untrusted", "renderTemplate(userInput); // userInput can manipulate the template"], "secure_examples": ["const sanitizedInput = sanitize(userInput); const template = `Hello, ${sanitizedInput}`;", "renderTemplate(validate(userInput)); // userInput is validated before use"], "verification_steps": ["Review the template rendering code for untrusted input usage.", "Check if input is sanitized or validated before being included in templates.", "Look for any instances where user input is directly passed to the template engine."], "common_mistakes": ["Assuming that template engines automatically sanitize input.", "Failing to validate input when using complex templating logic.", "Not considering all sources of input that could affect templates."], "related_cwe": ["CWE-20: Improper Input Validation", "CWE-74: Injection", "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Injection')"], "related_capec": ["CAPEC-116: Template Injection", "CAPEC-130: Code Injection via Templating Systems"], "attack_flow": "An attacker provides malicious input that is included in the template without proper validation or sanitization. This input is then processed by the template engine, leading to the execution of unintended commands or access to sensitive information, which can compromise the application's integrity and security."}
{"chapter_id": "V1", "chapter_name": "Encoding and Sanitization", "section_id": "V1.3", "section_name": "Sanitization", "req_id": "V1.3.8", "req_description": "Verify that the application appropriately sanitizes untrusted input before use in Java Naming and Directory Interface (JNDI) queries and that JNDI is configured securely to prevent JNDI injection attacks.", "level": 2, "explanation": "This requirement emphasizes the importance of sanitizing any untrusted input that may be used in JNDI queries to prevent attackers from injecting malicious data that could compromise the application or access unauthorized resources. Proper configuration of JNDI is also crucial to mitigate risks associated with JNDI injection vulnerabilities.", "threats_mitigated": ["JNDI Injection", "Remote Code Execution", "Unauthorized Access"], "insecure_examples": ["String jndiLookup = \"ldap://\" + userInput;", "Context ctx = new InitialContext(); ctx.lookup(jndiLookup);"], "secure_examples": ["String sanitizedInput = sanitizeInput(userInput); String jndiLookup = \"ldap://\" + sanitizedInput;", "Context ctx = new InitialContext(); ctx.lookup(jndiLookup);"], "verification_steps": ["Review code for direct usage of untrusted input in JNDI queries.", "Check for the implementation of input sanitization functions.", "Verify that JNDI configurations are set to restrict access to only necessary resources.", "Conduct security testing to ensure that JNDI injection cannot be performed."], "common_mistakes": ["Failing to sanitize user input before using it in JNDI queries.", "Hardcoding sensitive JNDI configurations without proper access controls.", "Using unvalidated or unsanitized data in JNDI lookups."], "related_cwe": ["CWE-74: Injection", "CWE-20: Improper Input Validation", "CWE-284: Improper Access Control"], "related_capec": ["CAPEC-138: JNDI Injection", "CAPEC-150: LDAP Injection"], "attack_flow": "An attacker can exploit this requirement by injecting malicious input into a JNDI query. If the application does not properly sanitize the input, the attacker can manipulate the JNDI lookup to access sensitive data or execute arbitrary code on the server, leading to a full compromise of the application."}
{"chapter_id": "V1", "chapter_name": "Encoding and Sanitization", "section_id": "V1.3", "section_name": "Sanitization", "req_id": "V1.3.9", "req_description": "Verify that the application sanitizes content before it is sent to memcache to prevent injection attacks.", "level": "2", "explanation": "This requirement emphasizes the importance of sanitizing data before it is stored in memcache. Unsanitized data can lead to various types of injection attacks, where malicious input is executed or interpreted in unintended ways when retrieved from memcache. Proper sanitization ensures that only safe, expected input is processed and stored.", "threats_mitigated": ["Code Injection", "Command Injection", "SQL Injection", "Cross-Site Scripting (XSS)"], "insecure_examples": ["memcache.set('user_input', userInput); // No sanitization applied", "memcache.set('data', '<script>alert(1)</script>'); // Unsanitized HTML content"], "secure_examples": ["memcache.set('user_input', sanitize(userInput)); // Sanitization applied", "memcache.set('data', escapeHtml(userInput)); // Sanitized HTML content"], "verification_steps": ["Check that all data sent to memcache is sanitized.", "Review sanitization functions for effectiveness against injection attacks.", "Ensure that user input is validated before being processed.", "Conduct code reviews focusing on data handling and storage."], "common_mistakes": ["Assuming that memcache automatically handles data safely.", "Failing to sanitize data that is not user-generated.", "Using outdated or ineffective sanitization libraries."], "related_cwe": ["CWE-74: Injection", "CWE-20: Improper Input Validation", "CWE-117: Improper Output Encoding or Escaping"], "related_capec": ["CAPEC-137: Code Injection", "CAPEC-118: Command Injection", "CAPEC-132: SQL Injection"], "attack_flow": "An attacker provides malicious input that is stored in memcache without proper sanitization. When this data is later retrieved and used in an application context (e.g., rendered in a web page), the malicious code is executed, leading to potential data breaches or unauthorized actions."}
{"chapter_id": "V1", "chapter_name": "Encoding and Sanitization", "section_id": "V1.3", "section_name": "Sanitization", "req_id": "V1.3.10", "req_description": "Verify that format strings which might resolve in an unexpected or malicious way when used are sanitized before being processed.", "level": "2", "explanation": "This requirement emphasizes the importance of sanitizing format strings to prevent unexpected behavior or malicious exploitation. Format strings can be manipulated to access memory locations, execute arbitrary code, or cause application crashes. Proper sanitization ensures that only expected and safe format specifiers are processed, reducing the risk of vulnerabilities such as format string attacks.", "threats_mitigated": ["Format string vulnerabilities", "Arbitrary code execution", "Information disclosure", "Application crashes"], "insecure_examples": [{"code": "printf(user_input);"}, {"code": "sprintf(buffer, user_input);"}], "secure_examples": [{"code": "printf('%s', user_input);"}, {"code": "snprintf(buffer, sizeof(buffer), '%s', user_input);"}], "verification_steps": ["Review code for any use of format strings with user input.", "Check if format strings are sanitized before being used.", "Ensure that only safe format specifiers are allowed.", "Test for potential format string vulnerabilities using fuzzing techniques."], "common_mistakes": ["Assuming user input is safe without validation.", "Using user input directly in format strings.", "Failing to limit the format specifiers to a safe subset."], "related_cwe": ["CWE-134", "CWE-20", "CWE-22"], "related_capec": ["CAPEC-137", "CAPEC-138", "CAPEC-139"], "attack_flow": "An attacker provides a malicious format string as input, which is then processed by the application without proper sanitization. This can lead to the execution of unintended commands, memory corruption, or information leakage, ultimately compromising the application's integrity and security."}
{"chapter_id": "V1", "chapter_name": "Encoding and Sanitization", "section_id": "V1.3", "section_name": "Sanitization", "req_id": "V1.3.11", "req_description": "Verify that the application sanitizes user input before passing to mail systems to protect against SMTP or IMAP injection.", "level": 2, "explanation": "This requirement emphasizes the importance of sanitizing user input that is used in email systems. Unsanitized input can allow attackers to manipulate email headers or content, leading to unauthorized actions such as email spoofing or injection of malicious commands.", "threats_mitigated": ["SMTP Injection", "IMAP Injection", "Email Spoofing", "Phishing Attacks"], "insecure_examples": [{"code": "String email = request.getParameter(\"email\");\nString subject = request.getParameter(\"subject\");\nString body = request.getParameter(\"body\");\n\nsendEmail(email, subject, body);"}, {"code": "String command = \"mail -s '\" + subject + \"' \" + email;\nRuntime.getRuntime().exec(command);"}], "secure_examples": [{"code": "String email = sanitizeInput(request.getParameter(\"email\"));\nString subject = sanitizeInput(request.getParameter(\"subject\"));\nString body = sanitizeInput(request.getParameter(\"body\"));\n\nsendEmail(email, subject, body);"}, {"code": "String safeEmail = sanitizeInput(email);\nString safeSubject = sanitizeInput(subject);\nString command = \"mail -s '\" + safeSubject + \"' \" + safeEmail;\nRuntime.getRuntime().exec(command);"}], "verification_steps": ["Review the input sanitization functions used in the application.", "Check if user inputs are validated against a whitelist of acceptable values.", "Ensure that email headers are properly encoded and escaped.", "Test for injection vulnerabilities by attempting to send crafted email inputs."], "common_mistakes": ["Failing to sanitize user input before using it in email headers.", "Using outdated or insufficient sanitization libraries.", "Not considering all possible email injection vectors."], "related_cwe": ["CWE-74", "CWE-20", "CWE-116"], "related_capec": ["CAPEC-137", "CAPEC-145", "CAPEC-151"], "attack_flow": "An attacker crafts a malicious input that includes SMTP commands or header injections. If the application does not sanitize this input, the email system processes it, allowing the attacker to manipulate the email delivery, potentially sending spam or phishing emails to unsuspecting users."}
{"chapter_id": "V1", "chapter_name": "Encoding and Sanitization", "section_id": "V1.3", "section_name": "Sanitization", "req_id": "V1.3.12", "req_description": "Verify that regular expressions are free from elements causing exponential backtracking, and ensure untrusted input is sanitized to mitigate ReDoS or Runaway Regex attacks.", "level": 3, "explanation": "This requirement emphasizes the importance of crafting efficient regular expressions that do not lead to performance degradation due to exponential backtracking. It also stresses the need to sanitize untrusted input to prevent attackers from exploiting regex patterns, which can lead to denial of service (DoS) through ReDoS attacks. Proper validation and sanitization steps help ensure that input is safe to process, thus maintaining application performance and security.", "threats_mitigated": ["ReDoS (Regular Expression Denial of Service)", "Runaway Regex attacks", "Denial of Service (DoS) attacks"], "insecure_examples": [{"code": "if (input.matches(\"(a|aa|aaa|...|a{100000}\") { /* process input */ }", "description": "This regex can lead to exponential backtracking with long input strings."}, {"code": "String sanitizedInput = input.replaceAll(\"[^a-zA-Z0-9]\", \"\");", "description": "This does not properly handle edge cases and can allow malicious input to pass through."}], "secure_examples": [{"code": "if (input.matches(\"^(a{1,10})$\")) { /* process input */ }", "description": "This regex is designed to avoid exponential backtracking by limiting repetitions."}, {"code": "String sanitizedInput = input.replaceAll(\"[^a-zA-Z0-9]\", \"\").trim();", "description": "This regex ensures only safe characters are retained and handles whitespace."}], "verification_steps": ["Review all regular expressions for potential exponential backtracking.", "Ensure that input validation is in place to reject unsafe characters.", "Test regex patterns with various input lengths to observe performance.", "Check for proper handling of edge cases in input sanitization."], "common_mistakes": ["Using overly complex regex patterns without performance considerations.", "Neglecting to sanitize input before applying regex matching.", "Assuming all regex patterns are safe without testing them against potential input."], "related_cwe": ["CWE-1333", "CWE-20", "CWE-117"], "related_capec": ["CAPEC-88", "CAPEC-89"], "attack_flow": "An attacker crafts input that exploits the regex pattern causing it to take an excessive amount of time to process. This can lead to application unresponsiveness, effectively creating a denial of service condition. The attacker may use various input lengths and patterns to trigger the backtracking behavior, overwhelming the server and leading to degraded performance or crashes."}
{"chapter_id": "V1", "chapter_name": "Encoding and Sanitization", "section_id": "V1.4", "section_name": "Memory, String, and Unmanaged Code", "req_id": "V1.4.1", "req_description": "Verify that the application uses memory-safe string, safer memory copy and pointer arithmetic to detect or prevent stack, buffer, or heap overflows.", "level": "2", "explanation": "This requirement emphasizes the importance of using memory-safe programming practices to prevent common vulnerabilities such as buffer overflows, which can lead to arbitrary code execution or crashes. Memory-safe strings and safer memory operations help ensure that data is handled correctly without exceeding allocated memory boundaries.", "threats_mitigated": ["Buffer Overflow", "Heap Overflow", "Stack Overflow", "Arbitrary Code Execution", "Denial of Service"], "insecure_examples": [{"code": "char buffer[10];\nstrcpy(buffer, user_input); // No bounds checking"}, {"code": "int *arr = (int *)malloc(sizeof(int) * 10);\narr[10] = 5; // Writing out of bounds"}], "secure_examples": [{"code": "char buffer[10];\nsnprintf(buffer, sizeof(buffer), \"%s\", user_input); // Safe string copy"}, {"code": "int *arr = (int *)malloc(sizeof(int) * 10);\nif (index < 10) arr[index] = 5; // Bounds checking"}], "verification_steps": ["Check for the use of memory-safe string functions (e.g., snprintf, strncat).", "Review pointer arithmetic to ensure it does not exceed allocated memory.", "Audit memory allocation and deallocation practices.", "Ensure that all array accesses are within bounds."], "common_mistakes": ["Using unsafe string functions like strcpy and strcat without bounds checking.", "Neglecting to validate user input length before copying to buffers.", "Failing to check the return values of memory allocation functions.", "Incorrectly calculating array indices leading to out-of-bounds access."], "related_cwe": ["CWE-120", "CWE-121", "CWE-787", "CWE-131"], "related_capec": ["CAPEC-66", "CAPEC-89", "CAPEC-104"], "attack_flow": "An attacker can exploit vulnerabilities related to memory safety by providing input that exceeds the allocated buffer size. This can overwrite adjacent memory, leading to control of program execution flow. By manipulating pointers or memory locations, the attacker can execute arbitrary code or crash the application."}
{"chapter_id": "V1", "chapter_name": "Encoding and Sanitization", "section_id": "V1.4", "section_name": "Memory, String, and Unmanaged Code", "req_id": "V1.4.2", "req_description": "Verify that sign, range, and input validation techniques are used to prevent integer overflows.", "level": "2", "explanation": "This requirement emphasizes the importance of validating input values to ensure they fall within expected ranges and types. Integer overflows can occur when an operation attempts to create a numeric value that exceeds the maximum limit of the data type, leading to unexpected behavior, security vulnerabilities, or application crashes. Developers must implement checks to validate that the input values are within safe boundaries before processing them.", "threats_mitigated": ["Integer Overflow", "Denial of Service (DoS)", "Data Corruption", "Arbitrary Code Execution"], "insecure_examples": ["int result = a + b; // No validation, could cause overflow", "int value = userInput; // Direct assignment without checks"], "secure_examples": ["if (a > Integer.MAX_VALUE - b) throw new IllegalArgumentException('Integer overflow'); int result = a + b;", "int value; if (isValidInput(userInput)) { value = userInput; } else { throw new IllegalArgumentException('Invalid input'); }"], "verification_steps": ["Check for input validation on all integer inputs.", "Ensure that arithmetic operations are checked for potential overflow.", "Review error handling for cases where overflow might occur.", "Verify that boundary conditions are tested in unit tests."], "common_mistakes": ["Failing to validate input sizes and ranges.", "Not considering the limits of data types during calculations.", "Assuming that all inputs are safe without proper checks."], "related_cwe": ["CWE-190", "CWE-680", "CWE-121"], "related_capec": ["CAPEC-137", "CAPEC-149", "CAPEC-155"], "attack_flow": "An attacker may exploit an integer overflow by providing input that exceeds the maximum value an integer can hold. This can lead to unexpected behavior, such as wrapping around to a negative number or a smaller positive number, which can then be used to bypass security checks or manipulate application logic, potentially leading to unauthorized access or system crashes."}
{"chapter_id": "V1", "chapter_name": "Encoding and Sanitization", "section_id": "V1.4", "section_name": "Memory, String, and Unmanaged Code", "req_id": "V1.4.3", "req_description": "Verify that dynamically allocated memory and resources are released, and that references or pointers to freed memory are removed or set to null to prevent dangling pointers and use-after-free vulnerabilities.", "level": 2, "explanation": "This requirement emphasizes the importance of proper memory management in applications. When memory is dynamically allocated, it is crucial to ensure that it is properly released when no longer needed. Failing to do so can lead to memory leaks, which can exhaust system resources. Additionally, if pointers to freed memory are not cleared, it can result in dangling pointers, which may allow attackers to exploit the application by accessing invalid memory locations, leading to use-after-free vulnerabilities. This can result in arbitrary code execution or data corruption.", "threats_mitigated": ["Dangling Pointer Attacks", "Use-After-Free Vulnerabilities", "Memory Leaks", "Arbitrary Code Execution"], "insecure_examples": [{"code": "int* ptr = (int*)malloc(sizeof(int));\n// Some operations on ptr\nfree(ptr);\n// ptr is still used here\nint value = *ptr;"}, {"code": "char* buffer = (char*)malloc(256);\n// Operations on buffer\nfree(buffer);\n// buffer is still used here\nstrcpy(buffer, \"New Data\");"}], "secure_examples": [{"code": "int* ptr = (int*)malloc(sizeof(int));\n// Some operations on ptr\nfree(ptr);\nptr = NULL; // Clear the pointer"}, {"code": "char* buffer = (char*)malloc(256);\n// Operations on buffer\nfree(buffer);\nbuffer = NULL; // Clear the pointer"}], "verification_steps": ["Check for all dynamic memory allocations in the code.", "Ensure that each allocation has a corresponding deallocation.", "Verify that pointers are set to NULL after memory is freed.", "Review the code for any use of freed memory.", "Conduct static analysis to identify potential memory management issues."], "common_mistakes": ["Forgetting to free dynamically allocated memory.", "Using memory after it has been freed.", "Not setting pointers to NULL after freeing them.", "Overlooking error handling for memory allocation failures."], "related_cwe": ["CWE-416", "CWE-824", "CWE-401"], "related_capec": ["CAPEC-137", "CAPEC-145"], "attack_flow": "An attacker could exploit a use-after-free vulnerability by first triggering the application to free a memory block while still holding a reference to it. They could then allocate new memory that is adjacent to the freed memory block. When the application subsequently accesses the dangling pointer, it may inadvertently access the attacker's data, allowing them to execute arbitrary code or manipulate application behavior."}
{"chapter_id": "V1", "chapter_name": "Encoding and Sanitization", "section_id": "V1.5", "section_name": "Safe Deserialization", "req_id": "V1.5.1", "req_description": "Verify that the application configures XML parsers to use a restrictive configuration and that unsafe features such as resolving external entities are disabled to prevent XML eXternal Entity (XXE) attacks.", "level": "1", "explanation": "This requirement emphasizes the importance of configuring XML parsers securely to mitigate risks associated with XML processing. By disabling features that allow the resolution of external entities, applications can prevent attackers from exploiting vulnerabilities that could lead to data leakage, denial of service, or even remote code execution. Proper configuration ensures that only safe and necessary features are enabled, reducing the attack surface.", "threats_mitigated": ["XML External Entity (XXE) attacks", "Data exfiltration", "Denial of Service (DoS)", "Remote code execution"], "insecure_examples": [{"code": "<!DOCTYPE foo [ <!ENTITY xxe SYSTEM \"file:///etc/passwd\"> ]><foo>&xxe;</foo>", "description": "This XML document allows the inclusion of an external entity, which can lead to unauthorized access to sensitive files."}, {"code": "DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", true);"}], "secure_examples": [{"code": "DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);"}, {"code": "factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);"}], "verification_steps": ["Check that XML parsers are configured to disable external entity resolution.", "Review the code for any use of XML parsing libraries and their configurations.", "Ensure that the application does not allow user-controlled XML input without proper validation."], "common_mistakes": ["Not disabling external entity resolution in XML parsers.", "Using default parser configurations without reviewing security implications.", "Allowing user input to dictate XML structure without validation."], "related_cwe": ["CWE-611", "CWE-20", "CWE-94"], "related_capec": ["CAPEC-137", "CAPEC-151"], "attack_flow": "An attacker can craft a malicious XML input that includes external entities. If the XML parser is misconfigured and allows external entity resolution, the attacker can exploit this to read sensitive files from the server, perform denial of service attacks by including large files, or execute arbitrary code if the application processes the external entity in a vulnerable way."}
{"chapter_id": "V1", "chapter_name": "Encoding and Sanitization", "section_id": "V1.5", "section_name": "Safe Deserialization", "req_id": "V1.5.2", "req_description": "Verify that deserialization of untrusted data enforces safe input handling, such as using an allowlist of object types or restricting client-defined object types, to prevent deserialization attacks. Deserialization mechanisms that are explicitly defined as insecure must not be used with untrusted input.", "level": "2", "explanation": "This requirement emphasizes the importance of safely handling deserialized data, particularly when the data originates from untrusted sources. It mandates the use of an allowlist to specify which object types are permissible during deserialization. This helps mitigate risks associated with deserialization attacks, where an attacker could manipulate the input data to instantiate malicious objects that could compromise the application or its data integrity.", "threats_mitigated": ["Remote Code Execution", "Denial of Service", "Data Tampering", "Unauthorized Access"], "insecure_examples": ["ObjectInputStream ois = new ObjectInputStream(inputStream); Object obj = ois.readObject();", "data = (MyClass) deserialize(input);"], "secure_examples": ["if (isAllowedType(input.getClass())) { Object obj = ois.readObject(); } else { throw new SecurityException('Disallowed type'); }", "data = (MyClass) secureDeserialize(input);"], "verification_steps": ["Check if deserialization uses an allowlist of object types.", "Verify that insecure deserialization methods are not used.", "Review the implementation for proper validation of input data.", "Ensure that error handling does not expose sensitive information."], "common_mistakes": ["Using generic deserialization methods without type checks.", "Failing to validate the input data before deserialization.", "Neglecting to update allowlists when new object types are introduced."], "related_cwe": ["CWE-502", "CWE-776", "CWE-20"], "related_capec": ["CAPEC-138", "CAPEC-164"], "attack_flow": "An attacker crafts a malicious payload that, when deserialized, creates an object that executes arbitrary code or alters application state. This can lead to unauthorized actions being performed on behalf of the user or the application, potentially compromising sensitive data or service availability."}
{"chapter_id": "V1", "chapter_name": "Encoding and Sanitization", "section_id": "V1.5", "section_name": "Safe Deserialization", "req_id": "V1.5.3", "req_description": "Verify that different parsers used in the application for the same data type (e.g., JSON parsers, XML parsers, URL parsers), perform parsing in a consistent way and use the same character encoding mechanism to avoid issues such as JSON Interoperability vulnerabilities or different URI or file parsing behavior being exploited in Remote File Inclusion (RFI) or Server-side Request Forgery (SSRF) attacks.", "level": 3, "explanation": "This requirement emphasizes the importance of consistency in how data is parsed across different components of an application. Inconsistent parsing can lead to vulnerabilities where data is interpreted differently by various parsers, potentially allowing attackers to exploit these differences to inject malicious data or manipulate the applicationâ€™s behavior. Ensuring that all parsers adhere to the same character encoding standards helps mitigate risks associated with data handling and processing.", "threats_mitigated": ["JSON Interoperability vulnerabilities", "Remote File Inclusion (RFI)", "Server-side Request Forgery (SSRF)"], "insecure_examples": [{"code": "json_decode($input); // No encoding check"}, {"code": "xml_parse($input); // Different encoding assumptions"}], "secure_examples": [{"code": "$input = mb_convert_encoding($input, 'UTF-8'); json_decode($input); // Ensures consistent encoding"}, {"code": "$input = mb_convert_encoding($input, 'UTF-8'); xml_parse($input); // Ensures consistent encoding"}], "verification_steps": ["Review the parsers used in the application for consistency.", "Check that all parsers use the same character encoding mechanism.", "Test data parsing with various input formats to ensure consistent behavior.", "Verify that error handling is consistent across different parsers."], "common_mistakes": ["Using different character encodings for different data types.", "Failing to validate input before parsing.", "Assuming that all parsers handle encoding in the same way."], "related_cwe": ["CWE-20", "CWE-74", "CWE-117"], "related_capec": ["CAPEC-137", "CAPEC-143"], "attack_flow": "An attacker may craft a payload that takes advantage of inconsistent parsing between different components. For example, if a JSON parser accepts a certain character encoding while an XML parser does not, the attacker could exploit this discrepancy to inject malicious data that is only interpreted correctly by one parser, leading to unauthorized access or execution of arbitrary code."}
{"chapter_id": "V2", "chapter_name": "Validation and Business Logic", "section_id": "V2.1", "section_name": "Validation and Business Logic Documentation", "req_id": "V2.1.1", "req_description": "Verify that the application's documentation defines input validation rules for how to check the validity of data items against an expected structure. This could be common data formats such as credit card numbers, email addresses, telephone numbers, or it could be an internal data format.", "level": "1", "explanation": "This requirement emphasizes the importance of having clear and comprehensive documentation for input validation rules within an application. Proper documentation ensures that developers understand how to validate data inputs correctly and consistently, which is crucial for preventing invalid data from being processed. The documentation should cover various data formats and structures expected by the application, allowing for effective validation mechanisms to be implemented.", "threats_mitigated": ["Injection Attacks", "Data Corruption", "Denial of Service", "Information Disclosure"], "insecure_examples": ["if (input != null) { processInput(input); }", "processInput(userInput); // No validation or checks performed"], "secure_examples": ["if (isValidEmail(input)) { processInput(input); }", "if (isValidCreditCard(input)) { processInput(input); }"], "verification_steps": ["Review the application documentation for input validation rules.", "Check if the documentation covers all expected data formats.", "Verify that implemented validation logic aligns with documented rules.", "Ensure that edge cases and error handling are addressed in the documentation."], "common_mistakes": ["Failing to document validation rules comprehensively.", "Assuming that input validation is unnecessary for certain data types.", "Not updating documentation when validation rules change."], "related_cwe": ["CWE-20: Improper Input Validation", "CWE-117: Improper Output Neutralization for Logs", "CWE-74: Injection"], "related_capec": ["CAPEC-137: SQL Injection", "CAPEC-162: Command Injection", "CAPEC-118: Cross-Site Scripting (XSS)"], "attack_flow": "An attacker may exploit the absence of proper input validation documentation by submitting malformed or unexpected data inputs. If developers are unaware of the expected input formats due to inadequate documentation, they may fail to implement necessary validation checks, leading to vulnerabilities such as injection attacks or data corruption. This can result in unauthorized access, data breaches, or application crashes."}
{"chapter_id": "V2", "chapter_name": "Validation and Business Logic", "section_id": "V2.1", "section_name": "Validation and Business Logic Documentation", "req_id": "V2.1.2", "req_description": "Verify that the application's documentation defines how to validate the logical and contextual consistency of combined data items, such as checking that suburb and ZIP code match.", "level": "2", "explanation": "This requirement emphasizes the importance of having comprehensive documentation that outlines the validation rules for data integrity. It ensures that developers and stakeholders understand how to check that related data fields are consistent with each other, which is critical for maintaining data quality and preventing logical errors in the application.", "threats_mitigated": ["Data integrity issues", "Inconsistent data leading to application errors", "Business logic bypass", "User confusion due to incorrect data"], "insecure_examples": ["if (suburb != '' && zipCode != '' && suburbZipMap[suburb] != zipCode) { throw new Error('Inconsistent suburb and ZIP code'); }", "let isValid = suburb && zipCode; // No validation logic implemented"], "secure_examples": ["if (suburb !== '' && zipCode !== '' && suburbZipMap[suburb] === zipCode) { /* Valid data */ } else { throw new Error('Inconsistent suburb and ZIP code'); }", "let isValid = suburb && zipCode && suburbZipMap[suburb] === zipCode; // Proper validation logic implemented"], "verification_steps": ["Check that documentation exists for data validation rules.", "Verify that the rules include checks for logical consistency between related fields.", "Ensure that examples in the documentation illustrate correct validation logic.", "Review the implementation to confirm it adheres to the documented rules."], "common_mistakes": ["Failing to document validation rules, leading to inconsistent implementations.", "Assuming data is valid without performing necessary checks.", "Not updating documentation when validation rules change."], "related_cwe": ["CWE-20: Improper Input Validation", "CWE-75: Improper Neutralization of Special Elements in Data Query Logic", "CWE-476: NULL Pointer Dereference"], "related_capec": ["CAPEC-137: Data Manipulation", "CAPEC-149: Data Injection", "CAPEC-151: Data Corruption"], "attack_flow": "An attacker may exploit the lack of proper validation documentation by submitting inconsistent data, such as a suburb that does not match the corresponding ZIP code. If the application does not validate this relationship, it could lead to incorrect processing of user data, potential business logic errors, or exploitation of vulnerabilities in the application logic."}
{"chapter_id": "V2", "chapter_name": "Validation and Business Logic", "section_id": "V2.1", "section_name": "Validation and Business Logic Documentation", "req_id": "V2.1.3", "req_description": "Verify that expectations for business logic limits and validations are documented, including both per-user and globally across the application.", "level": "2", "explanation": "This requirement emphasizes the importance of documenting the business logic validations and limits that are applied within the application. It ensures that both the developers and stakeholders have a clear understanding of how the application should behave under various conditions, including any limits on user actions or data inputs. Proper documentation helps in maintaining the application, conducting audits, and ensuring compliance with business rules.", "threats_mitigated": ["Business Logic Errors", "Unauthorized Access", "Data Integrity Issues"], "insecure_examples": ["if (userInput > MAX_LIMIT) { /* no error handling */ }", "function validateUserAction(action) { /* no documentation of limits */ }"], "secure_examples": ["if (userInput > MAX_LIMIT) { throw new Error('Input exceeds maximum limit'); }", "function validateUserAction(action) { /* Documented limits: Action X is allowed only for users with role Y */ }"], "verification_steps": ["Check if business logic limits are documented.", "Review documentation for clarity and completeness.", "Ensure that documentation includes per-user and global limits.", "Verify that the application code adheres to the documented limits."], "common_mistakes": ["Failing to document edge cases and limits.", "Assuming all users have the same permissions without documentation.", "Not updating documentation when business logic changes."], "related_cwe": ["CWE-20", "CWE-284", "CWE-703"], "related_capec": ["CAPEC-137", "CAPEC-148"], "attack_flow": "An attacker may exploit undocumented business logic by manipulating inputs or actions that exceed the expected limits. Without proper documentation, developers may not anticipate these edge cases, leading to vulnerabilities such as unauthorized access or data corruption."}
{"chapter_id": "V2", "chapter_name": "Validation and Business Logic", "section_id": "V2.2", "section_name": "Input Validation", "req_id": "V2.2.1", "req_description": "Verify that input is validated to enforce business or functional expectations for that input. This should either use positive validation against an allow list of values, patterns, and ranges, or be based on comparing the input to an expected structure and logical limits according to predefined rules. For L1, this can focus on input which is used to make specific business or security decisions. For L2 and up, this should apply to all input.", "level": "1", "explanation": "This requirement emphasizes the necessity of validating user input to ensure it meets defined business rules and expectations. It encourages the use of allow lists (whitelists) to permit only safe and expected values, patterns, or ranges. This is crucial to prevent unexpected behavior or security vulnerabilities that could arise from malicious or malformed input.", "threats_mitigated": ["SQL Injection", "Cross-Site Scripting (XSS)", "Command Injection", "Buffer Overflow", "Data Corruption"], "insecure_examples": [{"code": "if (input.length > 10) { process(input); }", "description": "This example does not validate the content of 'input', allowing potentially harmful data to be processed."}, {"code": "let userId = req.body.userId; if (userId) { db.query('SELECT * FROM users WHERE id = ' + userId); }", "description": "This example directly uses user input in a database query without validation, making it vulnerable to SQL injection."}], "secure_examples": [{"code": "const allowedValues = ['value1', 'value2', 'value3']; if (allowedValues.includes(input)) { process(input); }", "description": "This example uses an allow list to validate input before processing."}, {"code": "let userId = parseInt(req.body.userId, 10); if (!isNaN(userId) && userId > 0) { db.query('SELECT * FROM users WHERE id = ?', [userId]); }", "description": "This example validates the user input as a positive integer before using it in a database query."}], "verification_steps": ["Check if input is validated against an allow list or predefined patterns.", "Ensure that validation logic is applied consistently across all inputs.", "Review the handling of edge cases and unexpected input values.", "Verify that error handling does not expose sensitive information."], "common_mistakes": ["Using negative validation (blacklisting) instead of positive validation (whitelisting).", "Failing to validate input for all user inputs, especially in critical areas.", "Assuming that input is safe without proper checks.", "Not considering the context in which input is used."], "related_cwe": ["CWE-20", "CWE-74", "CWE-89", "CWE-117"], "related_capec": ["CAPEC-37", "CAPEC-139", "CAPEC-132"], "attack_flow": "An attacker may exploit a lack of input validation by sending crafted input that deviates from expected values. If the application processes this input without validation, it can lead to unauthorized access, data manipulation, or execution of arbitrary commands, resulting in data breaches or system compromise."}
{"chapter_id": "V2", "chapter_name": "Validation and Business Logic", "section_id": "V2.2", "section_name": "Input Validation", "req_id": "V2.2.2", "req_description": "Verify that the application is designed to enforce input validation at a trusted service layer. While client-side validation improves usability and should be encouraged, it must not be relied upon as a security control.", "level": "1", "explanation": "This requirement emphasizes the importance of implementing input validation on the server side, ensuring that all inputs are validated before processing. Client-side validation can be bypassed by an attacker, so server-side validation is essential for maintaining security. It ensures that only valid and expected data is processed by the application, preventing various types of attacks such as SQL injection and cross-site scripting (XSS).", "threats_mitigated": ["SQL Injection", "Cross-Site Scripting (XSS)", "Command Injection", "Path Traversal"], "insecure_examples": ["if (userInput.length < 5) { return; } // Only checks length on client-side", "let sanitizedInput = userInput; // No validation or sanitization performed"], "secure_examples": ["if (userInput.length >= 5 && /^[a-zA-Z0-9]*$/.test(userInput)) { processInput(userInput); } // Validates input on server-side", "let sanitizedInput = sanitize(userInput); // Proper validation and sanitization performed"], "verification_steps": ["Check if input validation is implemented on the server-side.", "Review the code for input validation rules and patterns.", "Ensure that client-side validation is complemented by server-side validation.", "Test the application with malicious inputs to verify that they are rejected."], "common_mistakes": ["Relying solely on client-side validation.", "Not validating input types or formats.", "Failing to handle unexpected input gracefully.", "Neglecting to update validation rules as the application evolves."], "related_cwe": ["CWE-20", "CWE-117", "CWE-74"], "related_capec": ["CAPEC-137", "CAPEC-132"], "attack_flow": "An attacker can bypass client-side validation by manipulating requests sent to the server. If the server does not enforce its own validation, the attacker can submit malicious input, leading to unauthorized actions, data breaches, or system compromise."}
{"chapter_id": "V2", "chapter_name": "Validation and Business Logic", "section_id": "V2.2", "section_name": "Input Validation", "req_id": "V2.2.3", "req_description": "Verify that the application ensures that combinations of related data items are reasonable according to the pre-defined rules.", "level": "2", "explanation": "This requirement emphasizes the importance of validating not only individual data items but also the relationships and dependencies between them. For instance, if a user submits a form with a start date and an end date, the application should verify that the end date is not earlier than the start date. This ensures that the data makes logical sense and adheres to business rules.", "threats_mitigated": ["Data Integrity Violations", "Business Logic Flaws", "Inconsistent Data States"], "insecure_examples": ["if (startDate > endDate) { /* No validation logic */ }", "if (userInput.age < 0) { /* Accepting negative age without checks */ }"], "secure_examples": ["if (startDate <= endDate) { /* Valid combination */ } else { throw new ValidationException('End date must be after start date'); }", "if (userInput.age >= 0) { /* Valid age check */ } else { throw new ValidationException('Age cannot be negative'); }"], "verification_steps": ["Review data validation logic for related fields.", "Check for business rules implementation in the code.", "Ensure that validation errors are properly handled and reported.", "Test with edge cases to verify that combinations are validated correctly."], "common_mistakes": ["Failing to validate combinations of fields together.", "Assuming that individual field validation is sufficient.", "Not considering business rules when validating input."], "related_cwe": ["CWE-20: Improper Input Validation", "CWE-75: Improper Handling of Special Cases"], "related_capec": ["CAPEC-137: Data Injection", "CAPEC-146: Logic Flaw"], "attack_flow": "An attacker may exploit the lack of validation on related data items by submitting a combination of inputs that violate business rules, leading to unexpected application behavior, data corruption, or unauthorized access to resources. For example, if a booking application does not validate that the end date is after the start date, an attacker could create a booking that overlaps incorrectly, causing financial loss or service disruption."}
{"chapter_id": "V2", "chapter_name": "Validation and Business Logic", "section_id": "V2.3", "section_name": "Business Logic Security", "req_id": "V2.3.1", "req_description": "Verify that the application will only process business logic flows for the same user in the expected sequential step order and without skipping steps.", "level": 1, "explanation": "This requirement ensures that users follow a defined sequence of actions within the application, preventing unauthorized access to certain functionalities that may be dependent on prior steps. By enforcing this order, the application can maintain the integrity of the business logic and prevent users from manipulating the flow to their advantage.", "threats_mitigated": ["Unauthorized access to sensitive functionalities", "Business logic manipulation", "Data integrity issues"], "insecure_examples": [{"code": "if (userStep == 2) { processStep2(); } else if (userStep == 3) { processStep3(); } // Allows skipping step 2"}, {"code": "processStep3(); // Directly accessing step 3 without validating previous steps"}], "secure_examples": [{"code": "if (userStep == expectedStep) { processStep(expectedStep); } else { throw new Error('Invalid step sequence'); }"}, {"code": "function processStep(currentStep) { if (currentStep == expectedStep) { // Process step logic } else { throw new Error('Step skipped or out of order'); } }"}], "verification_steps": ["Review the application flow to ensure each step is validated against the user's current state.", "Check that the application throws errors or prevents actions when users attempt to skip steps.", "Test the application with various user roles to ensure that business logic flows are correctly enforced."], "common_mistakes": ["Not validating the user's current step before processing a request.", "Allowing direct access to endpoints without enforcing the expected sequence.", "Assuming that the user will always follow the intended flow without checks."], "related_cwe": ["CWE-20", "CWE-841"], "related_capec": ["CAPEC-137", "CAPEC-146"], "attack_flow": "An attacker may attempt to access a functionality that is only available after completing prior steps. By manipulating the request or the application state, the attacker can bypass the intended flow and execute actions that should not be permitted, leading to unauthorized access or data corruption."}
{"chapter_id": "V2", "chapter_name": "Validation and Business Logic", "section_id": "V2.3", "section_name": "Business Logic Security", "req_id": "V2.3.2", "req_description": "Verify that business logic limits are implemented per the application's documentation to avoid business logic flaws being exploited.", "level": "2", "explanation": "This requirement emphasizes the importance of implementing business logic limits as defined in the application's documentation. It ensures that the application adheres to its intended operational constraints and prevents unauthorized actions that could lead to exploitation of business logic flaws. Proper implementation helps maintain data integrity and prevents abuse of the application's functionalities.", "threats_mitigated": ["Unauthorized access to sensitive functionalities", "Manipulation of business processes", "Data leakage through improper logic flows", "Denial of service through excessive resource consumption"], "insecure_examples": [{"code_snippet": "if (userRole == 'admin') { performSensitiveAction(); }"}, {"code_snippet": "if (requestAmount > 1000) { processTransaction(); }"}], "secure_examples": [{"code_snippet": "if (userRole == 'admin' && isActionAllowed(userId, 'performSensitiveAction')) { performSensitiveAction(); }"}, {"code_snippet": "if (requestAmount <= 1000 && isTransactionValid(userId, requestAmount)) { processTransaction(); }"}], "verification_steps": ["Review the application's documentation for defined business logic limits.", "Check the implementation of business logic limits against the documentation.", "Test the application to ensure that limits are enforced correctly.", "Verify that unauthorized users cannot bypass business logic checks."], "common_mistakes": ["Failing to update business logic limits when application features change.", "Hardcoding values instead of using configuration settings.", "Neglecting to validate user roles and permissions before executing sensitive actions."], "related_cwe": ["CWE-20", "CWE-284", "CWE-639"], "related_capec": ["CAPEC-104", "CAPEC-137", "CAPEC-148"], "attack_flow": "An attacker may exploit business logic flaws by manipulating inputs or bypassing checks that enforce business logic limits. For example, if the application allows a user to request a transaction without validating their role or the amount, an attacker could perform unauthorized actions, leading to financial loss or data compromise."}
{"chapter_id": "V2", "chapter_name": "Validation and Business Logic", "section_id": "V2.3", "section_name": "Business Logic Security", "req_id": "V2.3.3", "req_description": "Verify that transactions are being used at the business logic level such that either a business logic operation succeeds in its entirety or it is rolled back to the previous correct state.", "level": "2", "explanation": "This requirement ensures that any business logic operation is atomic, meaning that it either completes fully or not at all. This is crucial for maintaining data integrity and preventing partial updates that could lead to inconsistent application states. For example, if a financial transaction consists of debiting one account and crediting another, both actions should either succeed or fail together.", "threats_mitigated": ["Data corruption", "Inconsistent application state", "Business logic abuse", "Transaction replay attacks"], "insecure_examples": ["if (debitAccount(amount)) { creditAccount(amount); }", "try { debitAccount(amount); } catch { } // No rollback implemented"], "secure_examples": ["try { beginTransaction(); debitAccount(amount); creditAccount(amount); commitTransaction(); } catch { rollbackTransaction(); }", "if (debitAccount(amount) && creditAccount(amount)) { commitTransaction(); } else { rollbackTransaction(); }"], "verification_steps": ["Check that all business logic operations are wrapped in transactions.", "Ensure that rollback mechanisms are in place for failed operations.", "Review logs for transaction success/failure states.", "Test scenarios where operations should fail and verify rollback occurs."], "common_mistakes": ["Failing to implement transaction management for critical operations.", "Assuming that operations will always succeed without handling exceptions.", "Not considering the implications of partial updates on data integrity."], "related_cwe": ["CWE-400: Uncontrolled Resource Consumption", "CWE-703: Improper Check or Handling of Exceptional Conditions", "CWE-754: Improper Check for Unusual or Exceptional Conditions"], "related_capec": ["CAPEC-134: Transaction Replay", "CAPEC-147: Data Corruption via Inconsistent State", "CAPEC-153: Business Logic Manipulation"], "attack_flow": "An attacker may exploit the absence of proper transaction handling by initiating a series of operations that only partially complete, leading to a corrupted state. For instance, if an attacker can manipulate a transaction to succeed in debiting an account but fail in crediting another, they can effectively steal funds or manipulate data integrity."}
{"chapter_id": "V2", "chapter_name": "Validation and Business Logic", "section_id": "V2.3", "section_name": "Business Logic Security", "req_id": "V2.3.4", "req_description": "Verify that business logic level locking mechanisms are used to ensure that limited quantity resources (such as theater seats or delivery slots) cannot be double-booked by manipulating the application's logic.", "level": 2, "explanation": "This requirement emphasizes the importance of implementing locking mechanisms at the business logic level to prevent double-booking of limited resources. It ensures that once a resource is reserved, it cannot be booked again until the transaction is completed or canceled. This is crucial for maintaining the integrity of resource allocation in applications that handle limited availability items.", "threats_mitigated": ["Double booking", "Resource contention", "Race conditions"], "insecure_examples": [{"code": "if (isSeatAvailable(seatId)) { bookSeat(seatId); }"}, {"code": "if (isDeliverySlotAvailable(slotId)) { reserveSlot(slotId); }"}], "secure_examples": [{"code": "if (lockResource(seatId)) { bookSeat(seatId); unlockResource(seatId); }"}, {"code": "if (lockResource(slotId)) { reserveSlot(slotId); unlockResource(slotId); }"}], "verification_steps": ["Check if locking mechanisms are implemented in the business logic.", "Review code to ensure that resource allocation is atomic and thread-safe.", "Test the application for race conditions by simulating concurrent booking attempts."], "common_mistakes": ["Failing to implement locking mechanisms.", "Assuming that database constraints alone are sufficient for resource management.", "Not considering concurrency in resource allocation logic."], "related_cwe": ["CWE-362", "CWE-367"], "related_capec": ["CAPEC-137", "CAPEC-147"], "attack_flow": "An attacker may attempt to exploit the lack of locking mechanisms by rapidly sending multiple booking requests for the same resource. If the application processes these requests without proper synchronization, it may allow multiple bookings for the same resource, leading to financial loss and customer dissatisfaction."}
{"chapter_id": "V2", "chapter_name": "Validation and Business Logic", "section_id": "V2.3", "section_name": "Business Logic Security", "req_id": "V2.3.5", "req_description": "Verify that high-value business logic flows require multi-user approval to prevent unauthorized or accidental actions. This could include but is not limited to large monetary transfers, contract approvals, access to classified information, or safety overrides in manufacturing.", "level": 3, "explanation": "This requirement emphasizes the importance of implementing multi-user approval processes for critical business operations. By ensuring that multiple individuals must authorize significant actions, organizations can mitigate risks associated with unauthorized access and human error. This is particularly crucial for high-stakes transactions where the potential for loss or damage is significant.", "threats_mitigated": ["Unauthorized transactions", "Accidental approvals", "Fraudulent activities", "Insider threats"], "insecure_examples": [{"code_snippet": "function approveTransaction(userId) { if (isAuthorized(userId)) { executeTransaction(); } }"}, {"code_snippet": "function transferFunds(amount) { executeTransfer(amount); } // No approval needed"}], "secure_examples": [{"code_snippet": "function approveTransaction(userId) { if (isAuthorized(userId) && requiresApproval()) { requestMultiUserApproval(); } }"}, {"code_snippet": "function transferFunds(amount) { if (isApprovedByMultipleUsers()) { executeTransfer(amount); } }"}], "verification_steps": ["Check if multi-user approval is implemented for high-value transactions.", "Review the approval workflow to ensure it requires input from multiple users.", "Test the system to verify that unauthorized users cannot bypass the approval process.", "Examine logs to confirm that all approvals are recorded and traceable."], "common_mistakes": ["Assuming single-user approval is sufficient for high-value transactions.", "Neglecting to implement a robust approval workflow.", "Failing to log approval actions for audit purposes.", "Overlooking the need for role-based access control in the approval process."], "related_cwe": ["CWE-284", "CWE-20"], "related_capec": ["CAPEC-130", "CAPEC-151"], "attack_flow": "An attacker could exploit the lack of a multi-user approval process by impersonating an authorized user or manipulating the system to execute a high-value transaction without proper oversight. This could lead to unauthorized fund transfers or access to sensitive information, resulting in financial loss or data breaches."}
{"chapter_id": "V2", "chapter_name": "Validation and Business Logic", "section_id": "V2.4", "section_name": "Anti-automation", "req_id": "V2.4.1", "req_description": "Verify that anti-automation controls are in place to protect against excessive calls to application functions that could lead to data exfiltration, garbage-data creation, quota exhaustion, rate-limit breaches, denial-of-service, or overuse of costly resources.", "level": "2", "explanation": "This requirement emphasizes the necessity of implementing mechanisms that limit the frequency and volume of requests made to an application. Such controls are crucial to prevent abuse by automated scripts or bots, which can overwhelm the system, exploit vulnerabilities, or extract sensitive information without proper authorization.", "threats_mitigated": ["Denial of Service (DoS)", "Data Exfiltration", "Quota Exhaustion", "Garbage Data Creation", "Rate Limit Breaches"], "insecure_examples": [{"code_snippet": "app.get('/api/resource', (req, res) => { /* No rate limiting */ })"}, {"code_snippet": "function processRequest(req) { /* Accepts all requests without validation */ }"}], "secure_examples": [{"code_snippet": "app.get('/api/resource', rateLimit({ windowMs: 15 * 60 * 1000, max: 100 }), (req, res) => { /* Rate limiting applied */ })"}, {"code_snippet": "function processRequest(req) { if (isRequestValid(req)) { /* Process request */ } else { /* Reject request */ } }"}], "verification_steps": ["Check for implementation of rate limiting on API endpoints.", "Verify that the application logs excessive request attempts.", "Review the application for any mechanisms that detect and block automated scripts.", "Ensure that user input is validated to prevent abuse."], "common_mistakes": ["Failing to implement rate limiting on critical endpoints.", "Not logging or monitoring failed request attempts.", "Assuming that user-agent checks are sufficient to prevent automation."], "related_cwe": ["CWE-307: Improper Restriction of Excessive Authentication Attempts", "CWE-400: Uncontrolled Resource Consumption"], "related_capec": ["CAPEC-137: Resource Exhaustion", "CAPEC-147: Denial of Service via Resource Exhaustion"], "attack_flow": "An attacker utilizes automated scripts to send a high volume of requests to the application. Without anti-automation controls, these requests can overwhelm the server, leading to service unavailability for legitimate users. Additionally, the attacker may exploit vulnerabilities to extract sensitive data or manipulate application behavior."}
{"chapter_id": "V2", "chapter_name": "Validation and Business Logic", "section_id": "V2.4", "section_name": "Anti-automation", "req_id": "V2.4.2", "req_description": "Verify that business logic flows require realistic human timing, preventing excessively rapid transaction submissions.", "level": "3", "explanation": "This requirement ensures that applications implement timing constraints that mimic human interaction speeds. By doing so, it mitigates the risk of automated bots rapidly submitting transactions, which can lead to abuse, such as denial of service or exploitation of business logic flaws.", "threats_mitigated": ["Denial of Service (DoS)", "Business Logic Abuse", "Credential Stuffing", "Brute Force Attacks"], "insecure_examples": ["if (transactionCount > 10) { processTransaction(); } // No timing checks", "submitButton.onclick = function() { processTransaction(); }; // Rapid submissions allowed"], "secure_examples": ["if (transactionCount > 10 && isHumanTimingValid()) { processTransaction(); } // Timing checks implemented", "submitButton.onclick = function() { if (isHumanTimingValid()) { processTransaction(); } }; // Validates timing before processing"], "verification_steps": ["Review transaction submission code for timing checks.", "Check for rate limiting on transaction submissions.", "Test the application with automated tools to ensure it cannot process requests faster than human speed.", "Verify that logs capture rapid submission attempts."], "common_mistakes": ["Neglecting to implement timing checks on transaction submissions.", "Assuming that other security measures (like CAPTCHA) are sufficient without additional timing constraints.", "Not considering the impact of automated tools on business logic flows."], "related_cwe": ["CWE-20: Improper Input Validation", "CWE-770: Allocation of Resources Without Limits", "CWE-400: Uncontrolled Resource Consumption"], "related_capec": ["CAPEC-104: Automated Credential Guessing", "CAPEC-168: Automated Submission of Data", "CAPEC-142: Denial of Service via Resource Exhaustion"], "attack_flow": "An attacker uses automated scripts to submit transactions at a speed that exceeds human capabilities. Without proper timing checks, the application processes these transactions, leading to potential abuse such as overwhelming the system, exploiting business logic flaws, or executing unauthorized transactions."}
{"chapter_id": "V3", "chapter_name": "Web Frontend Security", "section_id": "V3.1", "section_name": "Web Frontend Security Documentation", "req_id": "V3.1.1", "req_description": "Verify that application documentation states the expected security features that browsers using the application must support (such as HTTPS, HTTP Strict Transport Security (HSTS), Content Security Policy (CSP), and other relevant HTTP security mechanisms). It must also define how the application must behave when some of these features are not available (such as warning the user or blocking access).", "level": "3", "explanation": "This requirement emphasizes the importance of having comprehensive documentation that outlines the security features expected from the web browsers interacting with the application. It ensures that developers and users are aware of the security measures in place, such as HTTPS for secure communication, HSTS to enforce secure connections, and CSP to mitigate cross-site scripting attacks. Additionally, it mandates that the application should have a defined response when these security features are not supported, which could include showing a warning message or restricting access to the application to prevent potential security risks.", "threats_mitigated": ["Man-in-the-Middle (MitM) attacks", "Data interception", "Cross-Site Scripting (XSS)", "Content injection attacks"], "insecure_examples": [{"code": "Documentation does not mention HTTPS or HSTS support."}, {"code": "The application allows access without checking for CSP support."}], "secure_examples": [{"code": "Documentation clearly states that HTTPS and HSTS must be supported by the browser."}, {"code": "The application includes a warning message when CSP is not supported."}], "verification_steps": ["Check the application documentation for mentions of HTTPS, HSTS, and CSP.", "Verify that the documentation includes instructions on how the application behaves without these features.", "Ensure that there are warnings or access restrictions defined in the documentation."], "common_mistakes": ["Failing to document security requirements clearly.", "Not updating documentation when security features change.", "Assuming users know the required security features without explicit mention."], "related_cwe": ["CWE-693: Protection Mechanism Failure", "CWE-200: Information Exposure"], "related_capec": ["CAPEC-125: Man-in-the-Middle Attack", "CAPEC-134: Cross-Site Scripting (XSS) Attack"], "attack_flow": "An attacker can exploit the lack of documentation regarding security features by tricking users into accessing the application through insecure means. If users are unaware that their browser must support HTTPS or CSP, they may unknowingly expose themselves to attacks such as data interception or XSS, leading to compromised user data or unauthorized access."}
{"chapter_id": "V3", "chapter_name": "Web Frontend Security", "section_id": "V3.2", "section_name": "Unintended Content Interpretation", "req_id": "V3.2.1", "req_description": "Verify that security controls are in place to prevent browsers from rendering content or functionality in HTTP responses in an incorrect context (e.g., when an API, a user-uploaded file or other resource is requested directly). Possible controls could include: not serving the content unless HTTP request header fields (such as Sec-Fetch-*) indicate it is the correct context, using the sandbox directive of the Content-Security-Policy header field or using the attachment disposition type in the Content-Disposition header field.", "level": "1", "explanation": "This requirement ensures that web applications do not inadvertently allow browsers to interpret or execute content in a way that could lead to security vulnerabilities. It emphasizes the importance of validating the context in which content is accessed, particularly for dynamic resources like APIs and user-uploaded files. By implementing proper controls, such as evaluating HTTP request headers and utilizing security headers, developers can mitigate risks associated with content rendering.", "threats_mitigated": ["Cross-Site Scripting (XSS)", "Content Injection", "MIME Sniffing Attacks", "Data Exposure"], "insecure_examples": [{"code": "response.setContentType(\"application/json\");\nresponse.getWriter().write(userData);"}, {"code": "response.setHeader(\"Content-Disposition\", \"inline; filename=report.pdf\");\nresponse.getOutputStream().write(fileData);"}], "secure_examples": [{"code": "if (request.getHeader(\"Sec-Fetch-Mode\").equals(\"cors\")) {\n    response.setContentType(\"application/json\");\n    response.getWriter().write(userData);\n} else {\n    response.sendError(HttpServletResponse.SC_FORBIDDEN);\n}"}, {"code": "response.setHeader(\"Content-Disposition\", \"attachment; filename=report.pdf\");\nresponse.getOutputStream().write(fileData);"}], "verification_steps": ["Check that HTTP request headers are validated before serving content.", "Ensure that the Content-Security-Policy header is implemented with a sandbox directive where applicable.", "Verify that the Content-Disposition header is set appropriately for downloadable files.", "Test for scenarios where content could be accessed directly to ensure proper error handling."], "common_mistakes": ["Not validating the context of HTTP requests before serving content.", "Using insecure content types without proper checks.", "Failing to implement Content-Security-Policy headers.", "Incorrectly setting Content-Disposition headers, allowing unintended inline rendering."], "related_cwe": ["CWE-693", "CWE-20", "CWE-79"], "related_capec": ["CAPEC-137", "CAPEC-104"], "attack_flow": "An attacker may exploit this requirement by crafting a request to access sensitive resources directly, bypassing intended security controls. If the application does not validate the context of the request, the attacker could receive a response that exposes sensitive data or allows for the execution of malicious scripts, leading to XSS or data leakage."}
{"chapter_id": "V3", "chapter_name": "Web Frontend Security", "section_id": "V3.2", "section_name": "Unintended Content Interpretation", "req_id": "V3.2.3", "req_description": "Verify that the application avoids DOM clobbering when using client-side JavaScript by employing explicit variable declarations, performing strict type checking, avoiding storing global variables on the document object, and implementing namespace isolation.", "level": "3", "explanation": "This requirement emphasizes the importance of avoiding DOM clobbering, which occurs when JavaScript variables unintentionally overwrite properties or methods of the DOM. By using explicit variable declarations (e.g., 'let' or 'const'), developers can limit the scope of variables and prevent unintended interactions with the global scope. Strict type checking ensures that the types of variables are validated before use, reducing the risk of errors. Additionally, avoiding global variables on the document object and implementing namespace isolation helps to create a more controlled environment for JavaScript execution, minimizing the risk of conflicts and unintended behavior.", "threats_mitigated": ["Cross-Site Scripting (XSS)", "JavaScript Injection", "Denial of Service (DoS) via script conflicts"], "insecure_examples": ["var myVar = 'value';\ndocument.myVar = 'newValue'; // Clobbers the global variable", "function example() {\n  myVar = 'value'; // Implicit global variable declaration\n}"], "secure_examples": ["let myVar = 'value';\n// Avoids clobbering by using 'let' for block scope", "function example() {\n  let myVar = 'value'; // Explicit declaration prevents global scope pollution\n}"], "verification_steps": ["Check for explicit variable declarations using 'let' or 'const'.", "Review code for instances of global variables on the document object.", "Ensure that strict type checking is implemented where applicable.", "Verify that namespace isolation techniques are employed in the application."], "common_mistakes": ["Using 'var' instead of 'let' or 'const', leading to unintentional global variables.", "Not checking for existing properties on the document object before assignment.", "Failing to implement proper namespace isolation, allowing for variable conflicts."], "related_cwe": ["CWE-Confusing Variable Scope", "CWE-20: Improper Input Validation", "CWE-134: Use of Externally-Controlled Format String"], "related_capec": ["CAPEC-5: DOM-Based Cross-Site Scripting", "CAPEC-137: JavaScript Injection", "CAPEC-154: Exploiting JavaScript Execution Environment"], "attack_flow": "An attacker can exploit DOM clobbering by injecting malicious JavaScript that overwrites critical DOM properties or methods. This can lead to the execution of unauthorized scripts, manipulation of the webpage, or exposure of sensitive data. By failing to adhere to the requirement, developers inadvertently create vulnerabilities that can be exploited in various attack scenarios."}
{"chapter_id": "V3", "chapter_name": "Web Frontend Security", "section_id": "V3.3", "section_name": "Cookie Setup", "req_id": "V3.3.1", "req_description": "Verify that cookies have the 'Secure' attribute set, and if the '\\__Host-' prefix is not used for the cookie name, the '__Secure-' prefix must be used for the cookie name.", "level": "1", "explanation": "This requirement ensures that cookies are transmitted securely over HTTPS by enforcing the 'Secure' attribute. It also mandates the use of specific prefixes for cookie names to prevent potential attacks such as session hijacking. The '__Host-' prefix indicates that the cookie is only accessible over secure connections and cannot be accessed via JavaScript, while the '__Secure-' prefix indicates that the cookie must be sent over secure channels.", "threats_mitigated": ["Session hijacking", "Man-in-the-middle attacks", "Cross-site scripting (XSS)"], "insecure_examples": ["Set-Cookie: sessionId=abc123; HttpOnly", "Set-Cookie: userId=xyz456; Path=/"], "secure_examples": ["Set-Cookie: sessionId=abc123; Secure; HttpOnly; SameSite=Strict", "Set-Cookie: __Secure-userId=xyz456; Secure; Path=/; HttpOnly; SameSite=Strict"], "verification_steps": ["Check if the 'Secure' attribute is present in all Set-Cookie headers.", "Verify that cookies not using the '__Host-' prefix use the '__Secure-' prefix instead.", "Ensure that cookies have the HttpOnly and SameSite attributes set appropriately."], "common_mistakes": ["Forgetting to set the 'Secure' attribute on cookies.", "Using cookie names without the required prefixes.", "Neglecting to set the HttpOnly attribute, allowing JavaScript access."], "related_cwe": ["CWE-1004", "CWE-200", "CWE-201"], "related_capec": ["CAPEC-137", "CAPEC-146", "CAPEC-153"], "attack_flow": "An attacker can intercept cookies that are transmitted over an insecure connection. If the 'Secure' attribute is not set, these cookies can be captured and used to impersonate the user. Additionally, if cookie names do not follow the required prefix conventions, they may be accessible via JavaScript, making them vulnerable to XSS attacks, allowing the attacker to steal session identifiers."}
{"chapter_id": "V3", "chapter_name": "Web Frontend Security", "section_id": "V3.3", "section_name": "Cookie Setup", "req_id": "V3.3.2", "req_description": "Verify that each cookie's 'SameSite' attribute value is set according to the purpose of the cookie, to limit exposure to user interface redress attacks and browser-based request forgery attacks, commonly known as cross-site request forgery (CSRF).", "level": "2", "explanation": "The 'SameSite' attribute of cookies is a security feature that helps prevent CSRF attacks by controlling how cookies are sent with cross-site requests. By setting this attribute to 'Strict' or 'Lax', developers can limit the conditions under which cookies are sent, thereby reducing the risk of unauthorized actions being performed on behalf of authenticated users.", "threats_mitigated": ["Cross-Site Request Forgery (CSRF)", "User Interface Redress Attacks"], "insecure_examples": ["Set-Cookie: sessionId=abc123; Path=/; Domain=example.com", "Set-Cookie: sessionId=abc123; Path=/; SameSite=None"], "secure_examples": ["Set-Cookie: sessionId=abc123; Path=/; SameSite=Lax", "Set-Cookie: sessionId=abc123; Path=/; SameSite=Strict"], "verification_steps": ["Check if the 'SameSite' attribute is present in all cookies.", "Verify that the 'SameSite' attribute is set to 'Lax' or 'Strict' as appropriate.", "Review the application's cookie usage to ensure it aligns with the intended security model."], "common_mistakes": ["Not setting the 'SameSite' attribute at all.", "Setting 'SameSite=None' without using 'Secure' attribute.", "Assuming that default cookie behavior is secure without verification."], "related_cwe": ["CWE-352"], "related_capec": ["CAPEC-154"], "attack_flow": "An attacker crafts a malicious request that targets a user's session on a vulnerable application. If the user's browser sends the request along with their session cookie (due to improper SameSite settings), the application processes the request as if it was legitimate, potentially allowing the attacker to perform unauthorized actions."}
{"chapter_id": "V3", "chapter_name": "Web Frontend Security", "section_id": "V3.3", "section_name": "Cookie Setup", "req_id": "V3.3.3", "req_description": "Verify that cookies have the '__Host-' prefix for the cookie name unless they are explicitly designed to be shared with other hosts.", "level": 2, "explanation": "The '__Host-' prefix indicates that the cookie is only accessible to the originating host and cannot be accessed by subdomains or other hosts. This helps to prevent cookie theft and cross-site scripting attacks by ensuring that cookies are scoped to the intended domain.", "threats_mitigated": ["Cross-Site Scripting (XSS)", "Cross-Site Request Forgery (CSRF)", "Session Hijacking"], "insecure_examples": ["Set-Cookie: sessionId=abc123; Domain=example.com; Path=/", "Set-Cookie: userId=xyz456; Path=/; HttpOnly"], "secure_examples": ["Set-Cookie: __Host-sessionId=abc123; Path=/; Secure; HttpOnly", "Set-Cookie: __Host-userId=xyz456; Path=/; Secure; HttpOnly"], "verification_steps": ["Check cookie names for the '__Host-' prefix.", "Ensure cookies are not set with the Domain attribute unless necessary.", "Verify that cookies are marked as Secure and HttpOnly."], "common_mistakes": ["Using the Domain attribute unnecessarily, allowing cookies to be shared across subdomains.", "Not using the '__Host-' prefix for sensitive cookies.", "Failing to set Secure and HttpOnly flags on cookies."], "related_cwe": ["CWE-1004", "CWE-200", "CWE-287"], "related_capec": ["CAPEC-137", "CAPEC-173"], "attack_flow": "An attacker could exploit the absence of the '__Host-' prefix by crafting a malicious subdomain that can access cookies intended for the main domain, potentially stealing session identifiers or sensitive information, leading to unauthorized access to user accounts."}
{"chapter_id": "V3", "chapter_name": "Web Frontend Security", "section_id": "V3.3", "section_name": "Cookie Setup", "req_id": "V3.3.4", "req_description": "Verify that if the value of a cookie is not meant to be accessible to client-side scripts (such as a session token), the cookie must have the 'HttpOnly' attribute set and the same value (e. g. session token) must only be transferred to the client via the 'Set-Cookie' header field.", "level": 2, "explanation": "The 'HttpOnly' attribute is a security feature that helps mitigate the risk of client-side script accessing sensitive cookie data. By setting this attribute, cookies cannot be accessed via JavaScript, which can help prevent attacks such as Cross-Site Scripting (XSS). Furthermore, ensuring that sensitive values are only sent via the 'Set-Cookie' header reinforces the security of the cookie by preventing unauthorized access through other means.", "threats_mitigated": ["Cross-Site Scripting (XSS)", "Session Hijacking", "Cookie Theft"], "insecure_examples": ["Set-Cookie: sessionToken=abc123; Path=/; Domain=example.com", "Set-Cookie: sessionToken=abc123; Path=/; Domain=example.com; Secure"], "secure_examples": ["Set-Cookie: sessionToken=abc123; Path=/; Domain=example.com; HttpOnly; Secure", "Set-Cookie: sessionToken=abc123; Path=/; HttpOnly; Secure"], "verification_steps": ["Check if the 'HttpOnly' attribute is present for sensitive cookies.", "Verify that sensitive cookie values are only transmitted via the 'Set-Cookie' header.", "Review code for any instances where sensitive cookies are accessed via client-side scripts."], "common_mistakes": ["Forgetting to set the 'HttpOnly' attribute on sensitive cookies.", "Using insecure methods to transfer sensitive cookie data.", "Not validating cookie attributes during code reviews."], "related_cwe": ["CWE-16: Configuration", "CWE-200: Information Exposure", "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"], "related_capec": ["CAPEC-137: Cookie Manipulation", "CAPEC-147: Cross-Site Scripting (XSS)", "CAPEC-185: Session Fixation"], "attack_flow": "An attacker can exploit the absence of the 'HttpOnly' attribute by injecting malicious JavaScript into a web page (via XSS). This script can access cookies that contain sensitive information, such as session tokens, and send them to the attacker's server. With the session token, the attacker can impersonate the victim and gain unauthorized access to their account."}
{"chapter_id": "V3", "chapter_name": "Web Frontend Security", "section_id": "V3.3", "section_name": "Cookie Setup", "req_id": "V3.3.5", "req_description": "Verify that when the application writes a cookie, the cookie name and value length combined are not over 4096 bytes. Overly large cookies will not be stored by the browser and therefore not sent with requests, preventing the user from using application functionality which relies on that cookie.", "level": "3", "explanation": "This requirement ensures that cookies used by the application do not exceed the maximum size limit imposed by browsers. If the combined length of the cookie name and value exceeds 4096 bytes, the browser may truncate the cookie or not store it at all, leading to potential loss of session data or user preferences. This can severely impact the functionality of the application, especially for features that rely on cookies for state management.", "threats_mitigated": ["Session hijacking", "User experience degradation", "Data loss"], "insecure_examples": ["document.cookie = 'sessionId=' + generateSessionId() + '; Path=/; Max-Age=3600;'; // If sessionId is too long", "document.cookie = 'userData=' + JSON.stringify(largeUserDataObject) + '; Path=/;'; // Large user data object"], "secure_examples": ["document.cookie = 'sessionId=' + truncateSessionId(generateSessionId()) + '; Path=/; Max-Age=3600;'; // Ensure sessionId is within limits", "document.cookie = 'userData=' + JSON.stringify(truncateUserData(largeUserDataObject)) + '; Path=/;'; // Ensure user data is within limits"], "verification_steps": ["Check the length of cookie names and values before setting them.", "Implement a size limit check in the cookie writing function.", "Review cookies set by the application in the browser's developer tools."], "common_mistakes": ["Failing to validate the size of cookie data before setting it.", "Assuming that all browsers handle large cookies the same way.", "Not considering the cumulative size of multiple cookies."], "related_cwe": ["CWE-20: Improper Input Validation", "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "CWE-117: Improper Output Encoding or Escaping"], "related_capec": ["CAPEC-118: Cookie Manipulation", "CAPEC-137: Session Fixation"], "attack_flow": "An attacker may exploit overly large cookies by crafting requests that exceed the size limit, causing the browser to ignore the cookie. This could lead to session fixation or loss of important user data, allowing the attacker to hijack the session or disrupt the user's experience."}
{"chapter_id": "V3", "chapter_name": "Web Frontend Security", "section_id": "V3.4", "section_name": "Browser Security Mechanism Headers", "req_id": "V3.4.1", "req_description": "Verify that a Strict-Transport-Security header field is included on all responses to enforce an HTTP Strict Transport Security (HSTS) policy. A maximum age of at least 1 year must be defined, and for L2 and up, the policy must apply to all subdomains as well.", "level": "1", "explanation": "This requirement mandates the inclusion of the Strict-Transport-Security (HSTS) header in HTTP responses to ensure that browsers only communicate with the server over HTTPS. By specifying a maximum age of at least one year, it prevents downgrade attacks and cookie hijacking by enforcing secure connections. For applications at Level 2 and above, the policy must also cover all subdomains, enhancing security across the entire domain.", "threats_mitigated": ["Man-in-the-Middle (MitM) attacks", "SSL stripping attacks", "Session hijacking", "Downgrade attacks"], "insecure_examples": ["HTTP/1.1 200 OK\nContent-Type: text/html\n\n<!DOCTYPE html><html><head></head><body>Hello World</body></html>", "Strict-Transport-Security: max-age=3600"], "secure_examples": ["HTTP/1.1 200 OK\nContent-Type: text/html\nStrict-Transport-Security: max-age=31536000; includeSubDomains\n\n<!DOCTYPE html><html><head></head><body>Hello World</body></html>"], "verification_steps": ["Check HTTP response headers for Strict-Transport-Security.", "Verify that max-age is set to at least 31536000 (1 year).", "Ensure 'includeSubDomains' is present for Level 2 and above.", "Test with various browsers to confirm HSTS is enforced."], "common_mistakes": ["Not including the Strict-Transport-Security header at all.", "Setting a max-age less than 1 year.", "Omitting 'includeSubDomains' for Level 2 and above.", "Incorrectly configuring HSTS on subdomains."], "related_cwe": ["CWE-319", "CWE-300"], "related_capec": ["CAPEC-137", "CAPEC-145"], "attack_flow": "An attacker intercepts HTTP traffic between the user and the server. Without HSTS, the attacker can force the user to connect over HTTP, allowing them to capture sensitive data or perform actions on behalf of the user. By implementing HSTS, the server informs the browser to only communicate over HTTPS, thereby preventing the attacker from downgrading the connection."}
{"chapter_id": "V3", "chapter_name": "Web Frontend Security", "section_id": "V3.4", "section_name": "Browser Security Mechanism Headers", "req_id": "V3.4.2", "req_description": "Verify that the Cross-Origin Resource Sharing (CORS) Access-Control-Allow-Origin header field is a fixed value by the application, or if the Origin HTTP request header field value is used, it is validated against an allowlist of trusted origins. When 'Access-Control-Allow-Origin: *' needs to be used, verify that the response does not include any sensitive information.", "level": 1, "explanation": "This requirement ensures that web applications control which domains can access their resources via CORS. By specifying a fixed value or validating against a trusted allowlist, the application can prevent unauthorized domains from making requests and potentially accessing sensitive data. If a wildcard '*' is used, it is crucial to ensure that sensitive information is not exposed in the response.", "threats_mitigated": ["Cross-Origin Resource Sharing (CORS) Misconfiguration", "Data Leakage", "Cross-Site Scripting (XSS)", "Cross-Site Request Forgery (CSRF)"], "insecure_examples": [{"code": "response.setHeader('Access-Control-Allow-Origin', '*');"}, {"code": "response.setHeader('Access-Control-Allow-Origin', request.getHeader('Origin'));"}], "secure_examples": [{"code": "response.setHeader('Access-Control-Allow-Origin', 'https://trusted-domain.com');"}, {"code": "if (allowedOrigins.contains(request.getHeader('Origin'))) { response.setHeader('Access-Control-Allow-Origin', request.getHeader('Origin')); }"}], "verification_steps": ["Check if the Access-Control-Allow-Origin header is set to a fixed value.", "Verify if the application validates the Origin header against an allowlist.", "Ensure that no sensitive information is exposed when using wildcard '*' for Access-Control-Allow-Origin.", "Review server-side code handling CORS headers."], "common_mistakes": ["Using wildcard '*' without considering data sensitivity.", "Failing to validate the Origin header against a predefined list.", "Assuming all origins are safe without proper checks."], "related_cwe": ["CWE-345", "CWE-20", "CWE-200"], "related_capec": ["CAPEC-137", "CAPEC-154", "CAPEC-159"], "attack_flow": "An attacker could exploit a misconfigured CORS policy by sending requests from a malicious domain that is not adequately validated. If the application responds with sensitive data due to a wildcard setting or improper validation, the attacker could gain unauthorized access to that data, potentially leading to further exploitation or data breaches."}
{"chapter_id": "V3", "chapter_name": "Web Frontend Security", "section_id": "V3.4", "section_name": "Browser Security Mechanism Headers", "req_id": "V3.4.3", "req_description": "Verify that HTTP responses include a Content-Security-Policy response header field which defines directives to ensure the browser only loads and executes trusted content or resources, in order to limit execution of malicious JavaScript. As a minimum, a global policy must be used which includes the directives object-src 'none' and base-uri 'none' and defines either an allowlist or uses nonces or hashes. For an L3 application, a per-response policy with nonces or hashes must be defined.", "level": 2, "explanation": "This requirement mandates the implementation of a Content Security Policy (CSP) to mitigate risks associated with the execution of untrusted scripts. A properly configured CSP can significantly reduce the risk of Cross-Site Scripting (XSS) attacks by restricting the sources from which scripts can be loaded and executed. The use of nonces or hashes allows for more granular control over which scripts are allowed to run, thus enhancing security.", "threats_mitigated": ["Cross-Site Scripting (XSS)", "Data Injection Attacks", "Content Injection Attacks"], "insecure_examples": [{"code": "HTTP/1.1 200 OK\nContent-Type: text/html\n\n<!DOCTYPE html>\n<html>\n<head>\n<title>Insecure Page</title>\n</head>\n<body>\n<script src='http://malicious.com/malicious.js'></script>\n</body>\n</html>"}, {"code": "HTTP/1.1 200 OK\nContent-Type: text/html\n\n<!DOCTYPE html>\n<html>\n<head>\n<title>Insecure Page</title>\n</head>\n<body>\n<script>alert('Hello World');</script>\n</body>\n</html>"}], "secure_examples": [{"code": "HTTP/1.1 200 OK\nContent-Type: text/html\nContent-Security-Policy: default-src 'self'; object-src 'none'; base-uri 'none';"}, {"code": "HTTP/1.1 200 OK\nContent-Type: text/html\nContent-Security-Policy: script-src 'self' 'nonce-xyz123';"}], "verification_steps": ["Check for the presence of the Content-Security-Policy header in HTTP responses.", "Verify that the policy includes object-src 'none' and base-uri 'none'.", "Ensure that the policy uses either an allowlist, nonces, or hashes for scripts.", "For L3 applications, confirm that a per-response policy with nonces or hashes is implemented."], "common_mistakes": ["Not including a Content-Security-Policy header at all.", "Using overly permissive CSP directives that allow execution of scripts from untrusted sources.", "Failing to implement nonces or hashes for inline scripts."], "related_cwe": ["CWE-79", "CWE-20", "CWE-116"], "related_capec": ["CAPEC-137", "CAPEC-148", "CAPEC-160"], "attack_flow": "An attacker can exploit a lack of or improperly configured Content-Security-Policy by injecting malicious scripts into a web page. If the CSP does not restrict script sources, the browser will execute the attacker's scripts, potentially leading to data theft, session hijacking, or further exploitation of the application."}
{"chapter_id": "V3", "chapter_name": "Web Frontend Security", "section_id": "V3.4", "section_name": "Browser Security Mechanism Headers", "req_id": "V3.4.4", "req_description": "Verify that all HTTP responses contain an 'X-Content-Type-Options: nosniff' header field. This instructs browsers not to use content sniffing and MIME type guessing for the given response, and to require the response's Content-Type header field value to match the destination resource. For example, the response to a request for a style is only accepted if the response's Content-Type is 'text/css'. This also enables the use of the Cross-Origin Read Blocking (CORB) functionality by the browser.", "level": 2, "explanation": "The 'X-Content-Type-Options: nosniff' header is a security feature that helps prevent browsers from interpreting files as a different MIME type than what is specified in the Content-Type header. When this header is set to 'nosniff', it instructs the browser to strictly adhere to the declared Content-Type, thereby mitigating the risk of executing malicious scripts or content that could be delivered through incorrect MIME types. This is particularly important for resources like CSS and JavaScript, where improper handling can lead to Cross-Site Scripting (XSS) attacks.", "threats_mitigated": ["Cross-Site Scripting (XSS)", "Content Type Confusion", "MIME Sniffing Attacks"], "insecure_examples": ["HTTP/1.1 200 OK\nContent-Type: text/html\n\n<html><script>alert('XSS');</script></html>", "HTTP/1.1 200 OK\nContent-Type: application/octet-stream\n\n<script>alert('XSS');</script>"], "secure_examples": ["HTTP/1.1 200 OK\nContent-Type: text/css\nX-Content-Type-Options: nosniff\n\nbody { background-color: #fff; }", "HTTP/1.1 200 OK\nContent-Type: application/javascript\nX-Content-Type-Options: nosniff\n\nconsole.log('Secure script');"], "verification_steps": ["Check if the 'X-Content-Type-Options' header is present in HTTP responses.", "Ensure the value of 'X-Content-Type-Options' is set to 'nosniff'.", "Review the Content-Type header for consistency with the resource being served.", "Test the application with various content types to confirm proper handling."], "common_mistakes": ["Forgetting to include the 'X-Content-Type-Options' header in HTTP responses.", "Setting the 'X-Content-Type-Options' header to a value other than 'nosniff'.", "Incorrectly configuring web servers to omit security headers."], "related_cwe": ["CWE- MIME Type Confusion", "CWE-20: Improper Input Validation", "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"], "related_capec": ["CAPEC-123: Content Sniffing Attack", "CAPEC-115: Cross-Site Scripting (XSS)", "CAPEC-133: Content Injection"], "attack_flow": "An attacker can exploit the absence of the 'X-Content-Type-Options: nosniff' header by delivering a malicious script disguised as a legitimate resource. When the browser receives the response, it may incorrectly interpret the content type, leading to the execution of the script. This can result in unauthorized actions, data theft, or session hijacking, compromising the security of the application and its users."}
{"chapter_id": "V3", "chapter_name": "Web Frontend Security", "section_id": "V3.4", "section_name": "Browser Security Mechanism Headers", "req_id": "V3.4.5", "req_description": "Verify that the application sets a referrer policy to prevent leakage of technically sensitive data to third-party services via the 'Referer' HTTP request header field. This can be done using the Referrer-Policy HTTP response header field or via HTML element attributes. Sensitive data could include path and query data in the URL, and for internal non-public applications also the hostname.", "level": "2", "explanation": "This requirement aims to control the information sent in the 'Referer' header when a user navigates from one page to another. By setting a referrer policy, developers can limit the amount of sensitive information that is shared with third-party sites when users click on links. This is important for protecting user privacy and preventing exposure of sensitive data such as URLs that may contain tokens or identifiers.", "threats_mitigated": ["Data leakage", "Information disclosure", "Cross-site tracking"], "insecure_examples": [{"code": "<a href=\"https://thirdparty.com/resource\">Click here</a>"}, {"code": "response.setHeader('Referrer', 'unsafe-url');"}], "secure_examples": [{"code": "<a href=\"https://thirdparty.com/resource\" referrerpolicy=\"no-referrer\">Click here</a>"}, {"code": "response.setHeader('Referrer-Policy', 'no-referrer');"}], "verification_steps": ["Check if the Referrer-Policy header is set in HTTP responses.", "Verify the values of the Referrer-Policy header are appropriate for the application context.", "Review HTML elements for referrerpolicy attributes.", "Test links to ensure sensitive data is not leaked in the Referer header."], "common_mistakes": ["Not setting a referrer policy at all.", "Using overly permissive referrer policies (e.g., 'no-referrer-when-downgrade').", "Failing to review third-party integrations for their referrer policies."], "related_cwe": ["CWE-200", "CWE-205"], "related_capec": ["CAPEC-132", "CAPEC-153"], "attack_flow": "An attacker can exploit a lack of a proper referrer policy by tricking a user into clicking a link that leads to a third-party site. If sensitive data is included in the URL, the third-party site can capture this data from the Referer header, leading to potential data breaches or unauthorized access to sensitive information."}
{"chapter_id": "V3", "chapter_name": "Web Frontend Security", "section_id": "V3.4", "section_name": "Browser Security Mechanism Headers", "req_id": "V3.4.6", "req_description": "Verify that the web application uses the frame-ancestors directive of the Content-Security-Policy header field for every HTTP response to ensure that it cannot be embedded by default and that embedding of specific resources is allowed only when necessary. Note that the X-Frame-Options header field, although supported by browsers, is obsolete and may not be relied upon.", "level": "2", "explanation": "The frame-ancestors directive in the Content-Security-Policy (CSP) header is used to control whether a web page can be embedded in a frame or iframe. By specifying this directive, developers can prevent clickjacking attacks, where malicious sites attempt to trick users into interacting with a page that is hidden behind another page. This requirement emphasizes the importance of using modern security headers to protect web applications from such vulnerabilities.", "threats_mitigated": ["Clickjacking", "Content Injection", "UI Redressing"], "insecure_examples": ["Response Headers: Content-Security-Policy: default-src 'self';", "Response Headers: X-Frame-Options: DENY;"], "secure_examples": ["Response Headers: Content-Security-Policy: frame-ancestors 'self';", "Response Headers: Content-Security-Policy: frame-ancestors https://trusted.com;"], "verification_steps": ["Check the HTTP response headers for Content-Security-Policy.", "Verify that the frame-ancestors directive is present.", "Ensure that the directive does not allow untrusted origins.", "Confirm that X-Frame-Options is not used as a primary defense."], "common_mistakes": ["Relying solely on X-Frame-Options instead of using frame-ancestors.", "Not specifying any frame-ancestors, allowing all origins by default.", "Misconfiguring the frame-ancestors directive to include untrusted domains."], "related_cwe": ["CWE-1021", "CWE-200", "CWE-16"], "related_capec": ["CAPEC-137", "CAPEC-152"], "attack_flow": "An attacker can exploit a vulnerability in a web application by creating a malicious site that embeds the target application in an iframe. If the target application does not implement the frame-ancestors directive correctly, the attacker can manipulate the user interface, tricking users into performing actions they did not intend, such as clicking buttons or entering sensitive information."}
{"chapter_id": "V3", "chapter_name": "Web Frontend Security", "section_id": "V3.4", "section_name": "Browser Security Mechanism Headers", "req_id": "V3.4.7", "req_description": "Verify that the Content-Security-Policy header field specifies a location to report violations.", "level": "3", "explanation": "The Content-Security-Policy (CSP) header is a security feature that helps prevent a variety of attacks, such as Cross-Site Scripting (XSS) and data injection attacks. By specifying a report-uri or report-to directive in the CSP, developers can receive notifications about policy violations, which can help them identify and fix security issues in their applications.", "threats_mitigated": ["Cross-Site Scripting (XSS)", "Data Injection Attacks", "Clickjacking", "Malicious Content Injection"], "insecure_examples": [{"code": "Content-Security-Policy: default-src 'self';"}, {"code": "Content-Security-Policy: script-src 'self';"}], "secure_examples": [{"code": "Content-Security-Policy: default-src 'self'; report-uri /csp-violation-report-endpoint;"}, {"code": "Content-Security-Policy: script-src 'self'; report-to csp-endpoint;"}], "verification_steps": ["Check if the Content-Security-Policy header is present in HTTP responses.", "Verify that the header includes a report-uri or report-to directive.", "Ensure that the specified URI is a valid endpoint capable of receiving reports.", "Test the reporting mechanism by triggering a CSP violation and confirming receipt of the report."], "common_mistakes": ["Omitting the report-uri or report-to directive from the CSP header.", "Using an invalid or non-existent endpoint for reporting violations.", "Failing to test the reporting functionality after implementation."], "related_cwe": ["CWE-79", "CWE-20", "CWE-116"], "related_capec": ["CAPEC-137", "CAPEC-149", "CAPEC-155"], "attack_flow": "An attacker may exploit a vulnerability in the application that allows them to inject malicious scripts. If the CSP is not configured to report violations, the developer may remain unaware of the attack, allowing it to persist. By implementing the report-uri or report-to directive, the developer can receive alerts about such violations, enabling them to investigate and mitigate the security issues promptly."}
{"chapter_id": "V3", "chapter_name": "Web Frontend Security", "section_id": "V3.4", "section_name": "Browser Security Mechanism Headers", "req_id": "V3.4.8", "req_description": "Verify that all HTTP responses that initiate a document rendering (such as responses with Content-Type text/html), include the Crossâ€‘Originâ€‘Openerâ€‘Policy header field with the same-origin directive or the same-origin-allow-popups directive as required. This prevents attacks that abuse shared access to Window objects, such as tabnabbing and frame counting.", "level": "3", "explanation": "The Cross-Origin-Opener-Policy (COOP) header is crucial for ensuring that a document does not share a browsing context with cross-origin documents. By setting this header to 'same-origin' or 'same-origin-allow-popups', you can control how your document interacts with other documents, thereby mitigating risks associated with shared resources. This is particularly important in preventing attacks that exploit the Window object, such as tabnabbing, where an attacker can manipulate the user's browser context.", "threats_mitigated": ["Tabnabbing", "Frame counting", "Cross-origin data leaks", "Cross-origin attacks"], "insecure_examples": ["HTTP/1.1 200 OK\nContent-Type: text/html\n\n<html>...</html>", "HTTP/1.1 200 OK\nContent-Type: text/html\nX-Frame-Options: DENY\n\n<html>...</html>"], "secure_examples": ["HTTP/1.1 200 OK\nContent-Type: text/html\nCross-Origin-Opener-Policy: same-origin\n\n<html>...</html>", "HTTP/1.1 200 OK\nContent-Type: text/html\nCross-Origin-Opener-Policy: same-origin-allow-popups\n\n<html>...</html>"], "verification_steps": ["Check if the server responds with the Cross-Origin-Opener-Policy header.", "Verify that the header value is either 'same-origin' or 'same-origin-allow-popups'.", "Ensure that all relevant HTTP responses include this header."], "common_mistakes": ["Forgetting to include the COOP header in HTTP responses.", "Using an incorrect value for the COOP header.", "Assuming that other security headers (like X-Frame-Options) are sufficient without COOP."], "related_cwe": ["CWE-200", "CWE-285", "CWE-16"], "related_capec": ["CAPEC-134", "CAPEC-145"], "attack_flow": "An attacker can exploit a lack of COOP by tricking a user into clicking on a malicious link that opens a new tab or window. If the original page does not have COOP set, the attacker can access the Window object of the original page, potentially leading to data theft or manipulation. By setting COOP correctly, the attacker is prevented from accessing the original page's context, thereby mitigating the risk."}
{"chapter_id": "V3", "chapter_name": "Web Frontend Security", "section_id": "V3.5", "section_name": "Browser Origin Separation", "req_id": "V3.5.1", "req_description": "Verify that, if the application does not rely on the CORS preflight mechanism to prevent disallowed cross-origin requests to use sensitive functionality, these requests are validated to ensure they originate from the application itself. This may be done by using and validating anti-forgery tokens or requiring extra HTTP header fields that are not CORS-safelisted request-header fields. This is to defend against browser-based request forgery attacks, commonly known as cross-site request forgery (CSRF).", "level": 1, "explanation": "This requirement emphasizes the need for applications to implement additional validation mechanisms to ensure that cross-origin requests are legitimate and originate from trusted sources. By not solely relying on CORS preflight checks, developers can enhance security against unauthorized actions that could be triggered by malicious websites or scripts. The use of anti-forgery tokens and non-CORS-safelisted headers helps to ensure that requests are intentional and not the result of CSRF attacks.", "threats_mitigated": ["Cross-Site Request Forgery (CSRF)", "Cross-Origin Resource Sharing (CORS) misconfigurations", "Unauthorized access to sensitive functionality"], "insecure_examples": [{"code": "fetch('https://example.com/api/secure-endpoint', { method: 'POST', body: JSON.stringify(data) });"}, {"code": "$.ajax({ url: 'https://example.com/api/secure-endpoint', type: 'POST', data: { key: 'value' } });"}], "secure_examples": [{"code": "fetch('https://example.com/api/secure-endpoint', { method: 'POST', headers: { 'X-CSRF-Token': csrfToken }, body: JSON.stringify(data) });"}, {"code": "$.ajax({ url: 'https://example.com/api/secure-endpoint', type: 'POST', headers: { 'X-CSRF-Token': csrfToken }, data: { key: 'value' } });"}], "verification_steps": ["Check for the presence of anti-forgery tokens in state-changing requests.", "Verify that the application validates the origin of requests against allowed origins.", "Ensure that non-CORS-safelisted headers are used for sensitive operations.", "Review server-side logic to confirm that requests are properly authenticated and authorized."], "common_mistakes": ["Relying solely on CORS configuration without additional validation.", "Not implementing anti-forgery tokens for state-changing requests.", "Using CORS-safelisted headers for sensitive operations without additional checks."], "related_cwe": ["CWE-352", "CWE-346", "CWE-20"], "related_capec": ["CAPEC-137", "CAPEC-146"], "attack_flow": "An attacker can exploit this requirement by tricking a user into visiting a malicious site that sends unauthorized requests to the target application. If the application does not validate the origin of these requests or lacks proper anti-forgery measures, the attacker can perform actions on behalf of the user without their consent, leading to unauthorized access or data manipulation."}
{"chapter_id": "V3", "chapter_name": "Web Frontend Security", "section_id": "V3.5", "section_name": "Browser Origin Separation", "req_id": "V3.5.2", "req_description": "Verify that, if the application relies on the CORS preflight mechanism to prevent disallowed cross-origin use of sensitive functionality, it is not possible to call the functionality with a request which does not trigger a CORS-preflight request. This may require checking the values of the 'Origin' and 'Content-Type' request header fields or using an extra header field that is not a CORS-safelisted header-field.", "level": 1, "explanation": "This requirement ensures that applications properly implement Cross-Origin Resource Sharing (CORS) to restrict access to sensitive endpoints. By enforcing CORS preflight checks, applications can prevent unauthorized domains from making potentially harmful requests. It is crucial to validate the 'Origin' and 'Content-Type' headers to ensure that only requests from trusted domains are allowed to interact with sensitive functionalities.", "threats_mitigated": ["Cross-Origin Resource Sharing (CORS) Misconfiguration", "Cross-Site Request Forgery (CSRF)", "Data Exfiltration via Cross-Origin Requests"], "insecure_examples": [{"code": "fetch('https://example.com/api/sensitive', { method: 'POST', headers: { 'Content-Type': 'application/json' } });"}, {"code": "$.ajax({ url: 'https://example.com/api/sensitive', type: 'POST', data: JSON.stringify(data), contentType: 'application/json' });"}], "secure_examples": [{"code": "fetch('https://example.com/api/sensitive', { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-Custom-Header': 'value' } });"}, {"code": "$.ajax({ url: 'https://example.com/api/sensitive', type: 'POST', data: JSON.stringify(data), contentType: 'application/json', headers: { 'X-Custom-Header': 'value' } });"}], "verification_steps": ["Check that CORS is enabled for the application.", "Verify that the application correctly handles CORS preflight requests.", "Ensure that the application checks the 'Origin' header for allowed domains.", "Confirm that non-CORS-safelisted headers are used to trigger preflight requests.", "Test the application with various origins to ensure that disallowed origins are blocked."], "common_mistakes": ["Assuming that all requests will automatically trigger a CORS preflight check.", "Not validating the 'Origin' header properly.", "Using only CORS-safelisted headers without additional validation.", "Failing to implement error handling for disallowed cross-origin requests."], "related_cwe": ["CWE-346", "CWE-20", "CWE-200"], "related_capec": ["CAPEC-118", "CAPEC-137"], "attack_flow": "An attacker can exploit this requirement by crafting a request from a disallowed origin that does not trigger a CORS preflight check. If the application fails to validate the 'Origin' header or does not implement additional checks, the attacker could access sensitive functionality, potentially leading to data theft or manipulation."}
{"chapter_id": "V3", "chapter_name": "Web Frontend Security", "section_id": "V3.5", "section_name": "Browser Origin Separation", "req_id": "V3.5.3", "req_description": "Verify that HTTP requests to sensitive functionality use appropriate HTTP methods such as POST, PUT, PATCH, or DELETE, and not methods defined by the HTTP specification as 'safe' such as HEAD, OPTIONS, or GET. Alternatively, strict validation of the Sec-Fetch-* request header fields can be used to ensure that the request did not originate from an inappropriate cross-origin call, a navigation request, or a resource load (such as an image source) where this is not expected.", "level": "1", "explanation": "This requirement aims to ensure that sensitive operations are not inadvertently triggered by safe HTTP methods that could be exploited by attackers. By enforcing the use of non-safe methods for sensitive actions, applications can reduce the risk of unauthorized access or actions being performed through unintended means. Additionally, validating the Sec-Fetch-* headers helps to ensure that requests are coming from legitimate sources, adding an extra layer of security.", "threats_mitigated": ["Cross-Site Request Forgery (CSRF)", "Cross-Origin Resource Sharing (CORS) vulnerabilities", "Unauthorized data modification", "Data leakage through unintended HTTP methods"], "insecure_examples": [{"code": "GET /api/user/delete?id=12345 HTTP/1.1\nHost: example.com"}, {"code": "OPTIONS /api/user/update HTTP/1.1\nHost: example.com"}], "secure_examples": [{"code": "DELETE /api/user/delete HTTP/1.1\nHost: example.com\nContent-Type: application/json\n{\"id\": 12345}"}, {"code": "PATCH /api/user/update HTTP/1.1\nHost: example.com\nContent-Type: application/json\n{\"name\": \"newName\"}"}], "verification_steps": ["Check that sensitive API endpoints only accept POST, PUT, PATCH, or DELETE methods.", "Review the server configuration to ensure that safe methods like GET and HEAD are not allowed for sensitive actions.", "Inspect the Sec-Fetch-* headers in requests to verify they are correctly validated.", "Test the application to ensure that unauthorized methods result in appropriate error responses."], "common_mistakes": ["Using GET requests for actions that modify data.", "Failing to validate Sec-Fetch-* headers.", "Allowing OPTIONS method on sensitive endpoints without proper checks.", "Not implementing CSRF protections alongside method restrictions."], "related_cwe": ["CWE-352", "CWE-693", "CWE-20"], "related_capec": ["CAPEC-138", "CAPEC-154", "CAPEC-157"], "attack_flow": "An attacker can exploit this requirement by crafting a malicious request using a safe HTTP method (like GET) to trigger sensitive operations on the server. If the server does not properly validate the HTTP method or the Sec-Fetch-* headers, the attacker could perform actions such as deleting user accounts or modifying sensitive data without proper authorization."}
{"chapter_id": "V3", "chapter_name": "Web Frontend Security", "section_id": "V3.5", "section_name": "Browser Origin Separation", "req_id": "V3.5.4", "req_description": "Verify that separate applications are hosted on different hostnames to leverage the restrictions provided by same-origin policy, including how documents or scripts loaded by one origin can interact with resources from another origin and hostname-based restrictions on cookies.", "level": "2", "explanation": "This requirement emphasizes the importance of hosting separate web applications on distinct hostnames. By doing so, it ensures that the same-origin policy is effectively applied, which restricts how documents or scripts from one origin can interact with resources from another origin. This separation helps to prevent unauthorized access and data leakage between applications, as well as ensuring that cookies are scoped correctly to the intended application, preventing cross-site request forgery (CSRF) and other attacks.", "threats_mitigated": ["Cross-Origin Resource Sharing (CORS) vulnerabilities", "Cross-Site Scripting (XSS)", "Cross-Site Request Forgery (CSRF)", "Data leakage between applications"], "insecure_examples": [{"code": "http://app1.example.com and http://app2.example.com share cookies and resources."}, {"code": "http://example.com/app1 and http://example.com/app2 allow scripts from one to access the other's DOM."}], "secure_examples": [{"code": "http://app1.example.com and http://app2.example.com host separate applications with distinct cookies."}, {"code": "http://app1.example.com and http://app2.example.com restrict access to their respective resources."}], "verification_steps": ["Check that each application is hosted on a unique hostname.", "Verify that cookies are scoped to the appropriate hostname.", "Review CORS policies to ensure they are restrictive and do not allow unwanted access.", "Test for XSS vulnerabilities between applications hosted on the same domain."], "common_mistakes": ["Hosting multiple applications on the same hostname without proper separation.", "Failing to configure cookies with the correct domain attribute.", "Overly permissive CORS settings that allow access from unintended origins."], "related_cwe": ["CWE-346: Origin Validation Error", "CWE-16: Configuration", "CWE-20: Improper Input Validation"], "related_capec": ["CAPEC-137: Cross-Site Scripting (XSS)", "CAPEC-135: Cross-Site Request Forgery (CSRF)"], "attack_flow": "An attacker could exploit a vulnerability in one application hosted on a shared hostname to access sensitive data or perform actions in another application. By leveraging the same-origin policy, they may bypass security controls, allowing them to read cookies or make unauthorized requests to the other application."}
{"chapter_id": "V3", "chapter_name": "Web Frontend Security", "section_id": "V3.5", "section_name": "Browser Origin Separation", "req_id": "V3.5.5", "req_description": "Verify that messages received by the postMessage interface are discarded if the origin of the message is not trusted, or if the syntax of the message is invalid.", "level": "2", "explanation": "This requirement emphasizes the importance of validating the origin of messages sent through the postMessage API in web applications. It ensures that only messages from trusted sources are processed, preventing potential cross-origin attacks. Additionally, it requires that the structure of the message is checked to avoid processing malformed or malicious data.", "threats_mitigated": ["Cross-Site Scripting (XSS)", "Cross-Origin Resource Sharing (CORS) Misconfigurations", "Data Injection Attacks", "Man-in-the-Middle (MitM) Attacks"], "insecure_examples": [{"code": "window.addEventListener('message', function(event) { /* process message */ });"}, {"code": "if (event.origin === 'http://untrusted.com') { /* process message */ }"}], "secure_examples": [{"code": "window.addEventListener('message', function(event) { if (isValidOrigin(event.origin)) { /* process message */ } });"}, {"code": "function isValidOrigin(origin) { return ['https://trusted.com'].includes(origin); }"}], "verification_steps": ["Check that the postMessage listener validates the origin of incoming messages.", "Ensure that the message syntax is validated against expected formats.", "Review the implementation for proper error handling when an invalid message is detected.", "Test the application with both valid and invalid messages to confirm the expected behavior."], "common_mistakes": ["Not validating the origin of the message before processing it.", "Assuming that all messages from the same domain are safe.", "Failing to validate the structure or content of the received message.", "Ignoring potential race conditions in message handling."], "related_cwe": ["CWE-346", "CWE-20", "CWE-117"], "related_capec": ["CAPEC-134", "CAPEC-141", "CAPEC-155"], "attack_flow": "An attacker could exploit this requirement by sending a crafted message from an untrusted origin that the application processes without validation. This could lead to unauthorized actions being performed, sensitive data being exposed, or the application being manipulated in unintended ways."}
{"chapter_id": "V3", "chapter_name": "Web Frontend Security", "section_id": "V3.5", "section_name": "Browser Origin Separation", "req_id": "V3.5.6", "req_description": "Verify that JSONP functionality is not enabled anywhere across the application to avoid Cross-Site Script Inclusion (XSSI) attacks.", "level": "3", "explanation": "JSONP (JSON with Padding) is a technique used to overcome the same-origin policy in web browsers by allowing scripts to be loaded from different origins. However, if not properly controlled, it can lead to XSSI attacks, where an attacker can inject malicious scripts that can access sensitive data. This requirement mandates the complete disallowance of JSONP to eliminate this risk.", "threats_mitigated": ["Cross-Site Script Inclusion (XSSI)", "Data theft", "Cross-Site Scripting (XSS)"], "insecure_examples": [{"code": "function getJSONP(url) {\n    var script = document.createElement('script');\n    script.src = url;\n    document.body.appendChild(script);\n}"}, {"code": "http://example.com/api?callback=handleResponse"}], "secure_examples": [{"code": "function getJSON(url) {\n    fetch(url)\n        .then(response => response.json())\n        .then(data => console.log(data));\n}"}, {"code": "http://example.com/api"}], "verification_steps": ["Review the application code for any instances of JSONP usage.", "Check the application configuration for any enabled JSONP endpoints.", "Perform a security scan to identify any JSONP exposure.", "Ensure that all API endpoints are designed to only respond to standard JSON requests."], "common_mistakes": ["Using JSONP for cross-origin requests without proper validation.", "Failing to remove legacy JSONP functionality from older code.", "Assuming that JSONP is safe if only trusted domains are used."], "related_cwe": ["CWE-80", "CWE-117", "CWE-200"], "related_capec": ["CAPEC-139", "CAPEC-140"], "attack_flow": "An attacker crafts a malicious URL that returns a JSONP response with a callback function that executes arbitrary JavaScript in the victim's browser. If the application accepts this request and executes the callback, the attacker's script can access sensitive information or perform actions on behalf of the user."}
{"chapter_id": "V3", "chapter_name": "Web Frontend Security", "section_id": "V3.5", "section_name": "Browser Origin Separation", "req_id": "V3.5.7", "req_description": "Verify that data requiring authorization is not included in script resource responses, like JavaScript files, to prevent Cross-Site Script Inclusion (XSSI) attacks.", "level": "3", "explanation": "This requirement emphasizes the importance of ensuring that sensitive data is not exposed through script resources that are accessible to the client. When scripts are served to the browser, they should not contain any information that requires user authorization, as this can lead to unauthorized access and exploitation through XSSI attacks. This is especially critical in single-page applications where JavaScript files may be reused across different contexts.", "threats_mitigated": ["Cross-Site Script Inclusion (XSSI)", "Data leakage", "Unauthorized access to sensitive information"], "insecure_examples": [{"code_snippet": "var userData = fetch('/api/userdata'); // sensitive data included in script response"}, {"code_snippet": "response.setHeader('Content-Type', 'application/javascript');\nresponse.write('var userInfo = ' + JSON.stringify(userData)); // exposing user data"}], "secure_examples": [{"code_snippet": "var userData = fetch('/api/userdata', { headers: { 'Authorization': 'Bearer token' }}); // sensitive data fetched securely"}, {"code_snippet": "response.setHeader('Content-Type', 'application/javascript');\nresponse.write('var userInfo = {}; // no sensitive data exposed"}], "verification_steps": ["Review script resource responses to ensure they do not contain sensitive data.", "Check that any data requiring authorization is fetched securely and not included directly in script responses.", "Ensure that sensitive API endpoints are protected with proper authentication mechanisms."], "common_mistakes": ["Including sensitive data in JavaScript files that are publicly accessible.", "Assuming that client-side code is secure without proper validation.", "Not validating the origin of requests for sensitive data."], "related_cwe": ["CWE-200", "CWE-201", "CWE-79"], "related_capec": ["CAPEC-139", "CAPEC-160"], "attack_flow": "An attacker could exploit a vulnerability by including a malicious script that accesses sensitive data exposed in a JavaScript file. By manipulating the browser to execute this script, the attacker could gain unauthorized access to user information or perform actions on behalf of the user, leading to potential data breaches or account takeovers."}
{"chapter_id": "V3", "chapter_name": "Web Frontend Security", "section_id": "V3.5", "section_name": "Browser Origin Separation", "req_id": "V3.5.8", "req_description": "Verify that authenticated resources (such as images, videos, scripts, and other documents) can be loaded or embedded on behalf of the user only when intended. This can be accomplished by strict validation of the Sec-Fetch-* HTTP request header fields to ensure that the request did not originate from an inappropriate cross-origin call, or by setting a restrictive Cross-Origin-Resource-Policy HTTP response header field to instruct the browser to block returned content.", "level": "3", "explanation": "This requirement ensures that sensitive resources are only accessible in contexts where they are intended to be used. By validating the Sec-Fetch-* headers, applications can determine the origin of the request and prevent unauthorized access from malicious sites. Setting the Cross-Origin-Resource-Policy header further restricts how resources can be shared across origins, enhancing security against cross-origin attacks.", "threats_mitigated": ["Cross-Origin Resource Sharing (CORS) attacks", "Cross-Site Scripting (XSS)", "Data theft through unauthorized resource access", "Cross-Site Request Forgery (CSRF)"], "insecure_examples": [{"code": "const img = new Image(); img.src = 'https://example.com/user/image.png';", "description": "This code does not validate the origin of the request and could allow unauthorized access to user images."}, {"code": "fetch('https://example.com/user/video.mp4');", "description": "This fetch request does not check the Sec-Fetch-* headers, potentially exposing sensitive video content."}], "secure_examples": [{"code": "const img = new Image(); img.src = 'https://example.com/user/image.png'; if (validateOrigin(request)) { loadImage(img); }", "description": "This code includes a function to validate the origin before loading the image."}, {"code": "fetch('https://example.com/user/video.mp4', { headers: { 'Sec-Fetch-Mode': 'cors' } });", "description": "This fetch request includes a header to ensure it is a valid cross-origin request."}], "verification_steps": ["Check if Sec-Fetch-* headers are being validated for all sensitive resource requests.", "Ensure that the Cross-Origin-Resource-Policy header is set to restrict access appropriately.", "Review code to confirm that resources are only loaded in intended contexts.", "Test the application for potential cross-origin access vulnerabilities."], "common_mistakes": ["Failing to validate Sec-Fetch-* headers for sensitive resource requests.", "Not setting the Cross-Origin-Resource-Policy header.", "Assuming that all origins are safe without proper checks.", "Using overly permissive CORS settings."], "related_cwe": ["CWE-346", "CWE-693", "CWE-201"], "related_capec": ["CAPEC-118", "CAPEC-139", "CAPEC-138"], "attack_flow": "An attacker can exploit this requirement by crafting a malicious site that attempts to load resources from a target application. If the application does not validate the Sec-Fetch-* headers or does not implement a restrictive Cross-Origin-Resource-Policy, the attacker may gain unauthorized access to sensitive user resources, leading to data exposure or manipulation."}
{"chapter_id": "V3", "chapter_name": "Web Frontend Security", "section_id": "V3.6", "section_name": "External Resource Integrity", "req_id": "V3.6.1", "req_description": "Verify that client-side assets, such as JavaScript libraries, CSS, or web fonts, are only hosted externally (e.g., on a Content Delivery Network) if the resource is static and versioned and Subresource Integrity (SRI) is used to validate the integrity of the asset. If this is not possible, there should be a documented security decision to justify this for each resource.", "level": "3", "explanation": "This requirement ensures that any external resources used in a web application are secure and trustworthy. By enforcing the use of static and versioned resources along with Subresource Integrity (SRI), it mitigates the risk of an attacker injecting malicious code into these resources. SRI allows the browser to verify that the fetched resource has been delivered without unexpected manipulation. If a resource cannot meet these criteria, a documented security decision must be made to assess the risks involved.", "threats_mitigated": ["Cross-Site Scripting (XSS)", "Man-in-the-Middle (MitM) attacks", "Resource tampering"], "insecure_examples": ["<script src='https://example.com/library.js'></script>", "<link rel='stylesheet' href='https://example.com/styles.css'>"], "secure_examples": ["<script src='https://example.com/library.js' integrity='sha384-...' crossorigin='anonymous'></script>", "<link rel='stylesheet' href='https://example.com/styles.css' integrity='sha384-...' crossorigin='anonymous'>"], "verification_steps": ["Check if all external resources are static and versioned.", "Verify that Subresource Integrity (SRI) attributes are present for each external resource.", "Review documentation for any exceptions to the requirement.", "Ensure that integrity hashes are up-to-date and correctly calculated."], "common_mistakes": ["Using non-versioned resources from external sources.", "Failing to include SRI attributes for external resources.", "Not documenting security decisions for exceptions."], "related_cwe": ["CWE-346: Origin Validation Error", "CWE-20: Improper Input Validation", "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"], "related_capec": ["CAPEC-137: Cross-Site Scripting (XSS) via External Resource Inclusion", "CAPEC-114: Content Injection via Manipulated Content Delivery Network (CDN)"], "attack_flow": "An attacker can exploit a vulnerability by replacing a legitimate external resource with a malicious one. If the resource is not versioned or lacks SRI, the browser will load the compromised resource, allowing the attacker to execute arbitrary scripts or styles in the context of the user's session, leading to potential data theft or account compromise."}
{"chapter_id": "V3", "chapter_name": "Web Frontend Security", "section_id": "V3.7", "section_name": "Other Browser Security Considerations", "req_id": "V3.7.1", "req_description": "Verify that the application only uses client-side technologies which are still supported and considered secure. Examples of technologies which do not meet this requirement include NSAPI plugins, Flash, Shockwave, ActiveX, Silverlight, NACL, or client-side Java applets.", "level": "2", "explanation": "This requirement emphasizes the importance of using only those client-side technologies that are actively maintained and recognized as secure by the community. Using outdated or deprecated technologies can expose applications to various vulnerabilities, as these technologies may not receive security updates or patches, leaving them susceptible to exploitation.", "threats_mitigated": ["Cross-Site Scripting (XSS)", "Remote Code Execution", "Denial of Service (DoS)", "Data Leakage", "Malware Injections"], "insecure_examples": [{"code": "<object data='myapp.jar' type='application/java-archive'></object>", "description": "Using Java applets which are no longer supported."}, {"code": "<embed src='flashfile.swf' type='application/x-shockwave-flash'></embed>", "description": "Using Flash content which is deprecated and insecure."}], "secure_examples": [{"code": "<script src='https://secure-library.js'></script>", "description": "Using a secure and supported JavaScript library."}, {"code": "<iframe src='https://secure-content.com' sandbox='allow-scripts'></iframe>", "description": "Using a secure iframe with proper sandboxing."}], "verification_steps": ["Review the list of client-side technologies used in the application.", "Check the support status of each technology with official documentation.", "Ensure that no deprecated technologies are in use.", "Verify that all libraries and frameworks are up-to-date.", "Conduct a risk assessment for any legacy technology still in use."], "common_mistakes": ["Continuing to use deprecated technologies due to legacy code.", "Failing to update third-party libraries and plugins.", "Not verifying the security status of client-side frameworks.", "Assuming that all client-side technologies are secure without research."], "related_cwe": ["CWE-20: Improper Input Validation", "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "CWE-94: Code Injection"], "related_capec": ["CAPEC-137: Flash Application Attack", "CAPEC-136: Java Applet Attack", "CAPEC-118: Browser Exploit via Plugins"], "attack_flow": "An attacker can exploit outdated client-side technologies by crafting malicious payloads that take advantage of known vulnerabilities in those technologies. For example, if an application uses Flash, an attacker can create a malicious Flash file that executes arbitrary code when loaded by the user's browser. This can lead to unauthorized access, data theft, or complete control over the user's session."}
{"chapter_id": "V3", "chapter_name": "Web Frontend Security", "section_id": "V3.7", "section_name": "Other Browser Security Considerations", "req_id": "V3.7.2", "req_description": "Verify that the application will only automatically redirect the user to a different hostname or domain (which is not controlled by the application) where the destination appears on an allowlist.", "level": "2", "explanation": "This requirement ensures that the application does not redirect users to potentially malicious or untrusted sites. By maintaining an allowlist of approved domains, the application can prevent open redirect vulnerabilities, which can be exploited by attackers to redirect users to phishing sites or to conduct other malicious activities.", "threats_mitigated": ["Open Redirects", "Phishing Attacks", "Malware Distribution"], "insecure_examples": ["window.location.href = userInputUrl;", "response.redirect(userInputUrl);"], "secure_examples": ["if (allowedDomains.includes(userInputUrl.hostname)) { window.location.href = userInputUrl; }", "if (allowedRedirects.includes(userInputUrl)) { response.redirect(userInputUrl); }"], "verification_steps": ["Check if the application uses an allowlist for redirects.", "Review the implementation of the redirect logic to ensure it validates against the allowlist.", "Test the application with URLs not in the allowlist to confirm they are blocked.", "Verify that the allowlist is regularly reviewed and updated."], "common_mistakes": ["Failing to validate user input before using it in redirects.", "Using a dynamic list of domains without proper sanitization.", "Not implementing a fallback mechanism for untrusted redirects."], "related_cwe": ["CWE-601", "CWE-601", "CWE-20"], "related_capec": ["CAPEC-137", "CAPEC-156"], "attack_flow": "An attacker crafts a URL that includes a redirect to a malicious site. If the application does not validate the redirect destination against an allowlist, the user is redirected to the malicious site, where they may be tricked into providing sensitive information or downloading malware."}
{"chapter_id": "V3", "chapter_name": "Web Frontend Security", "section_id": "V3.7", "section_name": "Other Browser Security Considerations", "req_id": "V3.7.3", "req_description": "Verify that the application shows a notification when the user is being redirected to a URL outside of the application's control, with an option to cancel the navigation.", "level": "3", "explanation": "This requirement ensures that users are made aware when they are being redirected to an external site, which may not be secure or could potentially lead to phishing attacks. By providing a notification and an option to cancel the navigation, users can make informed decisions about whether to proceed or not.", "threats_mitigated": ["Phishing attacks", "Malware distribution", "User data exposure", "Unintentional navigation to malicious sites"], "insecure_examples": ["window.location.href = 'http://malicious-site.com';", "window.location.replace('http://malicious-site.com');"], "secure_examples": ["if (confirm('You are being redirected to an external site. Do you want to continue?')) { window.location.href = 'http://malicious-site.com'; }", "showNotification('You are being redirected to an external site. Click OK to proceed or Cancel to stay on this page.');"], "verification_steps": ["Check for user notifications during redirection to external URLs.", "Ensure the notification provides a clear message about the external site.", "Verify that users have the option to cancel the navigation.", "Test the functionality across different browsers."], "common_mistakes": ["Failing to notify users about external redirections.", "Not providing a cancel option for the navigation.", "Using vague or unclear messaging in notifications.", "Redirecting without any user interaction or confirmation."], "related_cwe": ["CWE-601: URL Redirection to Untrusted Site ('Open Redirect')", "CWE-20: Improper Input Validation"], "related_capec": ["CAPEC-137: Redirecting User to Malicious Site", "CAPEC-165: Phishing via URL Redirection"], "attack_flow": "An attacker may embed a link in a legitimate-looking email or webpage that redirects users to a malicious site. If the application does not notify users of the redirection, they may unknowingly provide sensitive information or download malware. By implementing this requirement, users are alerted and can choose not to proceed, thereby reducing the risk of falling victim to such attacks."}
{"chapter_id": "V3", "chapter_name": "Web Frontend Security", "section_id": "V3.7", "section_name": "Other Browser Security Considerations", "req_id": "V3.7.4", "req_description": "Verify that the application's top-level domain (e.g., site.tld) is added to the public preload list for HTTP Strict Transport Security (HSTS). This ensures that the use of TLS for the application is built directly into the main browsers, rather than relying only on the Strict-Transport-Security response header field.", "level": 3, "explanation": "This requirement mandates that the application's domain is included in the HSTS preload list, which is a list maintained by browser vendors. When a domain is on this list, browsers automatically enforce HTTPS connections without needing to wait for the server's response. This enhances security by preventing man-in-the-middle attacks and ensuring that users always connect securely.", "threats_mitigated": ["Man-in-the-Middle (MitM) attacks", "SSL stripping attacks", "Downgrade attacks"], "insecure_examples": [{"code_snippet": "HTTP/1.1 200 OK\nStrict-Transport-Security: max-age=31536000; includeSubDomains"}, {"code_snippet": "HTTP/1.1 200 OK\nStrict-Transport-Security: max-age=0"}], "secure_examples": [{"code_snippet": "HTTP/1.1 200 OK\nStrict-Transport-Security: max-age=31536000; includeSubDomains; preload"}], "verification_steps": ["Check if the domain is listed on the HSTS preload list at https://hstspreload.org.", "Verify that the Strict-Transport-Security header includes the 'preload' directive.", "Ensure that the max-age is set to a sufficiently long duration (e.g., 1 year).", "Confirm that the header is present on all HTTPS responses."], "common_mistakes": ["Forgetting to include the 'preload' directive in the HSTS header.", "Setting a very short max-age value, which may not provide adequate protection.", "Not testing if the domain is actually included in the HSTS preload list."], "related_cwe": ["CWE-319", "CWE-300"], "related_capec": ["CAPEC-137", "CAPEC-155"], "attack_flow": "An attacker can intercept communications between the user and the application if the HSTS preload is not implemented. They can perform a MitM attack by downgrading the connection to HTTP, allowing them to capture sensitive data. By including the domain in the HSTS preload list, browsers will enforce HTTPS, preventing any such downgrades."}
{"chapter_id": "V3", "chapter_name": "Web Frontend Security", "section_id": "V3.7", "section_name": "Other Browser Security Considerations", "req_id": "V3.7.5", "req_description": "Verify that the application behaves as documented (such as warning the user or blocking access) if the browser used to access the application does not support the expected security features.", "level": "3", "explanation": "This requirement ensures that applications provide a clear response when accessed with browsers that do not support necessary security features. This could include displaying a warning message to the user or completely blocking access to the application until a compatible browser is used. The goal is to prevent users from unknowingly using insecure browsers that may expose them to vulnerabilities.", "threats_mitigated": ["Cross-Site Scripting (XSS)", "Man-in-the-Middle (MitM) attacks", "Data leakage due to insecure browsers", "Session hijacking"], "insecure_examples": [{"code_snippet": "if (!supportsSecurityFeatures()) { /* No warning or blocking */ }"}, {"code_snippet": "document.write('Welcome to the application.');"}], "secure_examples": [{"code_snippet": "if (!supportsSecurityFeatures()) { alert('Your browser does not support necessary security features. Please update or switch your browser.'); }"}, {"code_snippet": "window.location.href = 'unsupported-browser.html';"}], "verification_steps": ["Check if the application displays a warning when accessed with an unsupported browser.", "Verify that the application prevents access to critical functionality in unsupported browsers.", "Test with multiple browsers to ensure consistent behavior.", "Review documentation to confirm expected behavior is accurately described."], "common_mistakes": ["Failing to provide any feedback to users on unsupported browsers.", "Not testing the application on various browsers and versions.", "Assuming all users are using the latest browser versions."], "related_cwe": ["CWE-20", "CWE-200", "CWE-285"], "related_capec": ["CAPEC-104", "CAPEC-105"], "attack_flow": "An attacker may exploit the lack of browser feature verification by tricking users into using outdated or insecure browsers that do not support modern security features. This could lead to exploitation of vulnerabilities such as XSS or MitM attacks, resulting in data breaches or unauthorized access."}
{"chapter_id": "V4", "chapter_name": "API and Web Service", "section_id": "V4.1", "section_name": "Generic Web Service Security", "req_id": "V4.1.1", "req_description": "Verify that every HTTP response with a message body contains a Content-Type header field that matches the actual content of the response, including the charset parameter to specify safe character encoding (e.g., UTF-8, ISO-8859-1) according to IANA Media Types, such as \"text/\", \"/+xml\" and \"/xml\".", "level": "1", "explanation": "This requirement ensures that the server explicitly states the type of content being sent in the HTTP response. This is crucial for the client to correctly interpret the data received. Mismatched Content-Type headers can lead to security vulnerabilities, such as content injection attacks, where an attacker can manipulate the response content to be interpreted as a different type, potentially executing malicious scripts.", "threats_mitigated": ["Content Injection", "Cross-Site Scripting (XSS)", "MIME Sniffing Attacks"], "insecure_examples": [{"code": "HTTP/1.1 200 OK\nContent-Type: text/plain\n\n<script>alert('XSS');</script>"}, {"code": "HTTP/1.1 200 OK\nContent-Type: application/octet-stream\n\n{\"key\":\"value\"}"}], "secure_examples": [{"code": "HTTP/1.1 200 OK\nContent-Type: text/html; charset=UTF-8\n\n<html><body><h1>Secure Response</h1></body></html>"}, {"code": "HTTP/1.1 200 OK\nContent-Type: application/json; charset=UTF-8\n\n{\"key\":\"value\"}"}], "verification_steps": ["Check that every HTTP response includes a Content-Type header.", "Verify that the Content-Type header matches the actual content type of the response body.", "Ensure that the charset parameter is included and specifies a safe encoding.", "Review the server-side code to confirm proper handling of Content-Type headers."], "common_mistakes": ["Omitting the Content-Type header in responses.", "Using a generic Content-Type (e.g., application/octet-stream) instead of a specific type.", "Failing to include the charset parameter.", "Not validating the Content-Type against the actual content."], "related_cwe": ["CWE-20", "CWE-79", "CWE- MIME Sniffing"], "related_capec": ["CAPEC-137", "CAPEC-153", "CAPEC-113"], "attack_flow": "An attacker sends a request to a vulnerable web service that does not validate or correctly set the Content-Type header. The attacker manipulates the response to include executable scripts or malicious content. When the client receives the response, it interprets the content incorrectly due to the misleading Content-Type header, leading to the execution of the attacker's code in the user's browser or application."}
{"chapter_id": "V4", "chapter_name": "API and Web Service", "section_id": "V4.1", "section_name": "Generic Web Service Security", "req_id": "V4.1.2", "req_description": "Verify that only user-facing endpoints (intended for manual web-browser access) automatically redirect from HTTP to HTTPS, while other services or endpoints do not implement transparent redirects. This is to avoid a situation where a client is erroneously sending unencrypted HTTP requests, but since the requests are being automatically redirected to HTTPS, the leakage of sensitive data goes undiscovered.", "level": 2, "explanation": "This requirement emphasizes the importance of ensuring that only endpoints meant for user interaction in a web browser automatically redirect from HTTP to HTTPS. Other endpoints, particularly those intended for API calls or backend services, should not redirect automatically to prevent scenarios where sensitive information is sent over unencrypted channels without the client's knowledge. This helps maintain the confidentiality and integrity of data in transit.", "threats_mitigated": ["Man-in-the-middle attacks", "Data leakage", "Session hijacking", "Eavesdropping"], "insecure_examples": [{"code": "http://example.com/api/data -> https://example.com/api/data"}, {"code": "http://example.com/user/login -> https://example.com/user/login"}], "secure_examples": [{"code": "http://example.com -> https://example.com (only for user-facing endpoints)"}, {"code": "http://example.com/api/data (no automatic redirect, should use HTTPS explicitly)"}], "verification_steps": ["Identify user-facing endpoints and ensure they redirect from HTTP to HTTPS.", "Review API endpoints to confirm they do not implement automatic redirects.", "Test endpoints using tools to verify HTTP responses and redirection behavior.", "Check server configurations for redirect rules."], "common_mistakes": ["Implementing automatic redirects for API endpoints.", "Failing to differentiate between user-facing and backend services.", "Assuming HTTPS will be used without enforcing it on sensitive endpoints."], "related_cwe": ["CWE-319", "CWE-300", "CWE-601"], "related_capec": ["CAPEC-30", "CAPEC-31", "CAPEC-32"], "attack_flow": "An attacker intercepts HTTP traffic between the client and server. If the client is unaware that the endpoint is not secure and sends sensitive data over HTTP, the attacker can capture this data. If the endpoint automatically redirects to HTTPS, the client may believe the connection is secure, leading to a false sense of security and potential data leakage."}
{"chapter_id": "V4", "chapter_name": "API and Web Service", "section_id": "V4.1", "section_name": "Generic Web Service Security", "req_id": "V4.1.3", "req_description": "Verify that any HTTP header field used by the application and set by an intermediary layer, such as a load balancer, a web proxy, or a backend-for-frontend service, cannot be overridden by the end-user. Example headers might include X-Real-IP, X-Forwarded-*, or X-User-ID.", "level": 2, "explanation": "This requirement ensures that HTTP headers, which are critical for identifying the origin of requests and user identities, are not manipulated by end-users. If these headers can be overridden, it can lead to security vulnerabilities such as IP spoofing or unauthorized access based on false identities.", "threats_mitigated": ["IP Spoofing", "Session Hijacking", "User Impersonation", "Man-in-the-Middle Attacks"], "insecure_examples": [{"code": "request.headers['X-Real-IP'] = user_input"}, {"code": "request.headers['X-User-ID'] = user_input"}], "secure_examples": [{"code": "request.headers['X-Real-IP'] = get_real_ip()"}, {"code": "request.headers['X-User-ID'] = get_authenticated_user_id()"}], "verification_steps": ["Check that HTTP headers set by intermediary services cannot be modified by client input.", "Review the application code to ensure headers like X-Real-IP and X-User-ID are set securely.", "Test the application to confirm that attempts to override these headers are unsuccessful."], "common_mistakes": ["Allowing user input to directly set HTTP headers.", "Not validating or sanitizing headers that are set by the application.", "Assuming that intermediary services will always set headers correctly without additional checks."], "related_cwe": ["CWE-20", "CWE-77", "CWE-93"], "related_capec": ["CAPEC-118", "CAPEC-37"], "attack_flow": "An attacker could manipulate the HTTP headers sent in a request to impersonate another user or to spoof their IP address. This could allow them to bypass security mechanisms that rely on these headers for authentication or authorization, leading to unauthorized access or data exposure."}
{"chapter_id": "V4", "chapter_name": "API and Web Service", "section_id": "V4.1", "section_name": "Generic Web Service Security", "req_id": "V4.1.4", "req_description": "Verify that only HTTP methods that are explicitly supported by the application or its API (including OPTIONS during preflight requests) can be used and that unused methods are blocked.", "level": "3", "explanation": "This requirement ensures that the application only allows specific HTTP methods that are necessary for its functionality. By limiting the HTTP methods, the application reduces the attack surface and minimizes the risk of unintended actions being performed by an attacker using unsupported methods.", "threats_mitigated": ["Cross-Site Request Forgery (CSRF)", "HTTP Method Tampering", "Unauthorized Access", "Information Disclosure"], "insecure_examples": [{"code": "app.use((req, res, next) => { res.send('Hello World'); }); // No method restriction"}, {"code": "app.all('*', (req, res) => { res.send('All methods allowed'); }); // Allows all HTTP methods"}], "secure_examples": [{"code": "app.use((req, res, next) => { if (['GET', 'POST', 'OPTIONS'].includes(req.method)) { next(); } else { res.status(405).send('Method Not Allowed'); } }); // Restricts methods"}, {"code": "app.post('/api/resource', (req, res) => { res.send('Resource created'); }); // Only POST method allowed"}], "verification_steps": ["Review the API documentation to identify allowed HTTP methods.", "Check server configuration for method restrictions.", "Test unsupported methods (e.g., DELETE, PUT) to ensure they return a 405 Method Not Allowed response.", "Verify that OPTIONS requests are handled correctly for preflight checks."], "common_mistakes": ["Failing to restrict HTTP methods leading to potential misuse.", "Allowing all methods by default without proper validation.", "Not implementing proper error handling for unsupported methods."], "related_cwe": ["CWE-20", "CWE-74", "CWE-307"], "related_capec": ["CAPEC-137", "CAPEC-146"], "attack_flow": "An attacker may attempt to exploit the application by sending requests using unsupported HTTP methods (e.g., DELETE, PUT) to perform unauthorized actions. If the application does not properly restrict these methods, the attacker could manipulate resources or access sensitive data, leading to potential data breaches or service disruptions."}
{"chapter_id": "V4", "chapter_name": "API and Web Service", "section_id": "V4.1", "section_name": "Generic Web Service Security", "req_id": "V4.1.5", "req_description": "Verify that per-message digital signatures are used to provide additional assurance on top of transport protections for requests or transactions which are highly sensitive or which traverse a number of systems.", "level": 3, "explanation": "This requirement emphasizes the importance of using digital signatures for each message to ensure the integrity and authenticity of sensitive data as it moves across different systems. While transport layer security (TLS) protects data in transit, per-message signatures provide an additional layer of security by allowing the recipient to verify that the message has not been altered and that it was indeed sent by the claimed sender.", "threats_mitigated": ["Man-in-the-Middle (MitM) attacks", "Replay attacks", "Data tampering", "Spoofing"], "insecure_examples": [{"code": "request.setHeader('Authorization', 'Bearer ' + token); // No digital signature applied"}, {"code": "sendMessage(message); // Message sent without integrity checks"}], "secure_examples": [{"code": "const signature = createDigitalSignature(message, privateKey); request.setHeader('Signature', signature);"}, {"code": "const signedMessage = signMessage(message, privateKey); sendMessage(signedMessage);"}], "verification_steps": ["Check if digital signatures are implemented for each sensitive message.", "Verify that the signature is generated using a secure algorithm.", "Ensure that the public key used for verification is securely distributed.", "Test for the presence of signature verification logic on the receiving end."], "common_mistakes": ["Using weak or deprecated signature algorithms.", "Failing to validate the digital signature upon receipt.", "Not signing every sensitive message, relying solely on transport security.", "Hardcoding private keys in the application code."], "related_cwe": ["CWE-345: Insufficient Verification of Data Authenticity", "CWE-347: Improper Verification of Cryptographic Signature"], "related_capec": ["CAPEC-138: Message Replay", "CAPEC-151: Man-in-the-Middle Attack"], "attack_flow": "An attacker intercepts a message during transmission. Without a per-message digital signature, the attacker can modify the message or impersonate the sender. The recipient, lacking a means to verify the message's integrity and authenticity, processes the altered message, leading to potential data breaches or unauthorized actions."}
{"chapter_id": "V4", "chapter_name": "API and Web Service", "section_id": "V4.2", "section_name": "HTTP Message Structure Validation", "req_id": "V4.2.1", "req_description": "Verify that all application components (including load balancers, firewalls, and application servers) determine boundaries of incoming HTTP messages using the appropriate mechanism for the HTTP version to prevent HTTP request smuggling. In HTTP/1.x, if a Transfer-Encoding header field is present, the Content-Length header must be ignored per RFC 2616. When using HTTP/2 or HTTP/3, if a Content-Length header field is present, the receiver must ensure that it is consistent with the length of the DATA frames.", "level": 2, "explanation": "This requirement ensures that the application correctly interprets the boundaries of incoming HTTP messages to prevent request smuggling attacks. Request smuggling occurs when an attacker crafts a request that exploits discrepancies in how different components interpret HTTP message boundaries. By adhering to the specified rules for each HTTP version, applications can avoid processing ambiguous or malicious requests.", "threats_mitigated": ["HTTP request smuggling", "Session fixation", "Cross-site scripting (XSS) via smuggled requests"], "insecure_examples": [{"code": "if (request.headers['Transfer-Encoding']) {\n    // Process request without checking Content-Length\n}", "description": "This code processes requests without properly handling the Content-Length header when Transfer-Encoding is present."}, {"code": "if (request.headers['Content-Length'] && httpVersion === 'HTTP/2') {\n    // Accept request without validating DATA frame length\n}", "description": "This code accepts requests without validating that the Content-Length matches the DATA frame length in HTTP/2."}], "secure_examples": [{"code": "if (request.headers['Transfer-Encoding']) {\n    // Ignore Content-Length as per RFC 2616\n}", "description": "This code correctly ignores the Content-Length header when Transfer-Encoding is present."}, {"code": "if (httpVersion === 'HTTP/2' && request.headers['Content-Length']) {\n    validateDataFrameLength(request);\n}", "description": "This code validates that the Content-Length matches the length of the DATA frames in HTTP/2."}], "verification_steps": ["Check if application components validate the Content-Length header based on the HTTP version.", "Ensure that Transfer-Encoding is handled correctly in HTTP/1.x.", "Verify that DATA frame lengths are consistent with Content-Length in HTTP/2 and HTTP/3.", "Review server and proxy configurations for proper handling of HTTP message boundaries."], "common_mistakes": ["Ignoring the presence of Transfer-Encoding when Content-Length is also present.", "Failing to validate the Content-Length against DATA frame lengths in HTTP/2.", "Assuming all components interpret HTTP messages the same way."], "related_cwe": ["CWE-444", "CWE-20", "CWE-61"], "related_capec": ["CAPEC-48", "CAPEC-49"], "attack_flow": "An attacker sends a specially crafted HTTP request that includes both Transfer-Encoding and Content-Length headers. The application server processes the request differently than the load balancer, leading to the server interpreting the request as two separate requests. This allows the attacker to smuggle a malicious request that can exploit the application or manipulate the session."}
{"chapter_id": "V4", "chapter_name": "API and Web Service", "section_id": "V4.2", "section_name": "HTTP Message Structure Validation", "req_id": "V4.2.2", "req_description": "Verify that when generating HTTP messages, the Content-Length header field does not conflict with the length of the content as determined by the framing of the HTTP protocol, in order to prevent request smuggling attacks.", "level": 3, "explanation": "This requirement ensures that the Content-Length header accurately reflects the size of the body of the HTTP message. If there is a mismatch, it can lead to request smuggling, where an attacker can manipulate the request to bypass security controls or inject malicious payloads. Proper validation of this header helps maintain the integrity of HTTP communications.", "threats_mitigated": ["Request Smuggling", "HTTP Response Splitting", "Cross-Site Scripting (XSS) via manipulated responses"], "insecure_examples": ["POST /api/resource HTTP/1.1\r\nHost: example.com\r\nContent-Length: 100\r\n\r\n<malicious data>", "POST /api/resource HTTP/1.1\r\nHost: example.com\r\nContent-Length: 50\r\n\r\n<valid data><malicious data>"], "secure_examples": ["POST /api/resource HTTP/1.1\r\nHost: example.com\r\nContent-Length: 50\r\n\r\n<valid data>", "POST /api/resource HTTP/1.1\r\nHost: example.com\r\nContent-Length: 30\r\n\r\n<valid data>"], "verification_steps": ["Check if the Content-Length header is present in the HTTP request.", "Verify that the Content-Length value matches the actual length of the body content.", "Ensure that the server correctly interprets the Content-Length header according to the HTTP specification.", "Test with various payload sizes to confirm that mismatched Content-Length values are rejected."], "common_mistakes": ["Assuming that the Content-Length header is always correct without validation.", "Not handling cases where the Content-Length is missing or set to zero.", "Failing to account for chunked transfer encoding when validating Content-Length."], "related_cwe": ["CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request Smuggling')", "CWE-20: Improper Input Validation"], "related_capec": ["CAPEC-132: HTTP Response Splitting", "CAPEC-162: HTTP Request Smuggling"], "attack_flow": "An attacker crafts an HTTP request with a manipulated Content-Length header that does not match the actual size of the body. The server processes the request based on the incorrect Content-Length, leading to the server interpreting the request in an unintended way, allowing the attacker to smuggle additional requests or responses, potentially bypassing security measures."}
{"chapter_id": "V4", "chapter_name": "API and Web Service", "section_id": "V4.2", "section_name": "HTTP Message Structure Validation", "req_id": "V4.2.3", "req_description": "Verify that the application does not send nor accept HTTP/2 or HTTP/3 messages with connection-specific header fields such as Transfer-Encoding to prevent response splitting and header injection attacks.", "level": "3", "explanation": "This requirement ensures that the application properly validates HTTP messages to avoid vulnerabilities related to connection-specific headers. Connection-specific headers can be manipulated by attackers to alter the way responses are processed by clients or intermediaries, leading to potential security issues such as response splitting, where an attacker can inject additional HTTP responses, or header injection, where malicious headers can be introduced.", "threats_mitigated": ["Response Splitting", "Header Injection", "Cross-Site Scripting (XSS)", "Cache Poisoning"], "insecure_examples": [{"code": "response.setHeader('Transfer-Encoding', 'chunked');"}, {"code": "request.headers['Transfer-Encoding'] = 'gzip';"}], "secure_examples": [{"code": "response.removeHeader('Transfer-Encoding');"}, {"code": "if (!request.headers['Transfer-Encoding']) { /* process request */ }"}], "verification_steps": ["Check that the application does not set any connection-specific headers in HTTP responses.", "Review the HTTP request handling code to ensure that connection-specific headers are not accepted.", "Use security tools to scan for potential header injection vulnerabilities."], "common_mistakes": ["Not validating or sanitizing incoming headers before processing.", "Assuming that all headers are safe without proper checks.", "Failing to remove or validate connection-specific headers in responses."], "related_cwe": ["CWE-113", "CWE-74", "CWE-20"], "related_capec": ["CAPEC-137", "CAPEC-113"], "attack_flow": "An attacker sends a malicious HTTP request with a crafted 'Transfer-Encoding' header. If the application accepts this header without validation, it may lead to response splitting, allowing the attacker to inject additional responses or headers. This can result in various attacks such as XSS or cache poisoning, compromising user data or application integrity."}
{"chapter_id": "V4", "chapter_name": "API and Web Service", "section_id": "V4.2", "section_name": "HTTP Message Structure Validation", "req_id": "V4.2.4", "req_description": "Verify that the application only accepts HTTP/2 and HTTP/3 requests where the header fields and values do not contain any CR (\r), LF (\n), or CRLF (\r\n) sequences, to prevent header injection attacks.", "level": "3", "explanation": "This requirement ensures that the application validates HTTP/2 and HTTP/3 messages to prevent header injection attacks. By rejecting any headers that contain carriage return or line feed characters, the application can mitigate the risk of attackers injecting malicious content into headers, which could lead to various attacks such as response splitting or cross-site scripting.", "threats_mitigated": ["HTTP Header Injection", "Cross-Site Scripting (XSS)", "Response Splitting", "Denial of Service (DoS)"], "insecure_examples": [{"code": "request.Headers.Add(\"X-Custom-Header\", \"value\\r\\nInjected-Header: malicious\");"}, {"code": "if (request.Headers.Contains(\"X-Header\")) { var headerValue = request.Headers[\"X-Header\"]; }"}], "secure_examples": [{"code": "if (!headerValue.Contains(\"\\r\") && !headerValue.Contains(\"\\n\")) { request.Headers.Add(\"X-Custom-Header\", headerValue); }"}, {"code": "if (IsValidHeader(headerValue)) { request.Headers.Add(\"X-Header\", headerValue); }"}], "verification_steps": ["Review the code handling HTTP requests.", "Check for validation of header fields and values.", "Ensure that any CR, LF, or CRLF sequences are rejected.", "Test with various header inputs to confirm rejection of invalid headers."], "common_mistakes": ["Failing to validate header values before processing.", "Assuming all headers are safe without proper checks.", "Not considering edge cases where CR or LF might be present."], "related_cwe": ["CWE-113", "CWE-20", "CWE-74"], "related_capec": ["CAPEC-25", "CAPEC-34", "CAPEC-143"], "attack_flow": "An attacker sends a crafted HTTP request containing CR or LF characters in the headers. If the application does not validate the headers properly, it processes the request, allowing the attacker to inject additional headers or manipulate the response, potentially leading to unauthorized access or data leakage."}
{"chapter_id": "V4", "chapter_name": "API and Web Service", "section_id": "V4.2", "section_name": "HTTP Message Structure Validation", "req_id": "V4.2.5", "req_description": "Verify that, if the application (backend or frontend) builds and sends requests, it uses validation, sanitization, or other mechanisms to avoid creating URIs (such as for API calls) or HTTP request header fields (such as Authorization or Cookie), which are too long to be accepted by the receiving component. This could cause a denial of service, such as when sending an overly long request (e.g., a long cookie header field), which results in the server always responding with an error status.", "level": 3, "explanation": "This requirement emphasizes the importance of validating and sanitizing the lengths of URIs and HTTP headers before they are sent to a server. If an application allows excessively long values, it may lead to denial of service (DoS) attacks, where the server becomes unresponsive due to processing errors or resource exhaustion caused by handling such requests.", "threats_mitigated": ["Denial of Service (DoS)", "Buffer Overflow", "Resource Exhaustion"], "insecure_examples": [{"code": "const request = new XMLHttpRequest();\nrequest.open('GET', 'https://api.example.com/resource?param=' + longParam, true);\nrequest.send();"}, {"code": "fetch('https://api.example.com/resource', {\n  headers: { 'Authorization': longAuthorizationHeader }\n});"}], "secure_examples": [{"code": "const sanitizedParam = longParam.substring(0, 2000); // Limit length\nconst request = new XMLHttpRequest();\nrequest.open('GET', 'https://api.example.com/resource?param=' + sanitizedParam, true);\nrequest.send();"}, {"code": "const sanitizedHeader = longAuthorizationHeader.substring(0, 2000); // Limit length\nfetch('https://api.example.com/resource', {\n  headers: { 'Authorization': sanitizedHeader }\n});"}], "verification_steps": ["Check if the application validates the length of URIs and HTTP headers.", "Ensure that there are limits set for maximum lengths of parameters and headers.", "Review the code for any instances where user input is directly used in URIs or headers without validation.", "Test the application with long inputs to see if it handles them gracefully."], "common_mistakes": ["Failing to set maximum length limits for URI parameters and HTTP headers.", "Directly using user input in requests without validation or sanitization.", "Assuming that the server will handle overly long requests without errors."], "related_cwe": ["CWE-400", "CWE-20", "CWE-22"], "related_capec": ["CAPEC-137", "CAPEC-153"], "attack_flow": "An attacker crafts a request with excessively long URIs or headers, sending it to the application. If the application does not validate the length, the server may become overwhelmed, leading to errors or crashes. This can result in a denial of service, preventing legitimate users from accessing the service."}
{"chapter_id": "V4", "chapter_name": "API and Web Service", "section_id": "V4.3", "section_name": "GraphQL", "req_id": "V4.3.1", "req_description": "Verify that a query allowlist, depth limiting, amount limiting, or query cost analysis is used to prevent GraphQL or data layer expression Denial of Service (DoS) as a result of expensive, nested queries.", "level": 2, "explanation": "This requirement emphasizes the importance of implementing controls in GraphQL APIs to mitigate the risk of Denial of Service attacks. By using query allowlists, limiting the depth of queries, restricting the amount of data returned, or analyzing the cost of queries, developers can prevent users from executing overly complex queries that could exhaust server resources, leading to service outages.", "threats_mitigated": ["Denial of Service (DoS)", "Resource Exhaustion", "Performance Degradation"], "insecure_examples": [{"code": "const query = `{ user { name, email, posts { title, content } } }`;"}, {"code": "const query = `{ user { name, email, posts { title, content, comments { text, author { name } } } } }`;"}], "secure_examples": [{"code": "const query = `{ user { name, email } }`;"}, {"code": "const query = `{ user { name } }`;"}], "verification_steps": ["Check if a query allowlist is implemented.", "Verify that query depth limiting is enforced.", "Ensure that amount limiting is applied to responses.", "Review the implementation of query cost analysis mechanisms."], "common_mistakes": ["Not implementing any form of query limiting.", "Allowing unrestricted nested queries.", "Failing to monitor and analyze query performance."], "related_cwe": ["CWE-400", "CWE-770"], "related_capec": ["CAPEC-137", "CAPEC-153"], "attack_flow": "An attacker crafts a deeply nested or highly complex GraphQL query that, when executed, consumes excessive server resources. This can lead to slow responses or complete service unavailability, effectively causing a Denial of Service for legitimate users."}
{"chapter_id": "V4", "chapter_name": "API and Web Service", "section_id": "V4.3", "section_name": "GraphQL", "req_id": "V4.3.2", "req_description": "Verify that GraphQL introspection queries are disabled in the production environment unless the GraphQL API is meant to be used by other parties.", "level": 2, "explanation": "GraphQL introspection allows clients to query the schema of the API, revealing types, fields, and operations that can be performed. In a production environment, exposing this information can lead to security vulnerabilities, as attackers can gain insights into the API structure and potentially exploit it. Therefore, introspection should be disabled unless necessary for external clients.", "threats_mitigated": ["Information Disclosure", "API Abuse", "Unauthorized Access"], "insecure_examples": [{"code": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst schema = require('./schema');\n\nconst app = express();\n\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  graphiql: true // Introspection enabled\n}));\n\napp.listen(4000);"}, {"code": "const { ApolloServer } = require('apollo-server');\n\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  introspection: true // Introspection enabled in production\n});\n\nserver.listen().then(({ url }) => {\n  console.log(`ðŸš€  Server ready at ${url}`);\n});"}], "secure_examples": [{"code": "const express = require('express');\nconst { graphqlHTTP } = require('express-graphql');\nconst schema = require('./schema');\n\nconst app = express();\n\napp.use('/graphql', graphqlHTTP({\n  schema: schema,\n  graphiql: false // Introspection disabled\n}));\n\napp.listen(4000);"}, {"code": "const { ApolloServer } = require('apollo-server');\n\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  introspection: false // Introspection disabled in production\n});\n\nserver.listen().then(({ url }) => {\n  console.log(`ðŸš€  Server ready at ${url}`);\n});"}], "verification_steps": ["Check the GraphQL server configuration for introspection settings.", "Ensure that introspection is disabled in production environments.", "Review documentation to confirm if the API is intended for external access.", "Test the GraphQL endpoint to verify that introspection queries return an error in production."], "common_mistakes": ["Leaving introspection enabled in production environments.", "Not differentiating between development and production configurations.", "Assuming that introspection is harmless without understanding its implications."], "related_cwe": ["CWE-200", "CWE-284"], "related_capec": ["CAPEC-137", "CAPEC-164"], "attack_flow": "An attacker sends a GraphQL introspection query to the API endpoint. If introspection is enabled, the attacker receives detailed information about the API schema, including types and fields. This information can be used to craft targeted attacks, such as exploiting vulnerabilities in specific queries or performing unauthorized operations."}
{"chapter_id": "V4", "chapter_name": "API and Web Service", "section_id": "V4.4", "section_name": "WebSocket", "req_id": "V4.4.1", "req_description": "Verify that WebSocket over TLS (WSS) is used for all WebSocket connections.", "level": "1", "explanation": "This requirement ensures that all WebSocket communications are encrypted using TLS, which protects the data in transit from eavesdropping and tampering. Using WSS (WebSocket Secure) instead of plain WebSocket helps secure the connection by providing confidentiality, integrity, and authentication.", "threats_mitigated": ["Eavesdropping", "Man-in-the-middle attacks", "Data tampering"], "insecure_examples": ["const socket = new WebSocket('ws://example.com/socket');", "let socket = new WebSocket('ws://example.com');"], "secure_examples": ["const socket = new WebSocket('wss://example.com/socket');", "let socket = new WebSocket('wss://example.com');"], "verification_steps": ["Check if the WebSocket connection URL starts with 'wss://'.", "Ensure that the server supports TLS and is configured correctly.", "Verify that the WebSocket traffic is encrypted using a valid TLS certificate."], "common_mistakes": ["Using 'ws://' instead of 'wss://'.", "Neglecting to validate the server's TLS certificate.", "Assuming that WebSocket connections are secure by default."], "related_cwe": ["CWE-319", "CWE-295"], "related_capec": ["CAPEC-139", "CAPEC-146"], "attack_flow": "An attacker could intercept the WebSocket connection if it uses 'ws://' instead of 'wss://'. By doing so, they could capture sensitive information being transmitted, inject malicious data, or impersonate the server to the client, leading to data breaches or unauthorized actions."}
{"chapter_id": "V4", "chapter_name": "API and Web Service", "section_id": "V4.4", "section_name": "WebSocket", "req_id": "V4.4.2", "req_description": "Verify that, during the initial HTTP WebSocket handshake, the Origin header field is checked against a list of origins allowed for the application.", "level": "2", "explanation": "This requirement ensures that only requests from trusted origins are allowed to establish a WebSocket connection. By validating the Origin header, applications can prevent unauthorized domains from initiating WebSocket communications, which could lead to Cross-Site WebSocket Hijacking (CSWSH) attacks.", "threats_mitigated": ["Cross-Site WebSocket Hijacking", "Cross-Origin Resource Sharing (CORS) Misconfigurations", "Unauthorized Access to WebSocket Endpoints"], "insecure_examples": ["if (request.headers['Origin'] === 'http://malicious.com') { /* allow connection */ }", "const allowedOrigins = ['http://example.com']; if (!allowedOrigins.includes(request.headers['Origin'])) { /* allow connection */ }"], "secure_examples": ["const allowedOrigins = ['http://example.com', 'http://anothertrusted.com']; if (allowedOrigins.includes(request.headers['Origin'])) { /* allow connection */ } else { /* reject connection */ }", "const validOrigins = new Set(['http://example.com', 'http://anothertrusted.com']); if (!validOrigins.has(request.headers['Origin'])) { /* reject connection */ }"], "verification_steps": ["Check that the application checks the Origin header during the WebSocket handshake.", "Verify that the list of allowed origins is properly configured and maintained.", "Test with various origins to ensure that only allowed origins can establish a connection."], "common_mistakes": ["Not validating the Origin header at all.", "Using a static list of origins that is not updated or maintained.", "Assuming that all requests from the same domain are safe without checking the Origin header."], "related_cwe": ["CWE-346: Origin Validation Error", "CWE-20: Improper Input Validation", "CWE-200: Information Exposure"], "related_capec": ["CAPEC-139: Cross-Site WebSocket Hijacking", "CAPEC-151: Cross-Site Request Forgery (CSRF)"], "attack_flow": "An attacker can exploit this requirement by sending a WebSocket handshake request from a malicious origin. If the application does not validate the Origin header correctly, the attacker can establish a WebSocket connection and potentially execute unauthorized actions or exfiltrate sensitive data."}
{"chapter_id": "V4", "chapter_name": "API and Web Service", "section_id": "V4.4", "section_name": "WebSocket", "req_id": "V4.4.3", "req_description": "Verify that, if the application's standard session management cannot be used, dedicated tokens are being used for this, which comply with the relevant Session Management security requirements.", "level": "2", "explanation": "This requirement emphasizes the importance of using dedicated tokens for session management when the standard mechanisms are not applicable. These tokens should be uniquely generated, securely stored, and should adhere to best practices in session management to prevent unauthorized access and session hijacking.", "threats_mitigated": ["Session hijacking", "Token reuse", "Cross-site request forgery (CSRF)", "Replay attacks"], "insecure_examples": [{"code": "const token = '12345'; // Hardcoded token usage"}, {"code": "sessionStorage.setItem('sessionToken', 'abcde'); // Storing token in sessionStorage without encryption"}], "secure_examples": [{"code": "const token = generateSecureToken(); // Use a secure token generation method"}, {"code": "sessionStorage.setItem('sessionToken', encrypt(token)); // Store token securely"}], "verification_steps": ["Check if dedicated tokens are used when standard session management is not applicable.", "Review the token generation mechanism for randomness and uniqueness.", "Ensure tokens are stored securely and not exposed in client-side code.", "Verify that tokens have appropriate expiration and revocation mechanisms."], "common_mistakes": ["Using predictable or easily guessable token values.", "Failing to implement token expiration and invalidation.", "Storing tokens in insecure locations, such as local storage without encryption."], "related_cwe": ["CWE-287", "CWE-384", "CWE-346"], "related_capec": ["CAPEC-137", "CAPEC-159", "CAPEC-134"], "attack_flow": "An attacker can exploit this requirement by intercepting or guessing the dedicated token used for session management. If the token is predictable or not properly secured, the attacker can impersonate a legitimate user, gaining unauthorized access to the application and its resources."}
{"chapter_id": "V4", "chapter_name": "API and Web Service", "section_id": "V4.4", "section_name": "WebSocket", "req_id": "V4.4.4", "req_description": "Verify that dedicated WebSocket session management tokens are initially obtained or validated through the previously authenticated HTTPS session when transitioning an existing HTTPS session to a WebSocket channel.", "level": 2, "explanation": "This requirement ensures that WebSocket connections, which can be long-lived and stateful, are established securely by leveraging session management tokens that are validated against an existing authenticated HTTPS session. This prevents unauthorized access and session hijacking during the transition from HTTPS to WebSocket.", "threats_mitigated": ["Session Hijacking", "Man-in-the-Middle Attacks", "Unauthorized Access"], "insecure_examples": ["const socket = new WebSocket('ws://example.com/socket'); // No session validation", "const token = getTokenFromLocalStorage(); // Token not validated against HTTPS session"], "secure_examples": ["const socket = new WebSocket('wss://example.com/socket?token=' + getValidTokenFromHttpsSession()); // Token validated", "const token = getTokenFromHttpsSession(); // Token obtained from authenticated HTTPS session"], "verification_steps": ["Check if WebSocket connections are initiated over 'wss://' protocol.", "Ensure that session tokens are validated against the existing HTTPS session.", "Verify that tokens are not hardcoded or exposed in client-side code.", "Review server-side logic to confirm that session management is enforced."], "common_mistakes": ["Using unsecured WebSocket connections (ws:// instead of wss://).", "Failing to validate session tokens against an authenticated session.", "Not implementing token expiration or revocation mechanisms."], "related_cwe": ["CWE-287", "CWE-384", "CWE-601"], "related_capec": ["CAPEC-92", "CAPEC-139", "CAPEC-154"], "attack_flow": "An attacker could intercept the initial HTTPS session and obtain the session token. If the WebSocket connection is established without validating this token against the authenticated session, the attacker could then hijack the WebSocket connection, leading to unauthorized actions and data exposure."}
{"chapter_id": "V5", "chapter_name": "File Handling", "section_id": "V5.1", "section_name": "File Handling Documentation", "req_id": "V5.1.1", "req_description": "Verify that the documentation defines the permitted file types, expected file extensions, and maximum size (including unpacked size) for each upload feature. Additionally, ensure that the documentation specifies how files are made safe for end-users to download and process, such as how the application behaves when a malicious file is detected.", "level": "2", "explanation": "This requirement emphasizes the importance of having clear and comprehensive documentation regarding file uploads. It ensures that developers and users are aware of the types of files that can be uploaded, the size limits, and the measures taken to secure the application against malicious files. Proper documentation helps in maintaining security and usability, guiding users to avoid uploading harmful files.", "threats_mitigated": ["Malicious file uploads", "Denial of Service through oversized files", "File type confusion attacks"], "insecure_examples": ["if (uploadedFile.type !== 'image/png' || uploadedFile.size > 500000) { throw new Error('Invalid file'); }", "const allowedExtensions = ['.exe', '.bat']; if (allowedExtensions.includes(fileExtension)) { processFile(file); }"], "secure_examples": ["const allowedTypes = ['image/png', 'image/jpeg']; if (!allowedTypes.includes(uploadedFile.type) || uploadedFile.size > 500000) { throw new Error('Invalid file'); }", "const allowedExtensions = ['.jpg', '.png']; if (!allowedExtensions.includes(fileExtension)) { throw new Error('Invalid file type'); }"], "verification_steps": ["Review the documentation for specified file types and extensions.", "Check the maximum file size limits stated in the documentation.", "Ensure that the documentation describes how to handle malicious files.", "Verify that the application behavior is documented for different file upload scenarios."], "common_mistakes": ["Failing to document all permitted file types and their extensions.", "Not specifying the maximum file size, leading to potential denial of service.", "Neglecting to outline how to handle malicious files in the documentation."], "related_cwe": ["CWE-20: Improper Input Validation", "CWE-434: Unrestricted File Upload", "CWE-125: Out-of-bounds Read"], "related_capec": ["CAPEC-110: File Upload Attack", "CAPEC-118: Malicious File Execution", "CAPEC-141: Content Spoofing"], "attack_flow": "An attacker may exploit this requirement by crafting a malicious file that is allowed by the current documentation and upload it to the application. If the documentation does not specify the required validations or maximum file size, the application may process this file, leading to potential exploitation, such as executing harmful code or causing a denial of service."}
{"chapter_id": "V5", "chapter_name": "File Handling", "section_id": "V5.2", "section_name": "File Upload and Content", "req_id": "V5.2.1", "req_description": "Verify that the application will only accept files of a size which it can process without causing a loss of performance or a denial of service attack.", "level": "1", "explanation": "This requirement ensures that the application imposes restrictions on the size of files that can be uploaded. By limiting file sizes, the application can prevent performance degradation and denial of service (DoS) attacks that could occur if excessively large files are processed.", "threats_mitigated": ["Denial of Service (DoS)", "Resource Exhaustion", "Performance Degradation"], "insecure_examples": ["app.post('/upload', (req, res) => { const file = req.files.uploadedFile; // No size validation if (file) { // process file } });", "upload.single('file')(req, res, function (err) { // No checks on file size // process file });"], "secure_examples": ["app.post('/upload', (req, res) => { const file = req.files.uploadedFile; if (file.size <= MAX_FILE_SIZE) { // process file } else { res.status(400).send('File too large'); } });", "upload.single('file')(req, res, function (err) { if (req.file.size <= MAX_FILE_SIZE) { // process file } else { return res.status(400).send('File too large'); } });"], "verification_steps": ["Check that file size limits are enforced on the server-side.", "Review the upload handling code to ensure that there are checks for file size.", "Test the application with files of varying sizes to confirm behavior.", "Ensure error messages are appropriate for oversized files."], "common_mistakes": ["Not implementing server-side checks for file size.", "Relying solely on client-side validations which can be bypassed.", "Failing to handle errors gracefully when large files are uploaded."], "related_cwe": ["CWE-400", "CWE-770"], "related_capec": ["CAPEC-137", "CAPEC-155"], "attack_flow": "An attacker may attempt to upload excessively large files to the application. If the application does not validate the file size, it may attempt to process these files, leading to resource exhaustion. This can cause the application to slow down significantly or crash, resulting in a denial of service for legitimate users."}
{"chapter_id": "V5", "chapter_name": "File Handling", "section_id": "V5.2", "section_name": "File Upload and Content", "req_id": "V5.2.2", "req_description": "Verify that when the application accepts a file, either on its own or within an archive such as a zip file, it checks if the file extension matches an expected file extension and validates that the contents correspond to the type represented by the extension. This includes, but is not limited to, checking the initial 'magic bytes', performing image re-writing, and using specialized libraries for file content validation. For L1, this can focus just on files which are used to make specific business or security decisions. For L2 and up, this must apply to all files being accepted.", "level": "1", "explanation": "This requirement ensures that applications do not accept arbitrary files that could be harmful. By validating both the file extension and the actual content of the file, applications can prevent various types of attacks, such as executing malicious code or uploading harmful files. It is essential for applications that handle file uploads to implement strict checks to ensure that only valid file types are processed.", "threats_mitigated": ["Malware Upload", "Remote Code Execution", "File Inclusion Attacks", "Denial of Service via malicious files"], "insecure_examples": [{"code": "if (uploadedFile.getExtension() == 'exe') { processFile(uploadedFile); }", "description": "This code only checks the file extension and does not validate the content."}, {"code": "acceptFile(uploadedFile);", "description": "This code accepts any file without any validation."}], "secure_examples": [{"code": "if (isValidFile(uploadedFile)) { processFile(uploadedFile); }", "description": "This code uses a function to validate both the extension and the content."}, {"code": "if (isImage(uploadedFile) && isValidMagicBytes(uploadedFile)) { acceptFile(uploadedFile); }", "description": "This code checks for both the file type and its magic bytes."}], "verification_steps": ["Check that the application verifies the file extension against a whitelist.", "Ensure that the application validates the content of the file using magic bytes.", "Test the application with various file types to confirm that it rejects invalid files.", "Review the code for any instances of unchecked file uploads."], "common_mistakes": ["Only checking the file extension without content validation.", "Using a generic method for file upload without specific checks for different file types.", "Failing to update the whitelist of allowed file types as new threats emerge."], "related_cwe": ["CWE-434", "CWE-20", "CWE-125"], "related_capec": ["CAPEC-138", "CAPEC-137"], "attack_flow": "An attacker uploads a malicious file disguised with a valid extension (e.g., .jpg) that contains executable code. If the application does not validate the file content, it may process the file, leading to code execution on the server, data leakage, or other malicious outcomes."}
{"chapter_id": "V5", "chapter_name": "File Handling", "section_id": "V5.2", "section_name": "File Upload and Content", "req_id": "V5.2.3", "req_description": "Verify that the application checks compressed files (e.g., zip, gz, docx, odt) against maximum allowed uncompressed size and against maximum number of files before uncompressing the file.", "level": 2, "explanation": "This requirement ensures that applications impose limits on the size and number of files that can be extracted from compressed archives. By enforcing these limits, applications can prevent resource exhaustion attacks and mitigate the risk of denial-of-service (DoS) vulnerabilities that can arise from processing excessively large files or too many files at once.", "threats_mitigated": ["Denial of Service (DoS)", "Resource Exhaustion", "Arbitrary File Upload", "Malicious File Extraction"], "insecure_examples": [{"code": "if (file.isCompressed()) { file.extract(); }"}, {"code": "uncompress(file); // No size or file count checks"}], "secure_examples": [{"code": "if (file.isCompressed() && file.getUncompressedSize() <= MAX_SIZE && file.getFileCount() <= MAX_FILES) { file.extract(); }"}, {"code": "if (isValidCompressedFile(file)) { uncompress(file); }"}], "verification_steps": ["Check if the application enforces a maximum uncompressed file size.", "Verify that the application limits the number of files that can be extracted from a compressed archive.", "Test with compressed files exceeding size and file count limits to ensure they are rejected.", "Review the code to confirm that size and file count checks are implemented before extraction."], "common_mistakes": ["Failing to validate the uncompressed size of files.", "Not limiting the number of files being extracted from a compressed archive.", "Assuming all compressed files are safe without validation."], "related_cwe": ["CWE-400", "CWE-20", "CWE-22"], "related_capec": ["CAPEC-139", "CAPEC-111"], "attack_flow": "An attacker creates a compressed file containing a large number of files or a single file that exceeds the application's size limit. If the application does not validate the size or count before extraction, it may consume excessive resources, leading to a denial of service. The attacker can exploit this to make the application unresponsive or crash."}
{"chapter_id": "V5", "chapter_name": "File Handling", "section_id": "V5.2", "section_name": "File Upload and Content", "req_id": "V5.2.4", "req_description": "Verify that a file size quota and maximum number of files per user are enforced to ensure that a single user cannot fill up the storage with too many files, or excessively large files.", "level": 3, "explanation": "This requirement ensures that the application limits the amount of storage space that each user can consume. By enforcing a file size quota and a maximum number of files, the application can prevent abuse where a single user uploads numerous large files, potentially leading to denial of service for other users or exhausting storage resources. This is particularly important in shared environments where multiple users rely on the same storage infrastructure.", "threats_mitigated": ["Denial of Service (DoS)", "Resource Exhaustion", "Abuse of storage resources"], "insecure_examples": ["if (file.size > MAX_SIZE) { /* allow upload */ }", "userFiles.push(uploadedFile); // No limit checks"], "secure_examples": ["if (file.size > MAX_SIZE || userFiles.length >= MAX_FILES) { throw new Error('File size or number of files exceeded.'); }", "if (userFiles.length < MAX_FILES) { userFiles.push(uploadedFile); }"], "verification_steps": ["Check that file size limits are enforced on the server-side.", "Verify that the maximum number of files per user is implemented.", "Test with a user uploading files exceeding the limits to ensure proper error handling.", "Review application logs for any bypass attempts."], "common_mistakes": ["Implementing file size checks only on the client side.", "Failing to account for multiple file uploads in quota enforcement.", "Not providing clear error messages to users when limits are exceeded."], "related_cwe": ["CWE-400: Uncontrolled Resource Consumption", "CWE-20: Improper Input Validation"], "related_capec": ["CAPEC-137: Resource Exhaustion Attack", "CAPEC-118: Denial of Service via Resource Consumption"], "attack_flow": "An attacker may attempt to upload numerous large files to the application, bypassing any limits that are not enforced on the server side. This could lead to the application running out of storage space, causing legitimate users to be unable to upload their files, effectively resulting in a denial of service."}
{"chapter_id": "V5", "chapter_name": "File Handling", "section_id": "V5.2", "section_name": "File Upload and Content", "req_id": "V5.2.5", "req_description": "Verify that the application does not allow uploading compressed files containing symlinks unless this is specifically required (in which case it will be necessary to enforce an allowlist of the files that can be symlinked to).", "level": "3", "explanation": "This requirement ensures that applications do not inadvertently allow the upload of compressed files that contain symbolic links (symlinks), which can point to arbitrary files on the server. Allowing such uploads can lead to security vulnerabilities, such as unauthorized access to sensitive files or even remote code execution. If symlink uploads are necessary, they must be strictly controlled through an allowlist.", "threats_mitigated": ["Arbitrary file access", "Remote code execution", "Denial of service via file system manipulation"], "insecure_examples": [{"code": "upload_file(file); // User uploads a compressed file containing a symlink."}, {"code": "if (isCompressed(file)) { processFile(file); } // No checks for symlinks."}], "secure_examples": [{"code": "if (isCompressed(file) && !containsSymlinks(file)) { uploadFile(file); }"}, {"code": "if (isCompressed(file) && isAllowedSymlink(file)) { uploadFile(file); } // Only allows specific symlinks."}], "verification_steps": ["Review the file upload functionality for compressed file handling.", "Check if there are validations to detect symlinks in uploaded files.", "Verify the implementation of an allowlist for symlinks if they are permitted.", "Test the application by uploading compressed files with and without symlinks."], "common_mistakes": ["Failing to validate the contents of compressed files before processing.", "Not implementing checks for symlinks in uploaded files.", "Assuming that all file uploads are safe without proper validation."], "related_cwe": ["CWE-22", "CWE-36", "CWE-73"], "related_capec": ["CAPEC-104", "CAPEC-127"], "attack_flow": "An attacker uploads a compressed file containing a symlink that points to a sensitive file on the server. If the application processes this file without validating its contents, it may inadvertently expose sensitive data or allow the attacker to execute arbitrary commands, leading to a compromise of the server."}
{"chapter_id": "V5", "chapter_name": "File Handling", "section_id": "V5.2", "section_name": "File Upload and Content", "req_id": "V5.2.6", "req_description": "Verify that the application rejects uploaded images with a pixel size larger than the maximum allowed, to prevent pixel flood attacks.", "level": "3", "explanation": "This requirement mandates that applications must implement checks on the dimensions of uploaded images. If an image exceeds a predefined maximum pixel size, it should be rejected. This is crucial to prevent pixel flood attacks, where an attacker uploads excessively large images to exhaust server resources, leading to denial of service or other performance issues.", "threats_mitigated": ["Denial of Service (DoS)", "Resource Exhaustion", "Server Performance Degradation"], "insecure_examples": [{"code": "if (uploadedImage.size > MAX_SIZE) { /* process image */ }", "description": "This code does not check the pixel dimensions of the image, only its file size."}, {"code": "processImage(uploadedImage);", "description": "This code directly processes the image without validating its dimensions."}], "secure_examples": [{"code": "if (uploadedImage.width <= MAX_WIDTH && uploadedImage.height <= MAX_HEIGHT) { /* process image */ }", "description": "This code checks both the width and height of the image before processing."}, {"code": "if (validateImageDimensions(uploadedImage)) { processImage(uploadedImage); }", "description": "This code uses a function to validate that the image dimensions are within allowed limits."}], "verification_steps": ["Check that the application has defined maximum pixel dimensions for image uploads.", "Review the image upload handling code to ensure dimension checks are implemented.", "Test the application by uploading images that exceed the maximum dimensions to verify they are rejected.", "Ensure logging is in place for rejected uploads to monitor potential attacks."], "common_mistakes": ["Only validating the file size instead of the pixel dimensions.", "Failing to implement checks for both width and height.", "Not providing user feedback when an image is rejected due to size."], "related_cwe": ["CWE-400", "CWE-770", "CWE-20"], "related_capec": ["CAPEC-87", "CAPEC-118"], "attack_flow": "An attacker uploads an image with extremely high pixel dimensions. If the application does not validate the dimensions, it processes the image, consuming excessive server resources. This can lead to slowdowns or crashes, resulting in denial of service for legitimate users."}
{"chapter_id": "V5", "chapter_name": "File Handling", "section_id": "V5.3", "section_name": "File Storage", "req_id": "V5.3.1", "req_description": "Verify that files uploaded or generated by untrusted input and stored in a public folder, are not executed as server-side program code when accessed directly with an HTTP request.", "level": "1", "explanation": "This requirement ensures that any files uploaded by users or generated from untrusted sources are stored in a way that they cannot be executed as code by the server. This is crucial for preventing remote code execution vulnerabilities, where an attacker could upload a malicious script and execute it on the server by accessing it directly via an HTTP request.", "threats_mitigated": ["Remote Code Execution", "File Inclusion Attacks", "Malicious File Uploads"], "insecure_examples": [{"code": "move_uploaded_file($_FILES['userfile']['tmp_name'], '/var/www/html/uploads/' . $_FILES['userfile']['name']);"}, {"code": "file_put_contents('/var/www/html/uploads/' . $filename, $content);"}], "secure_examples": [{"code": "move_uploaded_file($_FILES['userfile']['tmp_name'], '/var/www/html/uploads/' . basename($_FILES['userfile']['name']));"}, {"code": "file_put_contents('/var/www/html/uploads/' . basename($filename), $content);"}], "verification_steps": ["Ensure uploaded files are stored outside the web root.", "Verify that file extensions are validated against a whitelist.", "Check that the server is configured to prevent execution of files in the upload directory.", "Review access controls on the upload directory."], "common_mistakes": ["Storing uploaded files in a publicly accessible directory.", "Failing to validate file types or extensions.", "Not applying proper server configuration to restrict file execution."], "related_cwe": ["CWE-434", "CWE-20", "CWE-22"], "related_capec": ["CAPEC-137", "CAPEC-151", "CAPEC-132"], "attack_flow": "An attacker uploads a malicious file (e.g., a PHP script) to a public folder. If the application does not validate the file type and allows execution, the attacker can access the file directly through a web request, leading to remote code execution on the server."}
{"chapter_id": "V5", "chapter_name": "File Handling", "section_id": "V5.3", "section_name": "File Storage", "req_id": "V5.3.2", "req_description": "Verify that when the application creates file paths for file operations, instead of user-submitted filenames, it uses internally generated or trusted data, or if user-submitted filenames or file metadata must be used, strict validation and sanitization must be applied. This is to protect against path traversal, local or remote file inclusion (LFI, RFI), and server-side request forgery (SSRF) attacks.", "level": 1, "explanation": "This requirement emphasizes the importance of using secure file paths to prevent unauthorized access to the filesystem. By ensuring that filenames come from trusted sources or are properly validated, applications can mitigate risks associated with path traversal and file inclusion vulnerabilities. This means that any user input related to file paths must be thoroughly checked to ensure it does not lead to unintended file access or manipulation.", "threats_mitigated": ["Path Traversal", "Local File Inclusion (LFI)", "Remote File Inclusion (RFI)", "Server-Side Request Forgery (SSRF)"], "insecure_examples": ["file_get_contents($_GET['filename']);", "include($_POST['file']);"], "secure_examples": ["$filename = basename($_GET['filename']); if (is_file($base_path . $filename)) { file_get_contents($base_path . $filename); }", "$file = filter_input(INPUT_POST, 'file', FILTER_SANITIZE_STRING); include($base_path . $file);"], "verification_steps": ["Check that all file paths are generated using trusted data.", "Verify that user-submitted filenames are validated against a whitelist.", "Ensure that proper sanitization is applied to any user input related to file paths.", "Review any file operations to confirm they do not expose sensitive files."], "common_mistakes": ["Failing to validate user input before using it in file operations.", "Using user input directly in file paths without any sanitization.", "Not implementing a whitelist of allowed filenames or paths."], "related_cwe": ["CWE-22", "CWE-23", "CWE-36", "CWE-74"], "related_capec": ["CAPEC-118", "CAPEC-137", "CAPEC-144"], "attack_flow": "An attacker submits a specially crafted filename that includes directory traversal sequences (e.g., '../') to access sensitive files on the server. If the application directly uses this input in file operations without validation, the attacker can read or include files that should not be accessible, potentially leading to data exposure or remote code execution."}
{"chapter_id": "V5", "chapter_name": "File Handling", "section_id": "V5.3", "section_name": "File Storage", "req_id": "V5.3.3", "req_description": "Verify that server-side file processing, such as file decompression, ignores user-provided path information to prevent vulnerabilities such as zip slip.", "level": "3", "explanation": "This requirement emphasizes the importance of validating and sanitizing file paths when processing files on the server side. It is crucial to ensure that any user input, especially file paths, does not lead to unintended file access or manipulation. By ignoring user-provided path information, applications can prevent attackers from exploiting vulnerabilities like zip slip, where an attacker can manipulate archive files to extract files outside of the intended directory.", "threats_mitigated": ["Zip Slip", "Directory Traversal", "Arbitrary File Write", "Unauthorized File Access"], "insecure_examples": [{"code": "FileInputStream fis = new FileInputStream(userProvidedPath);"}, {"code": "unzip(userProvidedZipFile, userProvidedDestinationPath);"}], "secure_examples": [{"code": "FileInputStream fis = new FileInputStream(sanitizePath(userProvidedPath));"}, {"code": "unzip(userProvidedZipFile, safeDestinationPath);"}], "verification_steps": ["Review the file processing code to ensure paths are sanitized.", "Check for the use of whitelisting for allowed file paths.", "Test the application with malicious zip files to verify it does not extract files outside the intended directory."], "common_mistakes": ["Failing to validate or sanitize user input for file paths.", "Using user-provided paths directly in file operations.", "Not implementing proper error handling for file operations."], "related_cwe": ["CWE-22", "CWE-23", "CWE-125"], "related_capec": ["CAPEC-137", "CAPEC-145"], "attack_flow": "An attacker crafts a zip file containing path traversal sequences (e.g., '../') and uploads it to the server. If the application extracts this zip file without validating the paths, it can lead to files being written or overwritten in unintended locations, potentially allowing the attacker to execute arbitrary code or access sensitive data."}
{"chapter_id": "V5", "chapter_name": "File Handling", "section_id": "V5.4", "section_name": "File Download", "req_id": "V5.4.1", "req_description": "Verify that the application validates or ignores user-submitted filenames, including in a JSON, JSONP, or URL parameter and specifies a filename in the Content-Disposition header field in the response.", "level": 2, "explanation": "This requirement emphasizes the importance of validating or sanitizing user-submitted filenames to prevent potential attacks such as directory traversal or file inclusion vulnerabilities. By ensuring that the filenames are either validated or ignored, and by properly setting the Content-Disposition header, the application can mitigate risks associated with arbitrary file downloads.", "threats_mitigated": ["Directory Traversal", "File Inclusion Attacks", "Cross-Site Scripting (XSS) via file names", "Denial of Service (DoS) through excessive file requests"], "insecure_examples": ["response.setHeader('Content-Disposition', 'attachment; filename=' + userInputFilename);", "let fileName = request.query.filename; response.download(fileName);"], "secure_examples": ["let safeFileName = sanitizeFilename(userInputFilename); response.setHeader('Content-Disposition', 'attachment; filename=' + safeFileName);", "let allowedFiles = ['file1.txt', 'file2.txt']; if (allowedFiles.includes(request.query.filename)) { response.download(request.query.filename); }"], "verification_steps": ["Check if the application validates user-submitted filenames.", "Ensure that the Content-Disposition header is set correctly.", "Test for directory traversal attempts in the filename.", "Verify that only allowed filenames are processed by the application."], "common_mistakes": ["Failing to validate or sanitize user input for filenames.", "Directly using user input in headers without any checks.", "Not restricting downloadable files to a predefined list."], "related_cwe": ["CWE-22", "CWE-73", "CWE-118"], "related_capec": ["CAPEC-30", "CAPEC-131", "CAPEC-134"], "attack_flow": "An attacker submits a crafted filename through a URL parameter or JSON payload. If the application does not validate the filename, it may process the request and return sensitive files or execute arbitrary code, leading to data exposure or server compromise."}
{"chapter_id": "V5", "chapter_name": "File Handling", "section_id": "V5.4", "section_name": "File Download", "req_id": "V5.4.2", "req_description": "Verify that file names served (e.g., in HTTP response header fields or email attachments) are encoded or sanitized (e.g., following RFC 6266) to preserve document structure and prevent injection attacks.", "level": "2", "explanation": "This requirement ensures that any file names sent to users are properly encoded or sanitized to avoid issues such as directory traversal attacks or injection of malicious content. By following standards like RFC 6266, applications can ensure that file names are presented correctly in different contexts, thereby maintaining security and usability.", "threats_mitigated": ["Directory Traversal", "HTTP Response Splitting", "Cross-Site Scripting (XSS) via file name injection", "Malicious file download"], "insecure_examples": ["Content-Disposition: attachment; filename=\"../../etc/passwd\"", "Content-Disposition: attachment; filename=\"<script>alert('XSS')</script>\""], "secure_examples": ["Content-Disposition: attachment; filename=\"safe_file_name.pdf\"", "Content-Disposition: attachment; filename=\"my_document.txt\""], "verification_steps": ["Check that the application sanitizes file names before including them in HTTP headers.", "Verify that the file names do not contain any characters that could lead to directory traversal.", "Ensure that the application follows RFC 6266 for encoding file names.", "Review the response headers to confirm proper encoding of file names."], "common_mistakes": ["Failing to sanitize user input for file names.", "Using raw file names in HTTP headers without encoding.", "Not considering special characters in file names that could lead to injection attacks."], "related_cwe": ["CWE-22", "CWE-73", "CWE-80"], "related_capec": ["CAPEC-137", "CAPEC-150"], "attack_flow": "An attacker could craft a malicious file name that includes directory traversal sequences or script tags. If the application does not sanitize or encode this file name, it could be included in the HTTP response header. When the user receives the file, the browser may interpret the malicious content, leading to unauthorized file access or execution of scripts, compromising the user's system or data."}
{"chapter_id": "V5", "chapter_name": "File Handling", "section_id": "V5.4", "section_name": "File Download", "req_id": "V5.4.3", "req_description": "Verify that files obtained from untrusted sources are scanned by antivirus scanners to prevent serving of known malicious content.", "level": 2, "explanation": "This requirement emphasizes the importance of scanning files that are downloaded from untrusted sources using antivirus software. The goal is to ensure that any potentially harmful files are identified and neutralized before they can be accessed or executed by users. This helps to protect both the application and its users from malware, ransomware, and other malicious software that can be embedded in files.", "threats_mitigated": ["Malware infection", "Ransomware attacks", "Data breaches", "Phishing attacks via malicious files"], "insecure_examples": [{"code": "file = request.files['uploaded_file']\nfile.save('/path/to/save/' + file.filename)", "description": "This code saves an uploaded file without any scanning, allowing potentially malicious files to be stored."}, {"code": "response = requests.get(untrusted_url)\nopen('downloaded_file', 'wb').write(response.content)", "description": "This code downloads a file from an untrusted URL and saves it without scanning."}], "secure_examples": [{"code": "file = request.files['uploaded_file']\nif antivirus_scan(file):\n    file.save('/path/to/save/' + file.filename)\nelse:\n    raise Exception('Malicious file detected')", "description": "This code checks the uploaded file with an antivirus scanner before saving it."}, {"code": "response = requests.get(untrusted_url)\nif antivirus_scan(response.content):\n    open('downloaded_file', 'wb').write(response.content)\nelse:\n    raise Exception('Malicious content detected')", "description": "This code scans the downloaded file content before saving it."}], "verification_steps": ["Ensure antivirus scanning is implemented for all files from untrusted sources.", "Verify that the antivirus solution is up-to-date and configured correctly.", "Check logs for any detected malicious files and ensure appropriate actions are taken.", "Review the handling of files post-scan to confirm that no unscanned files are processed."], "common_mistakes": ["Assuming that files from known sources are safe without scanning.", "Not updating antivirus definitions regularly.", "Failing to handle exceptions or alerts when a malicious file is detected.", "Neglecting to scan files that are processed in the background or via automated systems."], "related_cwe": ["CWE-20: Improper Input Validation", "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')", "CWE-125: Out-of-bounds Read"], "related_capec": ["CAPEC-118: Uploading Malicious Files", "CAPEC-154: Exploiting File Upload Mechanisms", "CAPEC-168: Malicious File Download"], "attack_flow": "An attacker uploads a malicious file to the application, which is then served to other users without being scanned. When a user downloads and executes the file, their system becomes infected with malware, leading to potential data theft, system compromise, or further attacks."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.1", "section_name": "Authentication Documentation", "req_id": "V6.1.1", "req_description": "Verify that application documentation defines how controls such as rate limiting, anti-automation, and adaptive response, are used to defend against attacks such as credential stuffing and password brute force. The documentation must make clear how these controls are configured and prevent malicious account lockout.", "level": "1", "explanation": "This requirement emphasizes the importance of having comprehensive documentation that outlines the security mechanisms in place to protect user accounts from automated attacks. It requires that developers and security teams provide clear guidelines on how rate limiting, anti-automation techniques, and adaptive responses are implemented to mitigate risks associated with credential stuffing and brute force attacks. Proper documentation ensures that these controls are understood and correctly configured, reducing the likelihood of account compromise.", "threats_mitigated": ["Credential Stuffing", "Password Brute Force Attacks", "Account Lockout Attacks"], "insecure_examples": [{"code_snippet": "// Insecure: No rate limiting or anti-automation controls documented\nfunction login(username, password) {\n  // Process login without any restrictions\n}"}], "secure_examples": [{"code_snippet": "// Secure: Rate limiting and anti-automation controls documented\nfunction login(username, password) {\n  if (isRateLimited(username)) {\n    throw new Error('Too many login attempts. Please try again later.');\n  }\n  // Process login with rate limiting in place\n}"}], "verification_steps": ["Check if the documentation includes details on rate limiting implementation.", "Verify that anti-automation measures are described in the documentation.", "Ensure that adaptive response strategies are clearly outlined.", "Confirm that the documentation addresses how to prevent malicious account lockout."], "common_mistakes": ["Failing to document security controls adequately.", "Not updating documentation when security measures change.", "Assuming that developers will know how to implement controls without guidance."], "related_cwe": ["CWE-307: Improper Restriction of Excessive Authentication Attempts", "CWE-307: Improper Restriction of Excessive Authentication Attempts"], "related_capec": ["CAPEC-137: Brute Force Attack", "CAPEC-153: Credential Stuffing"], "attack_flow": "An attacker may exploit the lack of documentation on security controls by launching a brute force attack, attempting multiple username and password combinations. If rate limiting and anti-automation measures are not properly configured or documented, the attacker can easily bypass defenses, leading to unauthorized access to user accounts."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.1", "section_name": "Authentication Documentation", "req_id": "V6.1.2", "req_description": "Verify that a list of context-specific words is documented in order to prevent their use in passwords. The list could include permutations of organization names, product names, system identifiers, project codenames, department or role names, and similar.", "level": "2", "explanation": "This requirement emphasizes the importance of creating a documented list of words that are specific to the organization and its context, which should not be used in passwords. The rationale is that using easily guessable or contextually relevant terms can significantly weaken password strength, making it easier for attackers to compromise accounts via brute force or social engineering tactics.", "threats_mitigated": ["Brute Force Attacks", "Password Guessing", "Credential Stuffing", "Social Engineering Attacks"], "insecure_examples": ["password = 'AcmeCorp2023'; // Uses company name in password", "password = 'ProjectX123'; // Uses project codename in password"], "secure_examples": ["password = '7hG!qL2@9z'; // Strong, random password not related to context", "password = 'y5&Xj8#kPq!4'; // Strong, unique password"], "verification_steps": ["Check if a documented list of context-specific words exists.", "Review the list for completeness and relevance to the organization.", "Ensure that the list is regularly updated and maintained.", "Verify that the password policy enforces the exclusion of these words."], "common_mistakes": ["Failing to create a context-specific word list.", "Using generic lists that do not reflect the organization's context.", "Not updating the list as organizational names or projects change.", "Allowing users to set passwords that include context-specific terms."], "related_cwe": ["CWE-521: Weak Password Requirements", "CWE-307: Improper Restriction of Excessive Authentication Attempts", "CWE-759: Use of a One-Way Hash without a Salt"], "related_capec": ["CAPEC-137: Password Guessing", "CAPEC-157: Brute Force Attack", "CAPEC-164: Credential Stuffing"], "attack_flow": "An attacker may leverage knowledge of the organization's context, such as its name, projects, or roles, to create a list of likely passwords. If users are allowed to create passwords that include these terms, the attacker can use automated tools to guess passwords effectively, leading to unauthorized access."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.1", "section_name": "Authentication Documentation", "req_id": "V6.1.3", "req_description": "Verify that, if the application includes multiple authentication pathways, these are all documented together with the security controls and authentication strength which must be consistently enforced across them.", "level": 2, "explanation": "This requirement emphasizes the importance of having a comprehensive documentation strategy for applications that implement multiple authentication mechanisms. It ensures that all pathways are documented with their respective security controls and the strength of authentication methods used. This documentation should be clear and accessible, allowing developers and security teams to maintain consistency and enforce security measures effectively across all authentication methods.", "threats_mitigated": ["Insecure Authentication Flows", "Credential Stuffing", "Account Takeover", "Bypassing Authentication Controls"], "insecure_examples": ["if (userInput == 'admin') { login(); } // No documentation on authentication pathways", "function authenticate(user) { if (user.isAuthenticated) { return true; } } // Missing security controls documentation"], "secure_examples": ["function authenticate(user) { // Documentation states this is a multi-factor authentication pathway; ensure MFA is enforced. }", "if (userInput == 'admin') { // Documented that admin access requires 2FA; enforce it here. }"], "verification_steps": ["Check if all authentication pathways are documented.", "Review the documentation for clarity on security controls for each pathway.", "Ensure that the strength of authentication methods is clearly defined.", "Verify that the documented controls are enforced in the application code."], "common_mistakes": ["Failing to document all authentication pathways.", "Inconsistent enforcement of security controls across different authentication methods.", "Neglecting to update documentation after changes to authentication mechanisms."], "related_cwe": ["CWE-287", "CWE-384", "CWE-20"], "related_capec": ["CAPEC-118", "CAPEC-114", "CAPEC-17"], "attack_flow": "An attacker may exploit inconsistencies in authentication pathways by identifying undocumented methods or weaknesses in the security controls. If certain pathways are not adequately protected or documented, the attacker can bypass security measures, leading to unauthorized access or account takeover."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.2", "section_name": "Password Security", "req_id": "V6.2.1", "req_description": "Verify that user set passwords are at least 8 characters in length although a minimum of 15 characters is strongly recommended.", "level": "1", "explanation": "This requirement emphasizes the importance of password length in enhancing security. Longer passwords are generally more resistant to brute-force attacks and can provide a higher level of entropy, making them harder to guess. While a minimum of 8 characters is acceptable, a length of 15 characters or more is strongly recommended to significantly increase the complexity and strength of the password.", "threats_mitigated": ["Brute Force Attacks", "Password Guessing", "Credential Stuffing"], "insecure_examples": ["user_password = '12345678'; // Too short and predictable", "user_password = 'password'; // Common password and too short"], "secure_examples": ["user_password = 'A$tr0ngP@ssw0rd123!'; // At least 15 characters with complexity", "user_password = 'C0mpl3x_P@ssword_2023!'; // At least 15 characters with complexity"], "verification_steps": ["Check if the password length is enforced in the application.", "Verify that the application rejects passwords shorter than 8 characters.", "Ensure that the application recommends or enforces a minimum of 15 characters.", "Review password storage mechanisms to ensure they are secure."], "common_mistakes": ["Allowing passwords shorter than 8 characters.", "Not enforcing complexity requirements (uppercase, lowercase, numbers, special characters).", "Using default or common passwords."], "related_cwe": ["CWE-521: Weak Password Requirements", "CWE-759: Use of a One-Way Hash without a Salt"], "related_capec": ["CAPEC-112: Brute Force Attack", "CAPEC-137: Password Guessing"], "attack_flow": "An attacker may attempt to guess user passwords by systematically trying combinations of characters. If the password length is insufficient, the attacker can use brute-force methods to quickly find valid passwords. Longer passwords increase the number of possible combinations exponentially, making it impractical for attackers to succeed in a reasonable timeframe."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.2", "section_name": "Password Security", "req_id": "V6.2.2", "req_description": "Verify that users can change their password.", "level": "1", "explanation": "This requirement ensures that users have the ability to update their passwords securely. A secure password change mechanism prevents unauthorized access to user accounts and enhances overall account security.", "threats_mitigated": ["Account takeover", "Unauthorized access", "Credential stuffing"], "insecure_examples": ["if (userInput.password == currentPassword) { user.password = newPassword; }", "changePassword(userId, newPassword) { // No verification of user identity }"], "secure_examples": ["if (verifyUserIdentity(userId, currentPassword)) { user.password = hash(newPassword); }", "changePassword(userId, newPassword) { if (verifyUserIdentity(userId)) { user.password = hash(newPassword); } }"], "verification_steps": ["Check that the password change function requires the current password for verification.", "Ensure that the new password is hashed before being stored.", "Verify that the password change process is protected by CSRF tokens.", "Confirm that the user receives a notification upon successful password change."], "common_mistakes": ["Not requiring the current password for password changes.", "Failing to hash the new password before storage.", "Not implementing rate limiting on password change requests."], "related_cwe": ["CWE-640: Weak Password Recovery Mechanism", "CWE-307: Improper Restriction of Excessive Authentication Attempts"], "related_capec": ["CAPEC-118: Password Guessing", "CAPEC-137: Credential Stuffing"], "attack_flow": "An attacker may exploit a flaw in the password change functionality by bypassing the current password verification step, allowing them to change the password of a target account and gain unauthorized access."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.2", "section_name": "Password Security", "req_id": "V6.2.3", "req_description": "Verify that password change functionality requires the user's current and new password.", "level": "1", "explanation": "This requirement ensures that when a user attempts to change their password, they must provide their current password along with the new password. This prevents unauthorized users from changing a password without knowing the existing one, thereby enhancing the security of user accounts.", "threats_mitigated": ["Unauthorized password changes", "Account takeover", "Session hijacking"], "insecure_examples": ["if (newPassword) { changePassword(newPassword); }", "changePassword(newPassword); // No current password check"], "secure_examples": ["if (currentPassword && newPassword) { changePassword(currentPassword, newPassword); }", "if (isValidCurrentPassword(currentPassword)) { changePassword(newPassword); }"], "verification_steps": ["Check that the password change function requires both current and new passwords.", "Verify that the current password is validated against the stored password.", "Ensure that error messages do not reveal whether the current password was correct."], "common_mistakes": ["Allowing password changes without verifying the current password.", "Providing vague error messages that do not help users understand what went wrong.", "Not implementing rate limiting on password change attempts."], "related_cwe": ["CWE-640", "CWE-287"], "related_capec": ["CAPEC-155", "CAPEC-156"], "attack_flow": "An attacker who has gained access to a user's account may attempt to change the password without knowing the current password. If the application does not require the current password, the attacker can easily change the password and lock the legitimate user out of their account."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.2", "section_name": "Password Security", "req_id": "V6.2.4", "req_description": "Verify that passwords submitted during account registration or password change are checked against an available set of, at least, the top 3000 passwords which match the application's password policy, e.g. minimum length.", "level": "1", "explanation": "This requirement ensures that users do not choose easily guessable passwords that are commonly used and therefore vulnerable to attacks such as brute force or dictionary attacks. By checking against a list of commonly used passwords, the application can prevent users from selecting weak passwords that may compromise their accounts.", "threats_mitigated": ["Brute Force Attacks", "Dictionary Attacks", "Credential Stuffing", "Account Takeover"], "insecure_examples": ["if (password in common_passwords) { reject(); }", "if (isWeakPassword(password)) { return false; }"], "secure_examples": ["if (password in top_3000_passwords) { reject(); }", "if (!isValidPassword(password)) { return false; }"], "verification_steps": ["Check if the application has a list of the top 3000 passwords.", "Ensure that password submission checks against this list during registration and password changes.", "Review the password policy to confirm minimum length and complexity requirements.", "Test with known weak passwords to verify they are rejected."], "common_mistakes": ["Failing to update the list of common passwords regularly.", "Not enforcing password complexity rules alongside common password checks.", "Assuming that checking against a static list is sufficient without additional password strength validation."], "related_cwe": ["CWE-521: Weak Password Requirements", "CWE-307: Improper Restriction of Excessive Authentication Attempts"], "related_capec": ["CAPEC-137: Password Guessing", "CAPEC-145: Credential Stuffing"], "attack_flow": "An attacker can exploit this requirement by attempting to register or change a password to a commonly used password. If the application does not check against the list of top 3000 passwords, the attacker may gain unauthorized access to user accounts using these weak passwords."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.2", "section_name": "Password Security", "req_id": "V6.2.5", "req_description": "Verify that passwords of any composition can be used, without rules limiting the type of characters permitted. There must be no requirement for a minimum number of upper or lower case characters, numbers, or special characters.", "level": "1", "explanation": "This requirement emphasizes the importance of allowing users to create passwords without arbitrary restrictions on character types. It aims to enhance user experience and security by permitting a broader range of password compositions, which can lead to stronger passwords that are harder to guess or crack.", "threats_mitigated": ["Brute force attacks", "Dictionary attacks", "Credential stuffing"], "insecure_examples": ["password = 'abc123'; // Fails due to lack of special characters and upper case letters", "password = 'Password1!'; // Requires specific character types, limiting user choice"], "secure_examples": ["password = 'MyCustomPassword123'; // Accepts a password with no restrictions", "password = 'randomString'; // Allows any character composition"], "verification_steps": ["Check the password policy configuration in the application.", "Review user registration and password change forms for character restrictions.", "Test password creation with various compositions to ensure acceptance."], "common_mistakes": ["Implementing overly complex password policies that confuse users.", "Assuming that complexity guarantees security without considering usability.", "Forgetting to allow users to choose passwords freely, leading to frustration."], "related_cwe": ["CWE-521: Weak Password Requirements", "CWE-640: Weak Password Recovery Mechanism for Forgotten Password"], "related_capec": ["CAPEC-137: Password Guessing", "CAPEC-138: Credential Stuffing"], "attack_flow": "An attacker may exploit this requirement by attempting to create passwords that are easy to remember but complex enough to bypass traditional security measures. If the application allows any composition without restrictions, users may choose weak passwords that can be easily guessed or cracked through brute force methods."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.2", "section_name": "Password Security", "req_id": "V6.2.6", "req_description": "Verify that password input fields use type=password to mask the entry. Applications may allow the user to temporarily view the entire masked password, or the last typed character of the password.", "level": "1", "explanation": "This requirement ensures that password fields are appropriately configured to prevent shoulder surfing and unauthorized viewing of sensitive information. By using the type='password' attribute in HTML forms, the characters entered by the user are obscured. Additionally, providing an option to reveal the password temporarily can enhance user experience while still maintaining security.", "threats_mitigated": ["Shoulder surfing", "Unauthorized access due to visible passwords", "User frustration leading to poor password practices"], "insecure_examples": ["<input type='text' name='password' />", "<input type='password' name='password' style='display: inline;' />"], "secure_examples": ["<input type='password' name='password' />", "<input type='password' name='password' onfocus='this.type=\"text\"' onblur='this.type=\"password\"' />"], "verification_steps": ["Check that all password input fields use type='password'.", "Verify that the application allows users to toggle visibility of the password securely.", "Ensure that any toggle feature does not expose the password to unauthorized users."], "common_mistakes": ["Using type='text' for password fields.", "Failing to provide a mechanism to securely view the password when needed.", "Not considering the user experience when implementing password visibility features."], "related_cwe": ["CWE-200", "CWE-117", "CWE-1021"], "related_capec": ["CAPEC-138", "CAPEC-145"], "attack_flow": "An attacker can observe a user entering their password in a public space if the password field is not masked. This can lead to credential theft. If the application allows viewing of the password without proper security measures, an attacker can exploit this feature to gain unauthorized access."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.2", "section_name": "Password Security", "req_id": "V6.2.7", "req_description": "Verify that 'paste' functionality, browser password helpers, and external password managers are permitted.", "level": "1", "explanation": "This requirement ensures that users can easily input their passwords without restrictions that may hinder usability. Allowing paste functionality and integration with password managers improves user experience and encourages the use of strong, complex passwords.", "threats_mitigated": ["Credential stuffing attacks", "Weak password usage", "User frustration leading to insecure password practices"], "insecure_examples": ["document.getElementById('password').onpaste = function(e) { e.preventDefault(); };", "<input type='password' onpaste='return false;'>"], "secure_examples": ["<input type='password' id='password' autocomplete='new-password' />", "<input type='password' id='password' />"], "verification_steps": ["Check if the input field for passwords allows paste functionality.", "Verify that browser password helpers can autofill the password field.", "Test compatibility with popular external password managers."], "common_mistakes": ["Disabling paste functionality in password fields.", "Implementing overly restrictive input validation that rejects valid input methods.", "Not considering user experience when enforcing password policies."], "related_cwe": ["CWE-259: Use of Hard-coded Password", "CWE-20: Improper Input Validation"], "related_capec": ["CAPEC-137: Credential Stuffing", "CAPEC-153: Password Guessing"], "attack_flow": "An attacker may exploit a restriction on paste functionality by attempting to convince users to enter weak passwords manually. If users are frustrated by the inability to use password managers, they may resort to simpler passwords, making them more susceptible to credential stuffing and guessing attacks."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.2", "section_name": "Password Security", "req_id": "V6.2.8", "req_description": "Verify that the application verifies the user's password exactly as received from the user, without any modifications such as truncation or case transformation.", "level": 1, "explanation": "This requirement ensures that the application performs password verification in a manner that respects the exact input provided by the user. Any alterations to the password, such as changing the case of characters or truncating the length, can lead to unauthorized access or denial of service for legitimate users. Proper verification means that the application must compare the stored password hash against the hash of the input password without any preprocessing.", "threats_mitigated": ["Unauthorized access due to case-insensitive password checks", "Account lockout due to truncation errors", "Bypassing password checks through manipulation of input"], "insecure_examples": ["if (userInput.Password.ToLower() == storedPasswordHash.ToLower()) { /* allow access */ }", "if (userInput.Password.Substring(0, 8) == storedPasswordHash) { /* allow access */ }"], "secure_examples": ["if (VerifyPassword(userInput.Password, storedPasswordHash)) { /* allow access */ }", "if (userInput.Password == storedPasswordHash) { /* allow access */ }"], "verification_steps": ["Check that the password comparison is case-sensitive.", "Ensure no truncation or modification occurs in the password input.", "Review the password verification function for proper implementation.", "Test with various password cases to confirm behavior."], "common_mistakes": ["Implementing case-insensitive password checks.", "Truncating passwords to a fixed length before comparison.", "Using insecure string comparison methods that may lead to timing attacks."], "related_cwe": ["CWE-259: Use of Hard-coded Password", "CWE-760: Use of a One-Way Hash without a Salt"], "related_capec": ["CAPEC-137: Password Guessing Attack", "CAPEC-151: Credential Stuffing"], "attack_flow": "An attacker may exploit this requirement by providing a password with altered case or length, which the application incorrectly verifies as valid. For instance, if the application performs a case-insensitive check, an attacker could use a known password but change the case to gain unauthorized access. Similarly, if the application truncates the password, an attacker could guess the truncated version and bypass security."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.2", "section_name": "Password Security", "req_id": "V6.2.9", "req_description": "Verify that passwords of at least 64 characters are permitted.", "level": 2, "explanation": "This requirement emphasizes the importance of allowing long passwords, specifically those that are at least 64 characters in length. Longer passwords are generally more secure because they increase the number of possible combinations, making them harder to guess or crack through brute force attacks. This requirement encourages the implementation of password policies that do not impose arbitrary length restrictions that could weaken password strength.", "threats_mitigated": ["Brute Force Attacks", "Credential Stuffing", "Password Guessing"], "insecure_examples": [{"code": "password = getUserInput();\nif (strlen(password) < 8) {\n    throw new Exception('Password too short');\n}"}, {"code": "if (password.length < 20) {\n    throw new Error('Password must be at least 20 characters long');\n}"}], "secure_examples": [{"code": "password = getUserInput();\nif (strlen(password) < 64) {\n    throw new Exception('Password must be at least 64 characters long');\n}"}, {"code": "if (password.length < 64) {\n    throw new Error('Password must be at least 64 characters long');\n}"}], "verification_steps": ["Check the password policy documentation for minimum length requirements.", "Review code to ensure there are no hardcoded minimum password lengths less than 64 characters.", "Test the application to confirm that it accepts passwords of 64 characters or more."], "common_mistakes": ["Setting a minimum password length that is too short.", "Failing to validate password length on the client-side and server-side.", "Not allowing special characters, numbers, or mixed case in longer passwords."], "related_cwe": ["CWE-521: Weak Password Requirements", "CWE-307: Improper Restriction of Excessive Authentication Attempts"], "related_capec": ["CAPEC-137: Brute Force Attack", "CAPEC-151: Credential Stuffing Attack"], "attack_flow": "An attacker may exploit weak password policies by attempting to gain unauthorized access to user accounts through brute force attacks. If the application does not allow long passwords, it may inadvertently encourage users to create shorter, weaker passwords that are easier to guess. By allowing passwords of at least 64 characters, the application increases the complexity and time required for an attacker to successfully guess or crack a password."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.2", "section_name": "Password Security", "req_id": "V6.2.10", "req_description": "Verify that a user's password stays valid until it is discovered to be compromised or the user rotates it. The application must not require periodic credential rotation.", "level": "2", "explanation": "This requirement emphasizes that passwords should remain valid indefinitely unless there is evidence of compromise or the user decides to change it. Periodic password changes can lead to weaker passwords, as users may resort to predictable patterns or simpler passwords to remember them.", "threats_mitigated": ["Password guessing attacks", "Credential stuffing", "Account takeover"], "insecure_examples": ["if (user.passwordExpired) { throw new Error('Password must be changed.'); }", "user.password = generateNewPassword(); // Forces password change every 90 days"], "secure_examples": ["if (user.passwordCompromised) { promptUserToChangePassword(); }", "user.password = currentPassword; // No forced periodic change"], "verification_steps": ["Check if the application allows users to keep their passwords indefinitely.", "Verify that there is no enforced periodic password change policy.", "Ensure that users can change their passwords voluntarily when needed."], "common_mistakes": ["Implementing a fixed schedule for password changes without considering user behavior.", "Not providing users with an option to change their password if they suspect it has been compromised."], "related_cwe": ["CWE-521: Weak Password Requirements", "CWE-640: Weak Password Recovery Mechanism"], "related_capec": ["CAPEC-117: Password Guessing", "CAPEC-137: Credential Stuffing"], "attack_flow": "An attacker may exploit the requirement violation by leveraging a user's compromised password. If periodic password changes are enforced, users may choose weak passwords or reuse passwords across different sites. This makes it easier for attackers to gain unauthorized access, especially if they have access to password databases from other breaches."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.2", "section_name": "Password Security", "req_id": "V6.2.11", "req_description": "Verify that the documented list of context specific words is used to prevent easy to guess passwords being created.", "level": 2, "explanation": "This requirement emphasizes the importance of using a list of context-specific words to enhance password complexity. By ensuring that users do not choose easily guessable passwords, such as common words or phrases related to the application, the security of user accounts is significantly improved. This can involve maintaining a blacklist of words that should not be used as passwords, which is tailored to the specific context of the application, such as company names, product names, or common terms related to the domain.", "threats_mitigated": ["Brute force attacks", "Dictionary attacks", "Credential stuffing", "Social engineering attacks"], "insecure_examples": ["password123", "letmein", "companyname2023"], "secure_examples": ["G3n3r@t3dP@ssw0rd!", "C0mpl3xP@ssw0rd#2023"], "verification_steps": ["Check the implementation of the password policy.", "Review the list of context-specific words used for password restrictions.", "Test user registration and password change functionality with common words.", "Ensure that error messages do not disclose whether a password was too simple."], "common_mistakes": ["Failing to update the list of context-specific words regularly.", "Allowing users to create passwords that are too similar to common terms.", "Not enforcing the password policy during account creation and updates."], "related_cwe": ["CWE-521: Weak Password Requirements", "CWE-307: Improper Restriction of Excessive Authentication Attempts"], "related_capec": ["CAPEC-137: Password Guessing", "CAPEC-142: Brute Force Attack"], "attack_flow": "An attacker may exploit this requirement by attempting to create accounts or reset passwords using easily guessable terms that are context-specific. If the application does not enforce the use of a robust password policy, the attacker can gain unauthorized access to user accounts through brute force or dictionary attacks, leveraging the predictable nature of the passwords."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.2", "section_name": "Password Security", "req_id": "V6.2.12", "req_description": "Verify that passwords submitted during account registration or password changes are checked against a set of breached passwords.", "level": "2", "explanation": "This requirement mandates that any password chosen by the user during account creation or when changing their password must be validated against a list of known compromised passwords. This helps to prevent users from inadvertently selecting passwords that have been exposed in data breaches, thereby reducing the risk of unauthorized access to their accounts.", "threats_mitigated": ["Account takeover", "Credential stuffing attacks", "Unauthorized access due to weak passwords"], "insecure_examples": ["if (password == '123456') { /* allow registration */ }", "registerUser(username, password) { /* no breach check */ }"], "secure_examples": ["if (!isPasswordBreached(password)) { /* allow registration */ }", "registerUser(username, password) { if (isPasswordBreached(password)) throw new Error('Password is compromised.'); }"], "verification_steps": ["Check if the application checks passwords against a breached password list.", "Ensure that the breached password list is regularly updated.", "Review the mechanism used to check for breaches (e.g., API calls to a breach database).", "Verify that users receive appropriate feedback when they attempt to use a compromised password."], "common_mistakes": ["Failing to check against a comprehensive and up-to-date list of breached passwords.", "Not providing clear feedback to users when a compromised password is detected.", "Assuming that a password is strong enough without checking its history."], "related_cwe": ["CWE-307: Improper Restriction of Excessive Authentication Attempts", "CWE-521: Weak Password Requirements", "CWE-640: Weak Password Recovery Mechanism for Forgotten Password"], "related_capec": ["CAPEC-114: Credential Stuffing", "CAPEC-137: Password Guessing", "CAPEC-146: Password Cracking"], "attack_flow": "An attacker may exploit this requirement by attempting to register or change a password that has previously been exposed in a data breach. If the application does not validate the password against a list of compromised passwords, the attacker can gain unauthorized access to the account, especially if the user has reused passwords across different sites."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.3", "section_name": "General Authentication Security", "req_id": "V6.3.1", "req_description": "Verify that controls to prevent attacks such as credential stuffing and password brute force are implemented according to the application's security documentation.", "level": "1", "explanation": "This requirement emphasizes the importance of implementing robust security measures to protect user credentials from common attack vectors like credential stuffing and brute force attacks. Credential stuffing occurs when attackers use stolen username/password pairs to gain unauthorized access to accounts. Brute force attacks involve systematically trying every possible combination of passwords until the correct one is found. Proper controls include rate limiting, account lockout mechanisms, and the use of CAPTCHA to mitigate these threats.", "threats_mitigated": ["Credential Stuffing", "Password Brute Force Attacks"], "insecure_examples": ["if (attempts > 5) { loginUser(username, password); } // No lockout or rate limiting", "password = getUserPassword(username); if (password == inputPassword) { grantAccess(); } // No checks for failed attempts"], "secure_examples": ["if (attempts > 5) { lockAccount(username); } else { loginUser(username, password); } // Implements account lockout", "if (isValidPassword(username, inputPassword)) { grantAccess(); } else { incrementFailedAttempts(username); } // Validates attempts"], "verification_steps": ["Check for implementation of account lockout after a defined number of failed attempts.", "Verify that rate limiting is applied to authentication endpoints.", "Ensure CAPTCHA is implemented after several failed login attempts.", "Review security documentation for compliance with authentication controls."], "common_mistakes": ["Failing to implement account lockout mechanisms.", "Not enforcing rate limiting on login attempts.", "Ignoring the need for CAPTCHA or similar controls.", "Using weak password policies that allow easily guessable passwords."], "related_cwe": ["CWE-307", "CWE-521", "CWE-307"], "related_capec": ["CAPEC-137", "CAPEC-153"], "attack_flow": "An attacker collects a list of usernames and corresponding passwords from a data breach. They then use automated tools to attempt to log in to various accounts on the application. Without proper rate limiting or account lockout, the attacker can try numerous combinations quickly, eventually gaining unauthorized access to user accounts."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.3", "section_name": "General Authentication Security", "req_id": "V6.3.2", "req_description": "Verify that default user accounts (e.g., 'root', 'admin', or 'sa') are not present in the application or are disabled.", "level": 1, "explanation": "This requirement ensures that default accounts, which often come with known credentials, are either removed or disabled to prevent unauthorized access. Default accounts are common targets for attackers because they are widely known and can be easily exploited if left active.", "threats_mitigated": ["Unauthorized access", "Account takeover", "Brute force attacks"], "insecure_examples": ["User.create(username='admin', password='admin123'); // Default admin account created", "User.create(username='root', password='root'); // Default root account created"], "secure_examples": ["User.create(username='customAdmin', password='securePassword123'); // Custom admin account created with secure password", "User.create(username='user1', password='strongPassword!'); // Custom user account created"], "verification_steps": ["Review the user account list to identify any default accounts.", "Check the application configuration for any references to default accounts.", "Verify that any default accounts are either removed or disabled.", "Ensure that no default passwords are being used."], "common_mistakes": ["Failing to change default passwords after installation.", "Leaving default accounts enabled without any restrictions.", "Assuming that default accounts are secure if they are not used frequently."], "related_cwe": ["CWE-256: Unencrypted Password Storage", "CWE-307: Improper Restriction of Excessive Authentication Attempts", "CWE-640: Weak Password Recovery Mechanism"], "related_capec": ["CAPEC-137: Default Credentials Attack", "CAPEC-153: Credential Stuffing", "CAPEC-164: Brute Force Attack"], "attack_flow": "An attacker identifies the presence of default accounts, such as 'admin' or 'root', and attempts to access the application using known default credentials. If the accounts are active and the default passwords have not been changed, the attacker can gain unauthorized access to the application, leading to potential data breaches or system compromise."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.3", "section_name": "General Authentication Security", "req_id": "V6.3.3", "req_description": "Verify that either a multi-factor authentication mechanism or a combination of single-factor authentication mechanisms, must be used in order to access the application. For L3, one of the factors must be a hardware-based authentication mechanism which provides compromise and impersonation resistance against phishing attacks while verifying the intent to authenticate by requiring a user-initiated action (such as a button press on a FIDO hardware key or a mobile phone). Relaxing any of the considerations in this requirement requires a fully documented rationale and a comprehensive set of mitigating controls.", "level": 2, "explanation": "This requirement emphasizes the importance of implementing strong authentication mechanisms to protect user accounts from unauthorized access. Multi-factor authentication (MFA) adds an additional layer of security beyond just a username and password, making it significantly harder for attackers to gain access. The requirement specifies that for Level 3, a hardware-based factor is necessary, which is more secure against phishing and other attacks that target traditional authentication methods.", "threats_mitigated": ["Phishing attacks", "Credential stuffing", "Account takeover", "Man-in-the-middle attacks"], "insecure_examples": ["if (userInputPassword == storedPassword) { grantAccess(); }", "if (username && password) { grantAccess(); }"], "secure_examples": ["if (userInputPassword == storedPassword && verifyMFA(userInputMFA)) { grantAccess(); }", "if (username && password && verifyHardwareKey(userInputKey)) { grantAccess(); }"], "verification_steps": ["Check if MFA is implemented for all user logins.", "Verify that at least one factor is hardware-based for Level 3 applications.", "Review documentation for any exceptions to the MFA requirement.", "Test the MFA mechanism to ensure it is functioning correctly."], "common_mistakes": ["Implementing only single-factor authentication.", "Failing to use hardware-based factors where required.", "Not providing clear user instructions for MFA setup.", "Neglecting to document exceptions to the MFA requirement."], "related_cwe": ["CWE-287", "CWE-521", "CWE-798"], "related_capec": ["CAPEC-137", "CAPEC-151", "CAPEC-172"], "attack_flow": "An attacker may attempt to gain access to an account by stealing the user's password through phishing. If the application only uses single-factor authentication, the attacker can log in successfully. However, if MFA is implemented correctly, the attacker would also need to bypass the additional authentication factor, which may involve physical access to a hardware token or a secondary device, making it significantly more difficult to compromise the account."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.3", "section_name": "General Authentication Security", "req_id": "V6.3.4", "req_description": "Verify that, if the application includes multiple authentication pathways, there are no undocumented pathways and that security controls and authentication strength are enforced consistently.", "level": 2, "explanation": "This requirement emphasizes the importance of having a well-documented and consistent authentication mechanism across all pathways in an application. If multiple methods of authentication exist (e.g., username/password, social login, token-based), each must be equally secure and documented to prevent unauthorized access through weaker pathways. It ensures that all pathways are known and controlled, reducing the risk of exploitation.", "threats_mitigated": ["Unauthorized access", "Credential stuffing", "Account takeover", "Bypassing authentication mechanisms"], "insecure_examples": [{"code": "if (user.isAuthenticated() || user.hasSocialLogin()) { return accessGranted; }"}, {"code": "public void authenticate(String method) { if (method.equals(\"password\")) { /* password logic */ } }"}], "secure_examples": [{"code": "if (user.isAuthenticated() && user.isUsingStrongAuth()) { return accessGranted; }"}, {"code": "public void authenticate(String method) { if (isValidMethod(method)) { /* secure authentication logic */ } }"}], "verification_steps": ["Review the authentication pathways implemented in the application.", "Ensure all pathways are documented and accessible.", "Check that security controls are consistently applied across all pathways.", "Verify that authentication strength is uniform and meets security standards.", "Conduct a security review to identify any undocumented pathways."], "common_mistakes": ["Failing to document all authentication pathways.", "Implementing weaker authentication methods without oversight.", "Neglecting to enforce consistent security controls across different methods.", "Assuming that all pathways are secure without proper testing."], "related_cwe": ["CWE-287", "CWE-384", "CWE-306"], "related_capec": ["CAPEC-118", "CAPEC-153", "CAPEC-164"], "attack_flow": "An attacker may discover an undocumented authentication pathway that has weaker security controls. By exploiting this pathway, they can gain unauthorized access to the application, potentially leading to data breaches or account takeovers. If pathways are not consistently enforced, the attacker can bypass stronger authentication methods and exploit the weaker ones."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.3", "section_name": "General Authentication Security", "req_id": "V6.3.5", "req_description": "Verify that users are notified of suspicious authentication attempts (successful or unsuccessful). This may include authentication attempts from an unusual location or client, partially successful authentication (only one of multiple factors), an authentication attempt after a long period of inactivity or a successful authentication after several unsuccessful attempts.", "level": "3", "explanation": "This requirement emphasizes the importance of user awareness regarding authentication activities that may indicate unauthorized access attempts. By notifying users of suspicious activity, organizations can empower them to take action, such as changing passwords or reporting incidents, thereby enhancing overall security.", "threats_mitigated": ["Account takeover", "Credential stuffing", "Brute force attacks", "Session hijacking"], "insecure_examples": ["if (loginAttemptSuccessful) { /* No notification sent */ }", "if (failedAttempts > 3) { /* No alert to user */ }"], "secure_examples": ["if (loginAttemptSuccessful) { notifyUser('Suspicious login from unusual location.'); }", "if (failedAttempts > 3) { notifyUser('Multiple unsuccessful login attempts detected.'); }"], "verification_steps": ["Check if users receive notifications for successful logins from unusual locations.", "Verify that users are alerted for unsuccessful login attempts after a certain threshold.", "Ensure notifications include relevant details (e.g., time, location, device).", "Review logs to confirm that notifications are being sent as expected."], "common_mistakes": ["Failing to implement user notifications for suspicious login attempts.", "Not providing enough detail in notifications for users to assess the situation.", "Ignoring the need for notifications after a long period of inactivity."], "related_cwe": ["CWE-287", "CWE-306", "CWE-384"], "related_capec": ["CAPEC-137", "CAPEC-147"], "attack_flow": "An attacker attempts to log in to a user's account from an unusual location. If the application does not notify the user of this attempt, the attacker may succeed in gaining access. The user, unaware of the attempted breach, may not take necessary actions such as changing their password, leading to unauthorized access and potential data compromise."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.3", "section_name": "General Authentication Security", "req_id": "V6.3.6", "req_description": "Verify that email is not used as either a single-factor or multi-factor authentication mechanism.", "level": "3", "explanation": "This requirement emphasizes the importance of not relying solely on email for authentication purposes. Email accounts can be compromised through various means, such as phishing attacks, leading to unauthorized access. By ensuring that email is not used as a primary or secondary factor in authentication, applications can enhance their security posture and reduce the risk of account takeovers.", "threats_mitigated": ["Account takeover", "Phishing attacks", "Credential stuffing", "Social engineering attacks"], "insecure_examples": [{"code": "if (userInput.email === storedEmail) { authenticateUser(); }"}, {"code": "if (userInput.email === storedEmail && sendVerificationEmail(userInput.email)) { grantAccess(); }"}], "secure_examples": [{"code": "if (verifyUserCredentials(userInput.username, userInput.password)) { grantAccess(); }"}, {"code": "if (userInput.phoneNumber && sendVerificationSMS(userInput.phoneNumber)) { grantAccess(); }"}], "verification_steps": ["Review authentication mechanisms used in the application.", "Check if email is used as a single-factor authentication method.", "Ensure that email is not used in multi-factor authentication without additional secure factors.", "Test the application to confirm that email cannot be exploited for authentication."], "common_mistakes": ["Using email as the only factor for user authentication.", "Implementing email-based verification without additional security measures.", "Failing to educate users about the risks of email-based authentication."], "related_cwe": ["CWE-287", "CWE-521", "CWE-295"], "related_capec": ["CAPEC-1", "CAPEC-138", "CAPEC-154"], "attack_flow": "An attacker may use phishing techniques to gain access to a user's email account. Once they have control over the email, they can reset passwords or bypass authentication mechanisms that rely on email, leading to unauthorized access to sensitive information and user accounts."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.3", "section_name": "General Authentication Security", "req_id": "V6.3.7", "req_description": "Verify that users are notified after updates to authentication details, such as credential resets or modification of the username or email address.", "level": "3", "explanation": "This requirement ensures that users are informed whenever there are changes made to their authentication credentials. This notification serves as a security measure to alert users of unauthorized changes and allows them to take action if they did not initiate the change.", "threats_mitigated": ["Account takeover", "Phishing attacks", "Unauthorized access"], "insecure_examples": ["User updates their email address, but no notification is sent, leaving them unaware of potential unauthorized changes.", "A password reset is performed without notifying the user, allowing an attacker to gain access without the user's knowledge."], "secure_examples": ["After a user updates their email address, an email notification is sent to the old email address confirming the change.", "Upon a password reset, the user receives an email alerting them of the change and providing steps to secure their account if they did not initiate the reset."], "verification_steps": ["Check that an email notification is sent after a user changes their password.", "Verify that users receive confirmation when their username or email address is modified.", "Ensure that notifications are sent to the old credentials to alert users of changes."], "common_mistakes": ["Failing to send notifications for all types of credential changes.", "Not verifying the user's identity before allowing changes to authentication details.", "Using generic notifications that do not specify the type of change made."], "related_cwe": ["CWE-384: Session Fixation", "CWE-287: Improper Authentication", "CWE-346: Origin Validation Error"], "related_capec": ["CAPEC-137: Account Takeover", "CAPEC-159: Credential Stuffing", "CAPEC-158: Phishing"], "attack_flow": "An attacker gains access to a user's account and changes the authentication details (e.g., email or password) without the user's knowledge. If the user is not notified of these changes, they remain unaware and cannot take corrective action, leading to potential account takeover and unauthorized access to sensitive information."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.3", "section_name": "General Authentication Security", "req_id": "V6.3.8", "req_description": "Verify that valid users cannot be deduced from failed authentication challenges, such as by basing on error messages, HTTP response codes, or different response times. Registration and forgot password functionality must also have this protection.", "level": "3", "explanation": "This requirement ensures that an attacker cannot infer valid usernames or accounts based on the system's response to failed login attempts. If error messages or response times vary depending on the validity of the credentials, attackers can use this information to enumerate valid accounts. Therefore, uniform error messages and consistent response times should be implemented to obscure this information.", "threats_mitigated": ["Account enumeration", "Brute force attacks", "Information disclosure"], "insecure_examples": [{"code": "if (usernameExists(username)) {\n    return 'Invalid password';\n} else {\n    return 'User not found';\n}"}, {"code": "if (passwordIncorrect) {\n    response.setStatus(401);\n    return 'Incorrect password';\n} else {\n    response.setStatus(404);\n    return 'User not found';\n}"}], "secure_examples": [{"code": "return 'Invalid login credentials';"}, {"code": "response.setStatus(401);\nreturn 'Invalid login credentials';"}], "verification_steps": ["Review error messages returned during failed authentication attempts.", "Check for consistency in HTTP response codes for all failed login attempts.", "Analyze response times for failed authentication attempts to ensure they are uniform.", "Verify that registration and password recovery functionalities do not disclose information about valid usernames."], "common_mistakes": ["Providing specific error messages that indicate whether the username or password was incorrect.", "Using different HTTP status codes for different types of authentication failures.", "Failing to implement rate limiting on failed login attempts, allowing for easier enumeration."], "related_cwe": ["CWE-203", "CWE-209", "CWE-290"], "related_capec": ["CAPEC-137", "CAPEC-147", "CAPEC-153"], "attack_flow": "An attacker attempts to log in with various usernames and observes the application's responses. If the application returns different error messages or response times based on whether the username exists or not, the attacker can compile a list of valid usernames, which may then be targeted for further attacks, such as password guessing or brute force attacks."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.4", "section_name": "Authentication Factor Lifecycle and Recovery", "req_id": "V6.4.1", "req_description": "Verify that system generated initial passwords or activation codes are securely randomly generated, follow the existing password policy, and expire after a short period of time or after they are initially used. These initial secrets must not be permitted to become the long term password.", "level": "1", "explanation": "This requirement ensures that any automatically generated passwords or activation codes are created using secure random algorithms, adhere to the organization's password policy, and are designed to expire quickly. This minimizes the risk of these temporary credentials being misused for unauthorized access.", "threats_mitigated": ["Unauthorized access due to predictable passwords", "Password reuse vulnerabilities", "Credential stuffing attacks"], "insecure_examples": ["String initialPassword = '123456'; // Predictable and insecure initial password", "String activationCode = 'abcdef'; // Easily guessable activation code"], "secure_examples": ["String initialPassword = generateSecureRandomPassword(); // Securely generated initial password", "String activationCode = generateSecureRandomCode(); // Securely generated activation code"], "verification_steps": ["Check that initial passwords are generated using a secure random function.", "Verify that the generated passwords comply with the organization's password policy.", "Ensure that initial passwords expire after a set period or after first use.", "Confirm that initial passwords are not reused as long-term credentials."], "common_mistakes": ["Using predictable patterns for generating initial passwords.", "Failing to enforce password expiration for initial credentials.", "Not adhering to the defined password policy for initial passwords."], "related_cwe": ["CWE-521: Weak Password Requirements", "CWE-759: Use of a One-Way Hash without a Salt"], "related_capec": ["CAPEC-137: Password Guessing", "CAPEC-142: Credential Stuffing"], "attack_flow": "An attacker may exploit weak initial passwords by guessing or using automated tools to generate potential passwords. If these passwords are predictable or not securely generated, the attacker can gain unauthorized access to user accounts, especially if the passwords do not expire or are reused."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.4", "section_name": "Authentication Factor Lifecycle and Recovery", "req_id": "V6.4.2", "req_description": "Verify that password hints or knowledge-based authentication (so-called 'secret questions') are not present.", "level": "1", "explanation": "This requirement emphasizes the importance of not using password hints or knowledge-based authentication methods, such as secret questions, as they can often be easily guessed or researched by attackers. Instead, more secure authentication methods should be employed to protect user accounts.", "threats_mitigated": ["Account enumeration", "Social engineering attacks", "Credential stuffing", "Brute force attacks"], "insecure_examples": ["if (userInput.equalsIgnoreCase(secretQuestionAnswer)) { // allow access }", "String hint = 'Your first pet's name?'; // hint stored in plaintext"], "secure_examples": ["if (isValidUser(userInput)) { // proceed with secure authentication }", "String hint = ''; // no hint stored"], "verification_steps": ["Check the authentication mechanism for the presence of password hints.", "Review the implementation of knowledge-based authentication methods.", "Ensure that no sensitive information is exposed through hints or questions."], "common_mistakes": ["Using easily guessable questions for knowledge-based authentication.", "Storing hints or answers in plaintext.", "Failing to remove legacy password hint mechanisms."], "related_cwe": ["CWE-521: Weak Password Requirements", "CWE-200: Information Exposure", "CWE-640: Weak Password Recovery Mechanism for Forgotten Password"], "related_capec": ["CAPEC-137: Guessing a Password", "CAPEC-162: Social Engineering - Pretexting", "CAPEC-172: Credential Stuffing"], "attack_flow": "An attacker may exploit the presence of password hints or knowledge-based authentication by researching the victim's personal information (e.g., through social media) to answer the questions correctly, thereby gaining unauthorized access to the victim's account."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.4", "section_name": "Authentication Factor Lifecycle and Recovery", "req_id": "V6.4.3", "req_description": "Verify that a secure process for resetting a forgotten password is implemented, that does not bypass any enabled multi-factor authentication mechanisms.", "level": 2, "explanation": "This requirement emphasizes the importance of having a secure password reset mechanism that respects the security controls in place, particularly multi-factor authentication (MFA). It ensures that even if a user forgets their password, the process to regain access does not compromise the security provided by MFA, thereby maintaining the integrity of user accounts.", "threats_mitigated": ["Account takeover", "Unauthorized access", "Social engineering attacks"], "insecure_examples": ["function resetPassword(userId) { // Insecure implementation\n  // Bypasses MFA\n  user = getUserById(userId);\n  user.password = generateNewPassword();\n  sendEmail(user.email, 'Your password has been reset');\n}", "function resetPassword(userId) { // Insecure implementation\n  // Allows password reset without MFA verification\n  if (userId) {\n    user = getUserById(userId);\n    user.password = 'newPassword';\n  }\n}"], "secure_examples": ["function resetPassword(userId) {\n  // Secure implementation with MFA\n  if (isMFAEnabled(userId)) {\n    sendMFAChallenge(userId);\n    if (verifyMFAToken(userId, token)) {\n      user = getUserById(userId);\n      user.password = generateNewPassword();\n      sendEmail(user.email, 'Your password has been reset');\n    }\n  }\n}", "function resetPassword(userId) {\n  // Secure implementation\n  if (isUserValid(userId) && isMFAEnabled(userId)) {\n    sendMFAChallenge(userId);\n    if (verifyMFAToken(userId, token)) {\n      user = getUserById(userId);\n      user.password = generateSecurePassword();\n    }\n  }\n}"], "verification_steps": ["Check if the password reset process requires MFA verification.", "Ensure that the reset process does not allow password changes without MFA.", "Review the implementation to confirm that no sensitive information is exposed during the reset process.", "Test the process with and without MFA enabled to ensure compliance."], "common_mistakes": ["Allowing password resets without MFA verification.", "Failing to validate the user's identity before allowing a password reset.", "Not notifying users of password changes or resets."], "related_cwe": ["CWE-640: Weak Password Recovery Mechanism", "CWE-287: Improper Authentication"], "related_capec": ["CAPEC-138: Password Reset via Email", "CAPEC-157: Credential Recovery via Social Engineering"], "attack_flow": "An attacker may exploit a weak password reset process by initiating a password reset for a target user. If the process does not require multi-factor authentication, the attacker can gain access to the user's account by simply resetting the password, thereby bypassing any security measures that were intended to protect the account."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.4", "section_name": "Authentication Factor Lifecycle and Recovery", "req_id": "V6.4.4", "req_description": "Verify that if a multi-factor authentication factor is lost, evidence of identity proofing is performed at the same level as during enrollment.", "level": 2, "explanation": "This requirement ensures that when a user loses a multi-factor authentication factor (such as a hardware token or mobile device), the process to recover or replace that factor is as stringent as the initial enrollment process. This means that the identity of the user must be verified using the same methods and rigor as when they first set up their multi-factor authentication. This helps prevent unauthorized access to accounts by ensuring that only legitimate users can recover their authentication factors.", "threats_mitigated": ["Account takeover", "Identity theft", "Unauthorized access"], "insecure_examples": ["if (factorLost) { allowRecoveryWithoutVerification(); }", "user.requestRecovery(factorLost); // No identity proofing implemented"], "secure_examples": ["if (factorLost) { requireIdentityProofing(); }", "user.requestRecovery(factorLost); verifyIdentity(user);"], "verification_steps": ["Check if the recovery process requires identity proofing.", "Ensure that the identity proofing methods are equivalent to those used during initial enrollment.", "Review logs to confirm that identity verification steps are logged and monitored."], "common_mistakes": ["Allowing recovery without any identity verification.", "Using weaker verification methods for recovery compared to enrollment.", "Failing to log recovery attempts and their outcomes."], "related_cwe": ["CWE-287", "CWE-306"], "related_capec": ["CAPEC-113", "CAPEC-152"], "attack_flow": "An attacker may exploit a lost multi-factor authentication factor by impersonating the user and requesting recovery without proper verification. If the recovery process does not enforce strict identity proofing, the attacker could gain access to the user's account, leading to potential data breaches and unauthorized transactions."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.4", "section_name": "Authentication Factor Lifecycle and Recovery", "req_id": "V6.4.5", "req_description": "Verify that renewal instructions for authentication mechanisms which expire are sent with enough time to be carried out before the old authentication mechanism expires, configuring automated reminders if necessary.", "level": 3, "explanation": "This requirement emphasizes the importance of timely notifications for users regarding the expiration of their authentication mechanisms, such as passwords or tokens. It ensures that users are given adequate time to renew their credentials before they become invalid, thereby preventing lockout scenarios and maintaining access continuity.", "threats_mitigated": ["Account lockout due to expired credentials", "Denial of service through credential expiration", "User frustration and potential abandonment of the service"], "insecure_examples": [{"code_snippet": "if (token.isExpired()) { /* No notification sent */ }"}, {"code_snippet": "user.sendReminderEmail(null); // Reminder not configured"}], "secure_examples": [{"code_snippet": "if (token.isExpiringSoon()) { user.sendReminderEmail(token); }"}, {"code_snippet": "scheduleReminder(user, token.expirationDate); // Configured automated reminder"}], "verification_steps": ["Check if the application sends renewal instructions before the authentication mechanism expires.", "Verify that automated reminders are configured and functioning as intended.", "Test the timing of reminders to ensure they are sent with adequate lead time."], "common_mistakes": ["Failing to send reminders until after the expiration date.", "Not providing clear instructions on how to renew the authentication mechanism.", "Neglecting to configure automated reminders for users."], "related_cwe": ["CWE-640: Weak Password Recovery Mechanism", "CWE-759: Use of a One-Way Hash without a Salt"], "related_capec": ["CAPEC-127: Credential Theft", "CAPEC-148: Credential Recovery Attack"], "attack_flow": "An attacker may exploit the lack of timely renewal notifications by waiting for a userâ€™s authentication mechanism to expire. Once expired, the user may be locked out and unable to access their account. If the user is not aware of the expiration, they may be vulnerable to social engineering attacks where the attacker could impersonate support to gain access to the account."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.4", "section_name": "Authentication Factor Lifecycle and Recovery", "req_id": "V6.4.6", "req_description": "Verify that administrative users can initiate the password reset process for the user, but that this does not allow them to change or choose the user's password. This prevents a situation where they know the user's password.", "level": 3, "explanation": "This requirement ensures that while administrators have the ability to assist users in resetting their passwords, they do not gain the ability to directly manipulate or know the user's password. This is crucial for maintaining user privacy and security, as it limits the power of administrative accounts and protects against potential misuse.", "threats_mitigated": ["Unauthorized access to user accounts", "Privilege escalation by administrators", "Social engineering attacks targeting administrators"], "insecure_examples": ["admin_user.changePassword(user_id, new_password); // Admin can set any password for the user", "admin_user.resetPassword(user_id); // Admin can reset the password without restrictions"], "secure_examples": ["admin_user.initiatePasswordReset(user_id); // Admin can only initiate a reset, not set a password", "user.receivePasswordResetLink(email); // User receives a link to reset their own password"], "verification_steps": ["Check if the admin can only initiate the password reset process.", "Verify that the admin cannot see or set the user's new password.", "Ensure that the user receives a secure password reset link or token."], "common_mistakes": ["Allowing admins to directly set user passwords instead of initiating a reset.", "Not implementing proper logging and monitoring of password reset requests.", "Failing to validate the identity of the user requesting the password reset."], "related_cwe": ["CWE-263: Permission Issues", "CWE-285: Improper Authorization"], "related_capec": ["CAPEC-130: Password Reset via Email", "CAPEC-137: Credential Recovery via Social Engineering"], "attack_flow": "An attacker may exploit this requirement by gaining administrative access and using it to reset user passwords directly, thereby gaining unauthorized access to user accounts. This can lead to data breaches and unauthorized actions performed in the context of the user's account."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.5", "section_name": "General Multi-factor authentication requirements", "req_id": "V6.5.1", "req_description": "Verify that lookup secrets, out-of-band authentication requests or codes, and time-based one-time passwords (TOTPs) are only successfully usable once.", "level": 2, "explanation": "This requirement ensures that any authentication mechanism that relies on temporary codes or secrets is designed to be used only a single time. This is critical to prevent replay attacks, where an attacker might intercept and reuse an authentication code to gain unauthorized access.", "threats_mitigated": ["Replay attacks", "Man-in-the-middle attacks", "Credential stuffing"], "insecure_examples": ["if (codeIsValid) { authenticateUser(); } // Code can be reused", "let isUsed = false; if (!isUsed) { authenticateUser(); isUsed = true; } // No proper state management"], "secure_examples": ["if (codeIsValid && !code.isUsed) { authenticateUser(); code.isUsed = true; } // Ensures code is marked as used", "let isUsed = false; if (!isUsed && validateCode(inputCode)) { authenticateUser(); isUsed = true; } // Proper state management"], "verification_steps": ["Check that each code or secret has a 'used' state that is updated after a successful authentication.", "Review the code to ensure that a code cannot be reused after it has been consumed.", "Test the authentication flow with valid codes to ensure they fail on subsequent attempts."], "common_mistakes": ["Not marking codes as used after authentication.", "Failing to implement a mechanism to invalidate codes after a single use.", "Assuming that time-based codes are secure without additional checks."], "related_cwe": ["CWE-295: Improper Certificate Validation", "CWE-287: Improper Authentication"], "related_capec": ["CAPEC-137: Replay Attack", "CAPEC-157: Man-in-the-Middle Attack"], "attack_flow": "An attacker intercepts a one-time password (OTP) sent to a user. If the OTP can be reused, the attacker can use it to authenticate as the user, gaining unauthorized access to the system. By ensuring that OTPs are only valid for a single use, this attack vector is mitigated."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.5", "section_name": "General Multi-factor authentication requirements", "req_id": "V6.5.2", "req_description": "Verify that, when being stored in the application's backend, lookup secrets with less than 112 bits of entropy (19 random alphanumeric characters or 34 random digits) are hashed with an approved password storage hashing algorithm that incorporates a 32-bit random salt. A standard hash function can be used if the secret has 112 bits of entropy or more.", "level": "2", "explanation": "This requirement emphasizes the importance of securely storing sensitive secrets, such as passwords or API keys, to prevent unauthorized access. It specifies that secrets with lower entropy should be hashed using a secure algorithm that includes a salt to protect against rainbow table attacks. For secrets with higher entropy, standard hash functions may suffice, but the requirement encourages the use of strong hashing methods for all sensitive data.", "threats_mitigated": ["Brute force attacks", "Rainbow table attacks", "Credential stuffing", "Data breaches"], "insecure_examples": [{"code": "String secret = \"mySecret123\"; // Less than 112 bits of entropy\nString hashedSecret = Hashing.sha256().hashString(secret, StandardCharsets.UTF_8).toString();"}, {"code": "String secret = \"password\"; // Too weak and not hashed\nstoreInDatabase(secret);"}], "secure_examples": [{"code": "String secret = \"mySecret123\"; // Less than 112 bits of entropy\nString salt = generateRandomSalt();\nString hashedSecret = hashWithSalt(secret, salt); // Use a secure hashing algorithm with salt"}, {"code": "String secret = \"password\";\nString salt = generateRandomSalt();\nString hashedSecret = hashWithSalt(secret, salt); // Securely hash the secret"}], "verification_steps": ["Check that secrets with less than 112 bits of entropy are hashed.", "Ensure that an approved password storage hashing algorithm is used.", "Verify that a 32-bit random salt is incorporated into the hashing process.", "Review the implementation for compliance with the latest security standards."], "common_mistakes": ["Using weak or outdated hashing algorithms.", "Failing to use a salt when hashing secrets.", "Assuming that high entropy secrets do not need special handling.", "Hardcoding secrets in the source code."], "related_cwe": ["CWE-256: Plaintext Storage of a Password", "CWE-760: Use of a One-Way Hash without a Salt"], "related_capec": ["CAPEC-137: Brute Force Attack", "CAPEC-149: Credential Stuffing Attack"], "attack_flow": "An attacker can exploit weakly hashed secrets by using pre-computed tables (rainbow tables) to quickly find the original secret. If secrets are stored in plaintext, the attacker can directly access them. By failing to use a strong hashing algorithm or salt, the application becomes vulnerable to brute force attacks where the attacker systematically tries different combinations until the correct one is found."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.5", "section_name": "General Multi-factor authentication requirements", "req_id": "V6.5.3", "req_description": "Verify that lookup secrets, out-of-band authentication code, and time-based one-time password seeds, are generated using a Cryptographically Secure Pseudorandom Number Generator (CSPRNG) to avoid predictable values.", "level": "2", "explanation": "This requirement ensures that any secrets or tokens used in the authentication process are generated using a secure method that produces unpredictable values. Using a Cryptographically Secure Pseudorandom Number Generator (CSPRNG) helps to prevent attackers from guessing or predicting these values, which could lead to unauthorized access.", "threats_mitigated": ["Predictable token generation", "Brute force attacks", "Replay attacks"], "insecure_examples": [{"code": "String token = UUID.randomUUID().toString(); // Insecure token generation"}, {"code": "int randomNumber = new Random().nextInt(); // Insecure random number generation"}], "secure_examples": [{"code": "SecureRandom secureRandom = new SecureRandom(); byte[] token = new byte[32]; secureRandom.nextBytes(token); // Secure token generation"}, {"code": "String otpSeed = Base64.getEncoder().encodeToString(secureRandom.generateSeed(16)); // Secure OTP seed generation"}], "verification_steps": ["Check that a CSPRNG is used for generating secrets and tokens.", "Review the implementation of the random number generation to ensure it meets cryptographic standards.", "Test the generated values to ensure they are unpredictable and not easily guessable."], "common_mistakes": ["Using non-cryptographic random number generators like java.util.Random.", "Failing to use sufficient entropy in the generation process.", "Hardcoding secrets or predictable values."], "related_cwe": ["CWE-331: Insufficient Entropy", "CWE-338: Use of Cryptographically Weak PRNG"], "related_capec": ["CAPEC-137: Brute Force Attack", "CAPEC-152: Token Replay Attack"], "attack_flow": "An attacker may exploit predictable values generated by a weak random number generator to guess tokens or secrets. By analyzing patterns in the generated values, they can potentially gain unauthorized access to user accounts or sensitive information."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.5", "section_name": "General Multi-factor authentication requirements", "req_id": "V6.5.4", "req_description": "Verify that lookup secrets and out-of-band authentication codes have a minimum of 20 bits of entropy (typically 4 random alphanumeric characters or 6 random digits is sufficient).", "level": 2, "explanation": "This requirement emphasizes the importance of using sufficiently random values for lookup secrets and out-of-band authentication codes to ensure that they cannot be easily guessed or brute-forced by an attacker. A minimum of 20 bits of entropy means that there are at least 1,048,576 possible combinations, making it significantly more difficult for an attacker to successfully guess the secret.", "threats_mitigated": ["Brute force attacks", "Guessing attacks", "Credential stuffing"], "insecure_examples": [{"code": "String lookupSecret = \"abcd\"; // Only 16 bits of entropy"}, {"code": "String authCode = \"123456\"; // Predictable numeric code"}], "secure_examples": [{"code": "String lookupSecret = generateSecureRandomString(4); // Generates a secure random string with sufficient entropy"}, {"code": "String authCode = generateSecureRandomDigits(6); // Generates a secure random numeric code"}], "verification_steps": ["Check the implementation of the random string generation method.", "Verify that the generated codes meet the minimum entropy requirement.", "Review the documentation for the random number generator used.", "Ensure that the secrets are not hardcoded and are generated at runtime."], "common_mistakes": ["Using predictable patterns for generating secrets.", "Hardcoding secrets in the source code.", "Using insufficiently random or weak random number generators."], "related_cwe": ["CWE-331: Insufficient Entropy", "CWE-326: Inadequate Encryption Strength"], "related_capec": ["CAPEC-138: Brute Force Attack", "CAPEC-163: Guessing Passwords"], "attack_flow": "An attacker may exploit weak lookup secrets or out-of-band authentication codes by using brute force techniques to guess the values. If the secrets are predictable or lack sufficient entropy, the attacker can successfully authenticate or gain unauthorized access to the system."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.5", "section_name": "General Multi-factor authentication requirements", "req_id": "V6.5.5", "req_description": "Verify that out-of-band authentication requests, codes, or tokens, as well as time-based one-time passwords (TOTPs) have a defined lifetime. Out of band requests must have a maximum lifetime of 10 minutes and for TOTP a maximum lifetime of 30 seconds.", "level": 2, "explanation": "This requirement ensures that authentication mechanisms that rely on out-of-band methods and time-based one-time passwords are not valid indefinitely. By enforcing a defined lifetime, the risk of replay attacks is minimized, as an attacker cannot reuse an old token or code after the specified time has elapsed.", "threats_mitigated": ["Replay attacks", "Session hijacking", "Unauthorized access using stale tokens"], "insecure_examples": ["if (codeIsValid) { grantAccess(); } // No expiration check for the code", "let token = generateToken(); // Token is valid indefinitely"], "secure_examples": ["if (codeIsValid && isWithinLifetime(codeTimestamp)) { grantAccess(); }", "let token = generateToken(); setExpiration(token, 30); // Token expires after 30 seconds"], "verification_steps": ["Check if the application defines a maximum lifetime for out-of-band codes.", "Verify that TOTP tokens expire after 30 seconds.", "Review the code to ensure that expired tokens are rejected.", "Test the application by attempting to use expired tokens or codes."], "common_mistakes": ["Failing to implement expiration checks for out-of-band codes.", "Setting token lifetimes too long, allowing for potential replay attacks.", "Not logging or monitoring the use of authentication codes."], "related_cwe": ["CWE-295: Improper Certificate Validation", "CWE-287: Improper Authentication", "CWE-306: Missing Authentication for Critical Function"], "related_capec": ["CAPEC-104: Replay Attack", "CAPEC-138: Credential Theft", "CAPEC-153: Token Theft"], "attack_flow": "An attacker intercepts an out-of-band authentication code or TOTP and attempts to reuse it after its intended use. If the application does not enforce a defined lifetime for these codes, the attacker can gain unauthorized access by presenting the stale code before it expires."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.5", "section_name": "General Multi-factor authentication requirements", "req_id": "V6.5.6", "req_description": "Verify that any authentication factor (including physical devices) can be revoked in case of theft or other loss.", "level": "3", "explanation": "This requirement ensures that if a multi-factor authentication device (like a hardware token or mobile device) is lost or stolen, the organization has the ability to invalidate that device immediately. This is crucial to prevent unauthorized access that could occur if an attacker gains possession of the authentication factor.", "threats_mitigated": ["Unauthorized access due to lost or stolen authentication factors", "Account takeover attacks", "Identity theft"], "insecure_examples": [{"code": "if (device.isStolen()) { device.enable(); }", "description": "This code snippet fails to revoke the authentication factor when it is determined to be stolen."}, {"code": "user.authFactors.add(stolenDevice); // No revocation logic implemented", "description": "Adding a stolen device back to the user's authentication factors without revocation."}], "secure_examples": [{"code": "if (device.isStolen()) { device.revoke(); }", "description": "This code snippet correctly revokes the authentication factor when it is determined to be stolen."}, {"code": "user.authFactors.remove(stolenDevice); // Properly revoking the stolen device", "description": "Removing the stolen device from the user's authentication factors."}], "verification_steps": ["Check if there is a mechanism to report lost or stolen authentication factors.", "Verify that the revocation process can be executed by authorized personnel.", "Test the revocation process to ensure it effectively prevents access using the revoked factor.", "Review logs to confirm that revocation actions are recorded."], "common_mistakes": ["Failing to implement a user-friendly process for reporting lost or stolen devices.", "Not providing a way to revoke access immediately after reporting.", "Assuming that physical possession of the device is enough to ensure security without revocation."], "related_cwe": ["CWE-287", "CWE-295"], "related_capec": ["CAPEC-134", "CAPEC-154"], "attack_flow": "An attacker finds or steals a user's multi-factor authentication device and attempts to use it to gain access to the user's account. If the organization does not have a mechanism to revoke the device, the attacker can successfully authenticate and take control of the account, leading to potential data breaches and identity theft."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.5", "section_name": "General Multi-factor authentication requirements", "req_id": "V6.5.7", "req_description": "Verify that biometric authentication mechanisms are only used as secondary factors together with either something you have or something you know.", "level": "3", "explanation": "This requirement ensures that biometric authentication, such as fingerprints or facial recognition, is not the sole method of authentication. Instead, it should be combined with another factor, such as a password (something you know) or a hardware token (something you have), to enhance security. This layered approach reduces the risk of unauthorized access even if one factor is compromised.", "threats_mitigated": ["Unauthorized access due to stolen biometric data", "Replay attacks using captured biometric data", "Bypassing authentication through compromised primary factors"], "insecure_examples": [{"code": "if (biometricAuthentication()) { grantAccess(); }"}, {"code": "userLogin(biometricData);"}], "secure_examples": [{"code": "if (biometricAuthentication() && passwordAuthentication()) { grantAccess(); }"}, {"code": "userLogin(biometricData, password);"}], "verification_steps": ["Check that biometric authentication is implemented as a secondary factor.", "Verify that at least one primary factor (something you know or something you have) is required.", "Review the authentication flow to ensure compliance with the requirement."], "common_mistakes": ["Using biometric authentication as the only factor for access control.", "Failing to implement fallback mechanisms for biometric failures.", "Not educating users about the limitations of biometric security."], "related_cwe": ["CWE-287", "CWE-522", "CWE-295"], "related_capec": ["CAPEC-94", "CAPEC-118", "CAPEC-164"], "attack_flow": "An attacker may exploit a system that relies solely on biometric authentication by capturing the biometric data (e.g., through a spoofing attack or using a high-resolution image). If the biometric system is the only factor, the attacker can gain unauthorized access. However, if the system requires an additional factor, such as a password or a hardware token, the attacker would need to compromise both factors to succeed."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.5", "section_name": "General Multi-factor authentication requirements", "req_id": "V6.5.8", "req_description": "Verify that time-based one-time passwords (TOTPs) are checked based on a time source from a trusted service and not from an untrusted or client provided time.", "level": 3, "explanation": "This requirement emphasizes the importance of using a reliable and secure time source for validating time-based one-time passwords (TOTPs). If an application relies on a client-provided time, it can be manipulated by an attacker to generate valid TOTPs, thereby compromising the multi-factor authentication mechanism. By using a trusted time source, such as a network time protocol (NTP) server, the integrity of the TOTP validation process is maintained.", "threats_mitigated": ["Replay attacks", "Man-in-the-middle attacks", "Time manipulation attacks"], "insecure_examples": [{"code": "if (userTOTP == generateTOTP(clientProvidedTime)) { /* allow access */ }"}, {"code": "let currentTime = clientProvidedTime; if (userTOTP == generateTOTP(currentTime)) { /* grant access */ }"}], "secure_examples": [{"code": "let trustedTime = getTimeFromTrustedSource(); if (userTOTP == generateTOTP(trustedTime)) { /* allow access */ }"}, {"code": "const currentTime = getTimeFromNTPServer(); if (userTOTP === generateTOTP(currentTime)) { /* grant access */ }"}], "verification_steps": ["Check if the application retrieves time from a trusted NTP server.", "Verify that the TOTP generation function uses the server-provided time.", "Test the application with manipulated client time to ensure it does not accept invalid TOTPs."], "common_mistakes": ["Using client-side time for TOTP generation and validation.", "Failing to validate the source of the time used for TOTP.", "Not implementing fallback mechanisms for time synchronization issues."], "related_cwe": ["CWE-295: Improper Certificate Validation", "CWE-20: Improper Input Validation", "CWE-330: Use of Insufficiently Random Values"], "related_capec": ["CAPEC-143: Replay Attack", "CAPEC-145: Time Manipulation Attack"], "attack_flow": "An attacker can manipulate the client's system time to generate valid TOTPs. If the application validates these TOTPs using the manipulated time, the attacker can gain unauthorized access. By ensuring that the TOTP validation relies on a trusted time source, the application mitigates this risk and maintains the integrity of the authentication process."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.6", "section_name": "Out-of-Band authentication mechanisms", "req_id": "V6.6.1", "req_description": "Verify that authentication mechanisms using the Public Switched Telephone Network (PSTN) to deliver One-time Passwords (OTPs) via phone or SMS are offered only when the phone number has previously been validated, alternate stronger methods (such as Time based One-time Passwords) are also offered, and the service provides information on their security risks to users. For L3 applications, phone and SMS must not be available as options.", "level": 2, "explanation": "This requirement ensures that any authentication mechanism that relies on the PSTN for delivering OTPs is secure and that users are aware of the potential risks associated with these methods. It emphasizes the importance of validating phone numbers before use and encourages the implementation of stronger authentication methods, such as Time-based One-Time Passwords (TOTP), which are less susceptible to interception. For Level 3 applications, which require a higher security standard, the use of phone and SMS for OTP delivery is prohibited altogether.", "threats_mitigated": ["SMS interception", "Phishing attacks", "Social engineering attacks", "SIM swapping"], "insecure_examples": ["if (userInput.phoneNumber.isValid()) { sendOTP(userInput.phoneNumber); }", "sendSMS(userInput.phoneNumber, generateOTP());"], "secure_examples": ["if (isPhoneNumberValidated(userInput.phoneNumber)) { sendOTP(userInput.phoneNumber); }", "sendSMS(userInput.phoneNumber, generateTOTP());"], "verification_steps": ["Check if the phone number is validated before sending OTP.", "Ensure that alternate authentication methods are available.", "Review user communication regarding security risks of SMS-based OTPs.", "Confirm that for L3 applications, phone and SMS are not used for OTP delivery."], "common_mistakes": ["Failing to validate phone numbers before sending OTPs.", "Not providing alternative authentication options.", "Neglecting to inform users about the security risks of using SMS for OTPs.", "Using SMS as a primary method for sensitive applications."], "related_cwe": ["CWE-20: Improper Input Validation", "CWE-287: Improper Authentication", "CWE-295: Improper Certificate Validation"], "related_capec": ["CAPEC-104: SMS Phishing", "CAPEC-125: SIM Swap Attack", "CAPEC-154: Social Engineering"], "attack_flow": "An attacker could exploit the lack of phone number validation by providing a malicious phone number to receive OTPs intended for a legitimate user. If the phone number is not validated, the attacker can intercept the OTP and gain unauthorized access. Additionally, if the application relies solely on SMS for OTP delivery, an attacker could use social engineering tactics to convince the victim to disclose their OTP, leading to account compromise."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.6", "section_name": "Out-of-Band authentication mechanisms", "req_id": "V6.6.2", "req_description": "Verify that out-of-band authentication requests, codes, or tokens are bound to the original authentication request for which they were generated and are not usable for a previous or subsequent one.", "level": "2", "explanation": "This requirement ensures that any out-of-band authentication mechanisms, such as SMS codes or email tokens, are uniquely tied to the specific authentication request. This prevents attackers from reusing codes or tokens generated for one session to authenticate themselves in another session, thereby enhancing the security of the authentication process.", "threats_mitigated": ["Replay attacks", "Token reuse attacks", "Session hijacking"], "insecure_examples": [{"code": "if (userInputToken == generatedToken) { authenticateUser(); }"}, {"code": "sendTokenToUser(); // No binding to original request"}], "secure_examples": [{"code": "if (userInputToken == generatedToken && requestId == originalRequestId) { authenticateUser(); }"}, {"code": "sendTokenToUser(requestId); // Binding token to original request"}], "verification_steps": ["Check that tokens are generated with a unique identifier for each request.", "Ensure that the token cannot be reused for different requests.", "Review the code to verify that the binding logic is implemented correctly.", "Test the application to ensure that expired tokens are not accepted."], "common_mistakes": ["Failing to bind tokens to specific requests.", "Allowing tokens to be reused across different authentication attempts.", "Not implementing expiration for out-of-band tokens."], "related_cwe": ["CWE-295: Improper Certificate Validation", "CWE-287: Improper Authentication"], "related_capec": ["CAPEC-139: Replay Attack", "CAPEC-92: Session Fixation"], "attack_flow": "An attacker intercepts an out-of-band authentication token and attempts to use it in a different session. If the token is not bound to the original request, the attacker can successfully authenticate, gaining unauthorized access to the user's account."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.6", "section_name": "Out-of-Band authentication mechanisms", "req_id": "V6.6.3", "req_description": "Verify that a code based out-of-band authentication mechanism is protected against brute force attacks by using rate limiting. Consider also using a code with at least 64 bits of entropy.", "level": 2, "explanation": "This requirement emphasizes the importance of implementing rate limiting on out-of-band authentication mechanisms, such as SMS or email codes. Rate limiting restricts the number of attempts a user can make to enter the code, thereby preventing attackers from systematically guessing the code through brute force methods. Additionally, ensuring that the authentication code has a sufficient level of entropy (at least 64 bits) makes it more resistant to guessing attacks, as the number of possible combinations increases exponentially with higher entropy.", "threats_mitigated": ["Brute Force Attacks", "Credential Stuffing", "Account Takeover"], "insecure_examples": ["if (userInputCode == expectedCode) { /* grant access */ }", "attempts++; if (attempts > 5) { /* lock account */ }"], "secure_examples": ["if (userInputCode == expectedCode && rateLimitExceeded() == false) { /* grant access */ }", "attempts++; if (attempts > MAX_ATTEMPTS) { /* block further attempts for a period */ }"], "verification_steps": ["Check if rate limiting is implemented for code entry attempts.", "Verify that the rate limit thresholds are reasonable and effective.", "Ensure that the authentication code has at least 64 bits of entropy.", "Review the code for potential bypasses of the rate limiting mechanism."], "common_mistakes": ["Not implementing any rate limiting on out-of-band authentication codes.", "Using codes with insufficient entropy, making them easier to guess.", "Failing to lock accounts or throttle requests after multiple failed attempts."], "related_cwe": ["CWE-307", "CWE-20", "CWE-798"], "related_capec": ["CAPEC-137", "CAPEC-138"], "attack_flow": "An attacker can exploit the lack of rate limiting by repeatedly submitting guessed codes until they find the correct one. If the authentication code has low entropy, the attacker can use automated tools to generate possible codes quickly. Once the correct code is found, the attacker gains unauthorized access to the user's account."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.6", "section_name": "Out-of-Band authentication mechanisms", "req_id": "V6.6.4", "req_description": "Verify that, where push notifications are used for multi-factor authentication, rate limiting is used to prevent push bombing attacks. Number matching may also mitigate this risk.", "level": 3, "explanation": "This requirement emphasizes the importance of implementing rate limiting on push notifications used in multi-factor authentication (MFA) scenarios. Push bombing is a type of attack where an attacker sends numerous push notifications to a user in a short period, overwhelming them and potentially leading to unauthorized access. By applying rate limiting, the system can restrict the number of notifications sent to a user within a specific timeframe, thereby reducing the risk of such attacks. Additionally, number matching requires the user to confirm a specific number displayed during the authentication process, further ensuring that the legitimate user is the one authorizing the action.", "threats_mitigated": ["Push bombing attacks", "Account takeover attempts", "Denial of service through excessive notifications"], "insecure_examples": [{"code_snippet": "function sendPushNotification(user) { sendNotification(user); } // No rate limiting implemented"}, {"code_snippet": "function authenticateUser(user, code) { if (isValidCode(code)) { sendPushNotification(user); } } // No check for excessive notifications"}], "secure_examples": [{"code_snippet": "function sendPushNotification(user) { if (rateLimitExceeded(user)) { return; } sendNotification(user); }"}, {"code_snippet": "function authenticateUser(user, code) { if (isValidCode(code) && !rateLimitExceeded(user)) { sendPushNotification(user); } }"}], "verification_steps": ["Check that rate limiting is implemented for push notifications.", "Verify that the rate limit is set to a reasonable threshold to prevent abuse.", "Ensure that number matching is implemented as an additional verification step.", "Review logs to identify any patterns of excessive push notifications."], "common_mistakes": ["Failing to implement any form of rate limiting on push notifications.", "Not considering the user experience when setting rate limits.", "Overlooking the need for additional verification methods like number matching."], "related_cwe": ["CWE-20: Improper Input Validation", "CWE-287: Improper Authentication"], "related_capec": ["CAPEC-148: Push Notification Bombing", "CAPEC-153: Account Takeover via Push Notification"], "attack_flow": "An attacker exploits this requirement by sending a flood of push notifications to a user's device, causing confusion and prompting the user to approve an authentication request without verifying its legitimacy. If rate limiting is not in place, the user may inadvertently grant access to the attacker, leading to unauthorized access to sensitive information or accounts."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.7", "section_name": "Cryptographic authentication mechanism", "req_id": "V6.7.1", "req_description": "Verify that the certificates used to verify cryptographic authentication assertions are stored in a way protects them from modification.", "level": "3", "explanation": "This requirement emphasizes the importance of securely storing cryptographic certificates to prevent unauthorized modifications. Certificates are critical for establishing trust in authentication processes, and if they are tampered with, it could lead to unauthorized access or impersonation. Proper storage mechanisms, such as hardware security modules (HSMs) or secure key management systems, should be utilized to ensure the integrity of these certificates.", "threats_mitigated": ["Certificate tampering", "Man-in-the-middle attacks", "Unauthorized access", "Impersonation attacks"], "insecure_examples": [{"code": "String certificate = \"-----BEGIN CERTIFICATE-----\\n...\\n-----END CERTIFICATE-----\"; // Hardcoded certificate in source code"}, {"code": "File certFile = new File(\"/path/to/certificates/cert.pem\"); // Storing certificate in an easily accessible location"}], "secure_examples": [{"code": "KeyStore keyStore = KeyStore.getInstance(\"PKCS12\"); // Use a secure keystore to store certificates"}, {"code": "HSM hsm = new HSM(); // Use a hardware security module for storing certificates securely"}], "verification_steps": ["Check if certificates are stored in a secure location.", "Verify that access to the storage location is restricted.", "Ensure that certificates are not hardcoded in source code.", "Review the use of secure key management practices."], "common_mistakes": ["Hardcoding certificates in the application code.", "Storing certificates in publicly accessible directories.", "Failing to implement proper access controls on certificate storage."], "related_cwe": ["CWE-312: Cleartext Storage of Sensitive Information", "CWE-321: Use of Hard-coded Cryptographic Key"], "related_capec": ["CAPEC-137: Man-in-the-Middle Attack", "CAPEC-153: Certificate Spoofing"], "attack_flow": "An attacker may gain access to the storage location of the certificates and modify them to impersonate a legitimate user or service. If the application relies on these modified certificates for authentication, the attacker can bypass security controls and gain unauthorized access."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.7", "section_name": "Cryptographic authentication mechanism", "req_id": "V6.7.2", "req_description": "Verify that the challenge nonce is at least 64 bits in length, and statistically unique or unique over the lifetime of the cryptographic device.", "level": 3, "explanation": "A nonce is a number that is used only once in a cryptographic communication. It is crucial for preventing replay attacks and ensuring that each authentication request is unique. By requiring a nonce to be at least 64 bits, we significantly increase the number of possible values, making it statistically improbable for a nonce to be reused. This uniqueness must be maintained either over the lifetime of the cryptographic device or for the duration of the session to prevent vulnerabilities.", "threats_mitigated": ["Replay Attacks", "Session Hijacking", "Man-in-the-Middle Attacks"], "insecure_examples": [{"code": "String nonce = generateNonce(); // Generates a nonce less than 64 bits"}, {"code": "String nonce = \"12345\"; // Hardcoded nonce value"}], "secure_examples": [{"code": "byte[] nonce = new byte[8]; // Generates a 64-bit nonce\nnew SecureRandom().nextBytes(nonce);"}, {"code": "String nonce = UUID.randomUUID().toString(); // Generates a unique nonce"}], "verification_steps": ["Check that the nonce length is at least 64 bits.", "Ensure that the nonce is generated using a secure random number generator.", "Verify that the nonce is unique for each authentication request.", "Confirm that the nonce is not reused during the lifetime of the cryptographic device."], "common_mistakes": ["Using a nonce that is too short, leading to potential collisions.", "Reusing nonces across multiple sessions or requests.", "Generating nonces using predictable algorithms or sources."], "related_cwe": ["CWE-330", "CWE-295", "CWE-384"], "related_capec": ["CAPEC-142", "CAPEC-155"], "attack_flow": "An attacker intercepts a previous authentication request and replays it, using the same nonce. If the nonce is not unique or is too short, the server may accept the replayed request, allowing the attacker to gain unauthorized access."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.8", "section_name": "Authentication with an Identity Provider", "req_id": "V6.8.1", "req_description": "Verify that, if the application supports multiple identity providers (IdPs), the user's identity cannot be spoofed via another supported identity provider (eg. by using the same user identifier). The standard mitigation would be for the application to register and identify the user using a combination of the IdP ID (serving as a namespace) and the user's ID in the IdP.", "level": 2, "explanation": "This requirement ensures that when an application allows users to authenticate through different identity providers, it prevents identity spoofing by ensuring that user identifiers are unique across those providers. By using a combination of the IdP ID and the user's ID, the application can uniquely identify users even if they have the same username or identifier across different IdPs.", "threats_mitigated": ["Identity spoofing", "Account takeover", "Unauthorized access"], "insecure_examples": ["user_id = get_user_id_from_idp(); // Vulnerable to spoofing if user_id is not namespaced", "if (user_id == 'exampleUser') { // Assumes user_id is unique across IdPs"], "secure_examples": ["user_id = get_user_id_from_idp() + '@' + idp_id; // Namespaces user_id with IdP ID", "if (user_id == 'exampleUser@idp1') { // Ensures unique identification"], "verification_steps": ["Check that user identifiers are namespaced by IdP ID.", "Review the authentication flow to ensure that user IDs are validated against their respective IdPs.", "Test the application with multiple IdPs to verify that user identities are correctly managed."], "common_mistakes": ["Assuming that user identifiers are unique across different identity providers.", "Not implementing a namespacing mechanism for user IDs.", "Failing to validate the source of the user ID during authentication."], "related_cwe": ["CWE-287", "CWE-352", "CWE-20"], "related_capec": ["CAPEC-100", "CAPEC-111", "CAPEC-118"], "attack_flow": "An attacker could exploit this requirement by creating an account with the same username on a different IdP. If the application does not properly namespace the user identifiers, the attacker could gain access to the original user's account by impersonating them, leading to unauthorized access and potential data breaches."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.8", "section_name": "Authentication with an Identity Provider", "req_id": "V6.8.2", "req_description": "Verify that the presence and integrity of digital signatures on authentication assertions (for example on JWTs or SAML assertions) are always validated, rejecting any assertions that are unsigned or have invalid signatures.", "level": 2, "explanation": "This requirement ensures that any authentication assertions, such as JSON Web Tokens (JWTs) or Security Assertion Markup Language (SAML) assertions, are properly signed and that the signatures are verified before trusting the assertions. This helps to prevent unauthorized access by ensuring that only valid tokens from trusted sources are accepted.", "threats_mitigated": ["Token forgery", "Replay attacks", "Man-in-the-middle attacks", "Identity spoofing"], "insecure_examples": [{"code": "const token = getAuthToken();\nconst decoded = jwt.decode(token);\nif (decoded) {\n    // Proceed without verifying signature\n}", "description": "This example decodes a JWT without verifying its signature, which can lead to accepting forged tokens."}, {"code": "const samlAssertion = getSAMLAssertion();\nif (samlAssertion) {\n    // Trust the assertion without checking signature\n}", "description": "This example trusts a SAML assertion without validating its signature, risking unauthorized access."}], "secure_examples": [{"code": "const token = getAuthToken();\nconst verified = jwt.verify(token, secretKey);\nif (!verified) {\n    throw new Error('Invalid token');\n}", "description": "This example verifies the JWT signature before proceeding, ensuring that only valid tokens are accepted."}, {"code": "const samlAssertion = getSAMLAssertion();\nif (validateSAMLSignature(samlAssertion)) {\n    // Proceed with trusted assertion\n} else {\n    throw new Error('Invalid SAML assertion');\n}", "description": "This example checks the signature of the SAML assertion before trusting it, preventing unauthorized access."}], "verification_steps": ["Check that all JWTs are signed with a secure algorithm (e.g., RS256).", "Verify the signature of the JWT using the public key of the issuer.", "For SAML assertions, ensure the signature is validated against the issuer's public key.", "Reject any assertion that is unsigned or has an invalid signature.", "Review the implementation for proper error handling on signature validation failures."], "common_mistakes": ["Failing to validate the signature of the token.", "Using weak or deprecated signing algorithms.", "Assuming that all tokens from a trusted source are valid without verification.", "Not handling signature validation errors properly."], "related_cwe": ["CWE-347", "CWE-295", "CWE-20"], "related_capec": ["CAPEC-138", "CAPEC-149", "CAPEC-150"], "attack_flow": "An attacker could forge a JWT or SAML assertion by creating a token with a valid payload but an invalid signature. If the application fails to validate the signature, it may accept the forged token, allowing the attacker to gain unauthorized access to the system."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.8", "section_name": "Authentication with an Identity Provider", "req_id": "V6.8.3", "req_description": "Verify that SAML assertions are uniquely processed and used only once within the validity period to prevent replay attacks.", "level": 2, "explanation": "This requirement emphasizes the importance of ensuring that SAML assertions are not reused, which can lead to replay attacks. Each assertion must be uniquely identified and should only be valid for a specific time frame. Implementing nonce values and validating timestamps can help mitigate this risk.", "threats_mitigated": ["Replay Attacks", "Session Hijacking"], "insecure_examples": ["if (isValidSAMLAssertion(samlAssertion)) { processAssertion(samlAssertion); }", "processSAMLAssertion(samlAssertion); // No uniqueness check"], "secure_examples": ["if (isValidSAMLAssertion(samlAssertion) && isUnique(samlAssertion)) { processAssertion(samlAssertion); }", "processSAMLAssertion(samlAssertion); // Ensures uniqueness and validity check"], "verification_steps": ["Check that SAML assertions include a unique identifier (e.g., ID attribute).", "Verify that the application maintains a record of processed assertions to prevent reuse.", "Ensure that assertions have a defined validity period and are checked against the current time.", "Review code for proper handling of assertion expiration and uniqueness."], "common_mistakes": ["Failing to implement a uniqueness check for SAML assertions.", "Not validating the expiration time of assertions.", "Reusing SAML assertions without proper checks."], "related_cwe": ["CWE-295: Improper Certificate Validation", "CWE-287: Improper Authentication"], "related_capec": ["CAPEC-137: Replay Attack", "CAPEC-108: Session Fixation"], "attack_flow": "An attacker intercepts a valid SAML assertion and reuses it to gain unauthorized access to a service. If the application does not check for uniqueness or validity, the attacker can impersonate a legitimate user, potentially leading to data breaches or unauthorized actions."}
{"chapter_id": "V6", "chapter_name": "Authentication", "section_id": "V6.8", "section_name": "Authentication with an Identity Provider", "req_id": "V6.8.4", "req_description": "Verify that, if an application uses a separate Identity Provider (IdP) and expects specific authentication strength, methods, or recentness for specific functions, the application verifies this using the information returned by the IdP. For example, if OIDC is used, this might be achieved by validating ID Token claims such as 'acr', 'amr', and 'auth_time' (if present). If the IdP does not provide this information, the application must have a documented fallback approach that assumes that the minimum strength authentication mechanism was used (for example, single-factor authentication using username and password).", "level": "2", "explanation": "This requirement ensures that applications relying on external Identity Providers (IdPs) for authentication rigorously validate the strength and methods of authentication used. It emphasizes the importance of checking specific claims in the ID Token to ensure that the authentication performed by the IdP meets the application's security requirements. If the IdP fails to provide necessary information, the application must revert to a secure default that does not compromise security.", "threats_mitigated": ["Weak authentication", "Unauthorized access", "Identity spoofing"], "insecure_examples": ["if (idToken) { /* No validation of claims */ }", "let userAuthenticated = true; // Assuming authentication strength without checks"], "secure_examples": ["if (idToken && idToken.acr === 'high') { /* Proceed with access */ }", "let userAuthenticated = validateIdToken(idToken); // Validate claims before proceeding"], "verification_steps": ["Check if the application validates ID Token claims such as 'acr', 'amr', and 'auth_time'.", "Ensure that fallback mechanisms are documented and implemented.", "Review the handling of cases where the IdP does not provide required authentication strength information."], "common_mistakes": ["Failing to validate ID Token claims before granting access.", "Assuming that the IdP always provides strong authentication without verification.", "Neglecting to implement fallback mechanisms for cases where claims are missing."], "related_cwe": ["CWE-287", "CWE-306", "CWE-295"], "related_capec": ["CAPEC-56", "CAPEC-137", "CAPEC-159"], "attack_flow": "An attacker could exploit a failure to validate the authentication strength by using a weak IdP that does not enforce strong authentication methods. If the application does not check the claims in the ID Token, the attacker could gain unauthorized access to sensitive functions, potentially leading to data breaches or unauthorized actions within the application."}
{"chapter_id": "V7", "chapter_name": "Session Management", "section_id": "V7.1", "section_name": "Session Management Documentation", "req_id": "V7.1.1", "req_description": "Verify that the user's session inactivity timeout and absolute maximum session lifetime are documented, are appropriate in combination with other controls, and that the documentation includes justification for any deviations from NIST SP 800-63B re-authentication requirements.", "level": "2", "explanation": "This requirement ensures that there are clear guidelines and documentation regarding session management, specifically focusing on session inactivity timeouts and maximum session lifetimes. Proper documentation helps organizations maintain security standards and provides a reference for compliance with best practices, such as those outlined in NIST SP 800-63B. It also emphasizes the importance of justifying any deviations from established standards to ensure that security controls remain effective.", "threats_mitigated": ["Session hijacking", "Unauthorized access due to stale sessions", "Account takeover"], "insecure_examples": ["sessionTimeout = 0; // No timeout set", "sessionLifetime = 365; // Extremely long session lifetime without justification"], "secure_examples": ["sessionTimeout = 15; // 15 minutes inactivity timeout", "sessionLifetime = 30; // 30 days maximum session lifetime with documentation"], "verification_steps": ["Check if session timeout values are documented.", "Verify that maximum session lifetime is specified and justified.", "Ensure that documentation aligns with NIST SP 800-63B requirements.", "Review any deviations and ensure they are justified."], "common_mistakes": ["Failing to document session timeout policies.", "Setting excessively long session lifetimes without justification.", "Not aligning session management practices with established standards."], "related_cwe": ["CWE-613: Insufficient Session Expiration", "CWE-287: Improper Authentication"], "related_capec": ["CAPEC-131: Session Fixation", "CAPEC-140: Session Hijacking"], "attack_flow": "An attacker may exploit a lack of session timeout by hijacking an inactive session. If sessions remain active indefinitely, the attacker can gain unauthorized access to the user's account after they have left their device unattended. This highlights the need for documented and enforced session management policies."}
{"chapter_id": "V7", "chapter_name": "Session Management", "section_id": "V7.1", "section_name": "Session Management Documentation", "req_id": "V7.1.2", "req_description": "Verify that the documentation defines how many concurrent (parallel) sessions are allowed for one account as well as the intended behaviors and actions to be taken when the maximum number of active sessions is reached.", "level": "2", "explanation": "This requirement emphasizes the need for clear documentation regarding session management policies, specifically the limits on concurrent sessions for user accounts. It should outline how many sessions a single user can have open at the same time and the system's response when this limit is reached, such as logging out the oldest session or preventing new logins until an existing session is closed.", "threats_mitigated": ["Session fixation", "Account takeover", "Unauthorized access"], "insecure_examples": ["User can log in from multiple devices without any restrictions, leading to potential session hijacking.", "Documentation does not specify any limits on concurrent sessions, allowing unlimited access."], "secure_examples": ["The application allows a maximum of 3 concurrent sessions per user. If the limit is reached, the user will be prompted to log out from one of the existing sessions before starting a new one.", "Documentation clearly states that only two concurrent sessions are allowed and that the oldest session will be terminated if a new login occurs."], "verification_steps": ["Review the session management documentation for clarity on concurrent session limits.", "Check if the system enforces the defined limits on concurrent sessions.", "Test the application by attempting to log in from multiple devices to see if the expected behavior occurs when the limit is reached."], "common_mistakes": ["Failing to define a maximum number of concurrent sessions in the documentation.", "Not implementing any enforcement mechanism for session limits in the application.", "Assuming users will manage their sessions without guidance."], "related_cwe": ["CWE-384: Session Fixation", "CWE-287: Improper Authentication"], "related_capec": ["CAPEC-54: Session Fixation Attack", "CAPEC-139: Credential Theft"], "attack_flow": "An attacker could exploit the lack of session limit documentation and enforcement by logging into a user's account from multiple devices. If the application does not restrict concurrent sessions, the attacker could maintain access while the legitimate user is logged in, leading to potential unauthorized actions and data breaches."}
{"chapter_id": "V7", "chapter_name": "Session Management", "section_id": "V7.1", "section_name": "Session Management Documentation", "req_id": "V7.1.3", "req_description": "Verify that all systems that create and manage user sessions as part of a federated identity management ecosystem (such as SSO systems) are documented along with controls to coordinate session lifetimes, termination, and any other conditions that require re-authentication.", "level": 2, "explanation": "This requirement emphasizes the importance of having comprehensive documentation for systems that handle user sessions in a federated identity management setup. It ensures that there are clear guidelines on how sessions are created, managed, and terminated, and outlines the conditions under which users must re-authenticate. Proper documentation helps in maintaining security and compliance, and aids in the identification of potential vulnerabilities related to session management.", "threats_mitigated": ["Session hijacking", "Session fixation", "Unauthorized access due to stale sessions", "Inadequate session termination"], "insecure_examples": ["session = createSession(user); // No documentation on session management policies", "if (user.isAuthenticated()) { grantAccess(); } // No checks for session expiration or re-authentication"], "secure_examples": ["session = createSession(user); // Documented session management policies in place", "if (user.isAuthenticated() && !session.isExpired()) { grantAccess(); } // Checks for session validity"], "verification_steps": ["Review the documentation for session management policies.", "Ensure that session lifetime and termination policies are clearly defined.", "Check for conditions that require re-authentication and verify they are documented.", "Confirm that all systems involved in session management are included in the documentation."], "common_mistakes": ["Failing to document session management policies.", "Not including all systems that manage sessions in the documentation.", "Overlooking the need for re-authentication under certain conditions.", "Neglecting to update documentation when changes are made to session management."], "related_cwe": ["CWE-384: Session Fixation", "CWE-287: Improper Authentication", "CWE-287: Improper Authentication"], "related_capec": ["CAPEC-119: Session Fixation", "CAPEC-155: Session Hijacking"], "attack_flow": "An attacker may exploit inadequate documentation and controls around session management by creating a session that is not properly terminated or re-authenticated. This can lead to session hijacking, where the attacker gains unauthorized access to a user's session, potentially leading to data breaches or unauthorized actions on behalf of the user."}
{"chapter_id": "V7", "chapter_name": "Session Management", "section_id": "V7.2", "section_name": "Fundamental Session Management Security", "req_id": "V7.2.1", "req_description": "Verify that the application performs all session token verification using a trusted, backend service.", "level": "1", "explanation": "This requirement ensures that session tokens are validated by a secure and trusted backend service rather than relying on client-side validation. This prevents attackers from bypassing security checks by manipulating session tokens on the client side.", "threats_mitigated": ["Session Hijacking", "Token Forgery", "Replay Attacks"], "insecure_examples": ["if (sessionToken == localStorage.getItem('sessionToken')) { /* allow access */ }", "if (sessionToken == cookies['sessionToken']) { /* allow access */ }"], "secure_examples": ["const isValid = await backendService.verifySessionToken(sessionToken); if (isValid) { /* allow access */ }", "const isValid = await sessionVerificationService.verifyToken(sessionToken); if (isValid) { /* allow access */ }"], "verification_steps": ["Check that session token verification is performed on the server-side.", "Ensure that the backend service used for verification is trusted and secure.", "Review the implementation to confirm that no client-side validation is performed."], "common_mistakes": ["Performing session token validation on the client side.", "Using weak or predictable session tokens.", "Failing to validate session tokens against a secure backend service."], "related_cwe": ["CWE-287", "CWE-384", "CWE-352"], "related_capec": ["CAPEC-139", "CAPEC-132", "CAPEC-152"], "attack_flow": "An attacker intercepts a session token and manipulates it. If the application performs validation on the client side, the attacker can bypass security checks and gain unauthorized access. By ensuring that validation occurs on a trusted backend service, the application can effectively mitigate this risk."}
{"chapter_id": "V7", "chapter_name": "Session Management", "section_id": "V7.2", "section_name": "Fundamental Session Management Security", "req_id": "V7.2.2", "req_description": "Verify that the application uses either self-contained or reference tokens that are dynamically generated for session management, i.e. not using static API secrets and keys.", "level": 1, "explanation": "This requirement emphasizes the importance of using dynamic tokens for session management instead of static secrets. Dynamic tokens are generated for each session and can include information such as user identity and expiration time, making them more secure against replay attacks. Static tokens, on the other hand, can be easily intercepted and reused by attackers, leading to unauthorized access.", "threats_mitigated": ["Session hijacking", "Replay attacks", "Token theft", "Unauthorized access"], "insecure_examples": ["const apiSecret = 'static-secret-key';\nconst sessionToken = apiSecret + userId;", "sessionToken = '12345-ABCDE'; // Static token used for session management"], "secure_examples": ["const sessionToken = generateDynamicToken(userId); // Dynamically generated token", "sessionToken = createSelfContainedToken(userId, expirationTime); // Self-contained token with expiration"], "verification_steps": ["Check that session tokens are generated dynamically for each user session.", "Ensure that tokens are not hard-coded or static.", "Review the token generation logic to confirm it incorporates user-specific data.", "Verify that tokens have an expiration time and are invalidated after logout."], "common_mistakes": ["Using hard-coded API secrets for session management.", "Failing to invalidate tokens after logout or expiration.", "Not implementing token expiration, allowing indefinite session access."], "related_cwe": ["CWE-287", "CWE-352", "CWE-384"], "related_capec": ["CAPEC-137", "CAPEC-149", "CAPEC-153"], "attack_flow": "An attacker intercepts a static session token through network sniffing or other means. They then reuse this token to gain unauthorized access to the user's session, potentially leading to data theft, account takeover, or unauthorized actions within the application."}
{"chapter_id": "V7", "chapter_name": "Session Management", "section_id": "V7.2", "section_name": "Fundamental Session Management Security", "req_id": "V7.2.3", "req_description": "Verify that if reference tokens are used to represent user sessions, they are unique and generated using a cryptographically secure pseudo-random number generator (CSPRNG) and possess at least 128 bits of entropy.", "level": "1", "explanation": "This requirement ensures that session tokens, which are used to identify and authenticate users during their session, are generated securely. By using a CSPRNG, the tokens are less predictable and thus harder for attackers to guess or forge. A minimum of 128 bits of entropy ensures a vast number of possible tokens, making brute-force attacks impractical.", "threats_mitigated": ["Session fixation", "Session hijacking", "Predictable session tokens"], "insecure_examples": ["String token = 'abc123'; // Hardcoded token, predictable and insecure.", "String token = UUID.randomUUID().toString(); // UUIDs are not sufficiently random for session tokens."], "secure_examples": ["SecureRandom secureRandom = new SecureRandom();\nbyte[] token = new byte[16];\nsecureRandom.nextBytes(token);\nString sessionToken = Base64.getUrlEncoder().withoutPadding().encodeToString(token);", "byte[] token = new byte[16];\nSecureRandom secureRandom = new SecureRandom();\nsecureRandom.nextBytes(token);\nString sessionToken = new BigInteger(1, token).toString(16);"], "verification_steps": ["Check that session tokens are generated using a CSPRNG.", "Ensure that the length of the generated tokens is at least 128 bits.", "Review the session token generation code for any hardcoded values or predictable patterns."], "common_mistakes": ["Using predictable algorithms like `Math.random()` for token generation.", "Hardcoding session tokens or using easily guessable values.", "Not validating the entropy of the generated tokens."], "related_cwe": ["CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)", "CWE-384: Session Fixation", "CWE-287: Improper Authentication"], "related_capec": ["CAPEC-137: Session Fixation Attack", "CAPEC-141: Session Hijacking", "CAPEC-164: Predictable Session Token Attack"], "attack_flow": "An attacker could exploit a weak session token generation process by predicting or guessing the token value. If the attacker can obtain a valid session token, they can impersonate the user and gain unauthorized access to their account. This could lead to data theft, unauthorized actions, or further attacks on the application."}
{"chapter_id": "V7", "chapter_name": "Session Management", "section_id": "V7.2", "section_name": "Fundamental Session Management Security", "req_id": "V7.2.4", "req_description": "Verify that the application generates a new session token on user authentication, including re-authentication, and terminates the current session token.", "level": 1, "explanation": "This requirement ensures that whenever a user successfully authenticates, a new session token is created. This prevents session fixation attacks, where an attacker could use a known session token to impersonate a user. By terminating the old session token, the application ensures that the previous session cannot be reused, thus enhancing the security of user sessions.", "threats_mitigated": ["Session fixation", "Session hijacking", "Replay attacks"], "insecure_examples": [{"code": "if (userAuthenticated) {\n    // Reuse existing session token\n    sessionToken = currentSessionToken;\n}"}, {"code": "function authenticateUser(username, password) {\n    if (validCredentials(username, password)) {\n        return currentSessionToken; // No new token generated\n    }\n}"}], "secure_examples": [{"code": "if (userAuthenticated) {\n    // Generate a new session token\n    sessionToken = generateNewSessionToken();\n    terminateCurrentSessionToken();\n}"}, {"code": "function authenticateUser(username, password) {\n    if (validCredentials(username, password)) {\n        sessionToken = generateNewSessionToken(); // New token generated\n    }\n}"}], "verification_steps": ["Check if a new session token is generated upon user authentication.", "Ensure the old session token is invalidated after a new token is issued.", "Review session management code to confirm proper token handling during authentication."], "common_mistakes": ["Failing to invalidate the old session token after generating a new one.", "Reusing the same session token for multiple authentication events.", "Not generating a new session token during re-authentication."], "related_cwe": ["CWE-384", "CWE-287", "CWE-601"], "related_capec": ["CAPEC-151", "CAPEC-152"], "attack_flow": "An attacker can exploit this requirement by initially gaining access to a user's session token. If the application does not generate a new token upon authentication, the attacker can continue to use the old token, allowing them to impersonate the user. By ensuring that a new session token is generated and the old one is terminated, the application mitigates this risk."}
{"chapter_id": "V7", "chapter_name": "Session Management", "section_id": "V7.3", "section_name": "Session Timeout", "req_id": "V7.3.1", "req_description": "Verify that there is an inactivity timeout such that re-authentication is enforced according to risk analysis and documented security decisions.", "level": 2, "explanation": "This requirement ensures that user sessions are automatically terminated after a defined period of inactivity. This is critical for protecting sensitive information and preventing unauthorized access to user accounts, especially in environments where users may leave their devices unattended.", "threats_mitigated": ["Session Hijacking", "Unauthorized Access", "Account Takeover"], "insecure_examples": ["session.setTimeout(0); // No timeout set, session remains active indefinitely", "if(user.isAuthenticated()) { // User remains authenticated without timeout check }"], "secure_examples": ["session.setTimeout(15 * 60 * 1000); // Set timeout to 15 minutes of inactivity", "if(user.isAuthenticated() && !session.isTimedOut()) { // Check if session is still valid }"], "verification_steps": ["Check the session timeout settings in the application configuration.", "Review the code to ensure that session timeout logic is implemented correctly.", "Test the application by leaving a session idle and verifying that re-authentication is required after the timeout period."], "common_mistakes": ["Failing to implement a session timeout policy.", "Setting the timeout period too long, allowing for potential unauthorized access.", "Not informing users about session timeout policies."], "related_cwe": ["CWE-613", "CWE-287"], "related_capec": ["CAPEC-137", "CAPEC-153"], "attack_flow": "An attacker may exploit a lack of session timeout by gaining access to an unattended device where a user is logged in. If the session remains active indefinitely, the attacker can perform actions on behalf of the user, potentially leading to data theft or unauthorized transactions."}
{"chapter_id": "V7", "chapter_name": "Session Management", "section_id": "V7.3", "section_name": "Session Timeout", "req_id": "V7.3.2", "req_description": "Verify that there is an absolute maximum session lifetime such that re-authentication is enforced according to risk analysis and documented security decisions.", "level": 2, "explanation": "This requirement emphasizes the importance of setting a maximum session lifetime to mitigate risks associated with session hijacking and unauthorized access. By enforcing a maximum duration for user sessions, applications can ensure that even if a session token is compromised, the window of opportunity for an attacker is limited. Re-authentication should be triggered when the session expires, requiring users to provide their credentials again to regain access.", "threats_mitigated": ["Session Hijacking", "Unauthorized Access", "Replay Attacks"], "insecure_examples": ["session.setMaxInactiveInterval(0); // No timeout set", "session.setMaxInactiveInterval(Integer.MAX_VALUE); // Session never expires"], "secure_examples": ["session.setMaxInactiveInterval(30 * 60); // Session expires after 30 minutes of inactivity", "session.setMaxInactiveInterval(15 * 60); // Session expires after 15 minutes of inactivity for sensitive actions"], "verification_steps": ["Check the session management configuration for maximum session lifetime settings.", "Verify that session timeout is documented and aligns with security policies.", "Test the application to ensure sessions expire as configured after inactivity.", "Confirm that re-authentication is required after session expiration."], "common_mistakes": ["Setting an excessively long session timeout without justification.", "Failing to enforce re-authentication after session expiration.", "Not considering the sensitivity of actions when defining session timeout."], "related_cwe": ["CWE-613: Insufficient Session Expiration", "CWE-287: Improper Authentication"], "related_capec": ["CAPEC-134: Session Fixation", "CAPEC-138: Session Hijacking"], "attack_flow": "An attacker could exploit a long-lived session by stealing a session token through various means (e.g., XSS, network sniffing). If the session does not expire within a reasonable timeframe, the attacker can use the stolen token to gain unauthorized access to the user's account until the session eventually expires."}
{"chapter_id": "V7", "chapter_name": "Session Management", "section_id": "V7.4", "section_name": "Session Termination", "req_id": "V7.4.1", "req_description": "Verify that when session termination is triggered (such as logout or expiration), the application disallows any further use of the session. For reference tokens or stateful sessions, this means invalidating the session data at the application backend. Applications using self-contained tokens will need a solution such as maintaining a list of terminated tokens, disallowing tokens produced before a per-user date and time or rotating a per-user signing key.", "level": "1", "explanation": "This requirement ensures that once a user logs out or their session expires, they cannot continue to use that session to access resources or perform actions. This is crucial for preventing unauthorized access to user accounts and sensitive data. The application must effectively invalidate session identifiers and tokens to ensure that any subsequent requests using those identifiers are rejected. For self-contained tokens, additional measures must be implemented to track and manage their validity.", "threats_mitigated": ["Session Hijacking", "Replay Attacks", "Unauthorized Access"], "insecure_examples": [{"code": "session.invalidate(); // Insecure: Doesn't handle token invalidation properly"}, {"code": "if (user.isLoggedIn()) { // Insecure: Allows continued access after logout\n  // perform actions\n}"}], "secure_examples": [{"code": "session.invalidate(); // Secure: Properly invalidates session on logout"}, {"code": "if (!user.isLoggedIn()) { // Secure: Prevents actions if user is logged out\n  // deny access\n}"}], "verification_steps": ["Check that session termination is implemented on logout.", "Ensure that session tokens are invalidated at the backend.", "Verify that expired tokens cannot be reused.", "Test for unauthorized access after session termination."], "common_mistakes": ["Failing to invalidate session tokens on logout.", "Not handling token expiration correctly.", "Using weak session identifiers that can be easily guessed."], "related_cwe": ["CWE-613", "CWE-287", "CWE-384"], "related_capec": ["CAPEC-137", "CAPEC-155", "CAPEC-160"], "attack_flow": "An attacker exploits this requirement by capturing a valid session token or identifier. If the application does not properly invalidate the session upon logout or expiration, the attacker can reuse the token to gain unauthorized access to the user's account and perform actions as if they were the legitimate user."}
{"chapter_id": "V7", "chapter_name": "Session Management", "section_id": "V7.4", "section_name": "Session Termination", "req_id": "V7.4.2", "req_description": "Verify that the application terminates all active sessions when a user account is disabled or deleted (such as an employee leaving the company).", "level": 1, "explanation": "This requirement ensures that when a user account is disabled or deleted, all sessions associated with that account are immediately terminated. This is crucial for preventing unauthorized access to sensitive information or functionalities that the user might have had before their account was disabled. It helps maintain the integrity of the application by ensuring that former users cannot access their accounts or any related data post-termination.", "threats_mitigated": ["Unauthorized access", "Account takeovers", "Data breaches", "Insider threats"], "insecure_examples": [{"code": "if (user.isDeleted()) { /* Do not terminate sessions */ }"}, {"code": "sessionManager.keepActiveSessions(userId);"}], "secure_examples": [{"code": "if (user.isDeleted()) { sessionManager.terminateAllSessions(userId); }"}, {"code": "userAccountService.disableAccount(userId); sessionManager.terminateAllSessions(userId);"}], "verification_steps": ["Check if all sessions are terminated when a user account is disabled.", "Verify that no active sessions remain for deleted accounts.", "Test the application with a user account that has been disabled to ensure access is denied.", "Review session management logs for proper termination events."], "common_mistakes": ["Failing to implement session termination logic upon account deletion.", "Not considering session persistence mechanisms that may keep sessions alive.", "Overlooking the need to notify users of session termination."], "related_cwe": ["CWE-613: Insufficient Session Expiration", "CWE-287: Improper Authentication"], "related_capec": ["CAPEC-145: Session Fixation", "CAPEC-148: Session Hijacking"], "attack_flow": "An attacker could exploit this requirement by gaining access to a disabled or deleted user's session token. If the application does not terminate the session upon account deletion, the attacker can impersonate the user, access sensitive data, and perform unauthorized actions within the application."}
{"chapter_id": "V7", "chapter_name": "Session Management", "section_id": "V7.4", "section_name": "Session Termination", "req_id": "V7.4.3", "req_description": "Verify that the application gives the option to terminate all other active sessions after a successful change or removal of any authentication factor (including password change via reset or recovery and, if present, an MFA settings update).", "level": 2, "explanation": "This requirement ensures that when a user changes their authentication factors, such as their password or multi-factor authentication settings, all other active sessions are invalidated. This is crucial for preventing unauthorized access to the user's account from other devices or sessions that may have been compromised.", "threats_mitigated": ["Session Hijacking", "Account Takeover", "Unauthorized Access"], "insecure_examples": ["User changes password, but other sessions remain active. User's account can be accessed from another device.", "MFA settings are updated, but previous sessions are not terminated, allowing an attacker to exploit the old session."], "secure_examples": ["Upon password change, the system automatically terminates all other active sessions and prompts the user to log in again.", "After updating MFA settings, all previous sessions are invalidated, requiring re-authentication."], "verification_steps": ["Check if the application provides an option to log out of all other sessions after authentication factor changes.", "Test the functionality by changing the password and verifying that all other sessions are terminated.", "Verify that the user is logged out from all devices except the one they are currently using after a change."], "common_mistakes": ["Failing to provide an option to terminate other sessions.", "Not implementing session invalidation properly, allowing old sessions to remain active.", "Overlooking the need to terminate sessions after MFA changes."], "related_cwe": ["CWE-384: Session Fixation", "CWE-287: Improper Authentication"], "related_capec": ["CAPEC-139: Session Fixation Attack", "CAPEC-113: Credential Theft"], "attack_flow": "An attacker gains access to a user's account through an active session. If the user changes their password or MFA settings without terminating the active sessions, the attacker can continue to access the account using the old session, leading to potential data theft or unauthorized actions."}
{"chapter_id": "V7", "chapter_name": "Session Management", "section_id": "V7.4", "section_name": "Session Termination", "req_id": "V7.4.4", "req_description": "Verify that all pages that require authentication have easy and visible access to logout functionality.", "level": 2, "explanation": "This requirement ensures that users can easily find and use the logout functionality on any authenticated page. This is crucial for maintaining session security, as it allows users to terminate their sessions promptly, especially on shared or public devices.", "threats_mitigated": ["Session Hijacking", "Unauthorized Access", "Session Fixation"], "insecure_examples": ["<a href=\"/logout\" style=\"display:none;\">Logout</a>", "<button onclick=\"logout()\">Logout</button> <!-- No visible indication of logout on the page -->"], "secure_examples": ["<a href=\"/logout\" style=\"display:block;\">Logout</a>", "<button onclick=\"logout()\" aria-label=\"Logout\">Logout</button> <!-- Clearly visible and accessible -->"], "verification_steps": ["Check that all authenticated pages have a logout link or button.", "Ensure the logout functionality is clearly labeled and easily accessible.", "Test the logout functionality to confirm it terminates the session properly."], "common_mistakes": ["Placing the logout link in a non-obvious location.", "Using misleading labels for the logout functionality.", "Failing to provide a logout option on certain authenticated pages."], "related_cwe": ["CWE-613: Insufficient Session Expiration", "CWE-287: Improper Authentication"], "related_capec": ["CAPEC-69: Session Fixation", "CAPEC-137: Session Hijacking"], "attack_flow": "An attacker may exploit the absence of a visible logout option by leaving a user session open on a shared device. If another user accesses the same device, they can perform actions as the authenticated user, leading to unauthorized access and potential data breaches."}
{"chapter_id": "V7", "chapter_name": "Session Management", "section_id": "V7.4", "section_name": "Session Termination", "req_id": "V7.4.5", "req_description": "Verify that application administrators are able to terminate active sessions for an individual user or for all users.", "level": "2", "explanation": "This requirement ensures that administrators have the capability to terminate sessions that may be compromised or no longer valid. This is crucial for maintaining control over user sessions and preventing unauthorized access.", "threats_mitigated": ["Session Hijacking", "Unauthorized Access", "Account Takeover"], "insecure_examples": [{"code": "if (user.isAdmin()) { user.sessionActive = true; } // No termination capability"}, {"code": "function logoutAllUsers() { // No admin session termination logic }"}], "secure_examples": [{"code": "if (user.isAdmin()) { terminateUserSession(targetUser); } // Correctly terminates session"}, {"code": "function logoutAllUsers() { users.forEach(user => terminateUserSession(user)); } // Admin can terminate all sessions"}], "verification_steps": ["Check if the application provides an interface for administrators to view active sessions.", "Verify that administrators can select an individual user and terminate their session.", "Ensure that there is an option for terminating all active sessions.", "Test the functionality to confirm that terminated sessions cannot be reused."], "common_mistakes": ["Failing to implement a session termination feature for administrators.", "Not logging session termination actions for audit purposes.", "Providing session termination without proper authorization checks."], "related_cwe": ["CWE-384: Session Fixation", "CWE-287: Improper Authentication"], "related_capec": ["CAPEC-32: Session Fixation Attack", "CAPEC-156: Session Hijacking"], "attack_flow": "An attacker could exploit the lack of session termination capabilities by hijacking a user's session. If the administrator cannot terminate the session, the attacker can maintain unauthorized access, potentially leading to data breaches or unauthorized actions within the application."}
{"chapter_id": "V7", "chapter_name": "Session Management", "section_id": "V7.5", "section_name": "Defenses Against Session Abuse", "req_id": "V7.5.1", "req_description": "Verify that the application requires full re-authentication before allowing modifications to sensitive account attributes which may affect authentication such as email address, phone number, MFA configuration, or other information used in account recovery.", "level": 2, "explanation": "This requirement ensures that any changes to critical account information, which can impact how a user authenticates and recovers their account, are safeguarded by requiring the user to re-enter their credentials. This adds an additional layer of security, preventing unauthorized users from making sensitive changes even if they have gained access to the user's session.", "threats_mitigated": ["Account takeover", "Session hijacking", "Social engineering attacks"], "insecure_examples": [{"code": "user.updateAccountInfo({ email: 'newemail@example.com' }); // No re-authentication required"}, {"code": "if (user.isLoggedIn()) { user.changeMFASettings(); } // Changes made without verifying identity"}], "secure_examples": [{"code": "if (user.isLoggedIn()) { if (user.requestReAuthentication()) { user.updateAccountInfo({ email: 'newemail@example.com' }); } }"}, {"code": "if (user.isLoggedIn()) { if (user.requestReAuthentication()) { user.changeMFASettings(); } }"}], "verification_steps": ["Check if the application prompts for re-authentication when modifying sensitive account attributes.", "Ensure that the re-authentication process requires the correct credentials.", "Review the code to confirm that sensitive changes are gated behind the re-authentication check."], "common_mistakes": ["Assuming that session state is sufficient for sensitive actions.", "Failing to implement re-authentication for all sensitive attribute changes.", "Not providing clear user feedback during the re-authentication process."], "related_cwe": ["CWE-287", "CWE-384"], "related_capec": ["CAPEC-115", "CAPEC-151"], "attack_flow": "An attacker who has gained access to a user's session could exploit the lack of re-authentication to change sensitive account details, such as email or phone number, without the user's consent. This could lead to account recovery being redirected to an attacker's control, allowing them to take over the account completely."}
{"chapter_id": "V7", "chapter_name": "Session Management", "section_id": "V7.5", "section_name": "Defenses Against Session Abuse", "req_id": "V7.5.2", "req_description": "Verify that users are able to view and (having authenticated again with at least one factor) terminate any or all currently active sessions.", "level": "2", "explanation": "This requirement ensures that users have control over their active sessions. By allowing users to view their active sessions, they can identify any unauthorized access. Re-authenticating before session termination adds an additional layer of security, ensuring that only the legitimate user can perform this action.", "threats_mitigated": ["Session Hijacking", "Account Takeover", "Unauthorized Access"], "insecure_examples": [{"code": "if (user.isAuthenticated()) {\n    // Allow session termination without re-authentication\n    terminateSession(user.sessionId);\n}"}, {"code": "function viewActiveSessions(user) {\n    return user.sessions; // No check for user identity\n}"}], "secure_examples": [{"code": "if (user.isAuthenticated() && user.hasReauthenticated()) {\n    terminateSession(user.sessionId);\n}"}, {"code": "function viewActiveSessions(user) {\n    if (user.isAuthenticated()) {\n        return user.sessions;\n    }\n    throw new Error('User not authenticated');\n}"}], "verification_steps": ["Check if the user can view their active sessions.", "Verify that the user must re-authenticate before terminating any session.", "Ensure that the session termination process is logged for auditing purposes.", "Test for unauthorized session termination attempts."], "common_mistakes": ["Allowing session termination without re-authentication.", "Failing to provide users with visibility of their active sessions.", "Not logging session termination actions."], "related_cwe": ["CWE-384: Session Fixation", "CWE-287: Improper Authentication"], "related_capec": ["CAPEC-137: Session Fixation", "CAPEC-113: Session Hijacking"], "attack_flow": "An attacker who has gained access to a user's session can exploit this vulnerability by performing actions on behalf of the user. If the user is unaware of the active session, they may not realize their account is compromised. By not requiring re-authentication, the attacker can easily terminate the user's legitimate sessions, locking them out of their account."}
{"chapter_id": "V7", "chapter_name": "Session Management", "section_id": "V7.5", "section_name": "Defenses Against Session Abuse", "req_id": "V7.5.3", "req_description": "Verify that the application requires further authentication with at least one factor or secondary verification before performing highly sensitive transactions or operations.", "level": "3", "explanation": "This requirement mandates that applications implement additional layers of authentication for sensitive actions, such as fund transfers, account settings changes, or access to sensitive data. This can involve methods such as SMS verification, email confirmation, or biometric authentication, ensuring that even if a session is compromised, the attacker cannot easily perform critical actions without additional proof of identity.", "threats_mitigated": ["Session hijacking", "Unauthorized access to sensitive operations", "Account takeover"], "insecure_examples": [{"code": "if (user.isLoggedIn()) {\n    performSensitiveOperation();\n}"}, {"code": "executeTransaction(userId, amount); // No additional checks"}], "secure_examples": [{"code": "if (user.isLoggedIn() && user.requiresAdditionalAuth()) {\n    requestSecondaryVerification();\n    if (verifyUser()) {\n        performSensitiveOperation();\n    }\n}"}, {"code": "if (user.isLoggedIn()) {\n    requestTwoFactorAuth();\n    if (verifyTwoFactorCode()) {\n        executeTransaction(userId, amount);\n    }\n}"}], "verification_steps": ["Check if sensitive operations require additional authentication.", "Review the implementation of secondary verification methods.", "Ensure that the application logs all authentication attempts for sensitive actions.", "Test the application to verify that sensitive actions cannot be performed without additional authentication."], "common_mistakes": ["Relying solely on session tokens without additional checks.", "Not implementing timeouts or limits on sensitive operations.", "Failing to notify users of sensitive actions taken on their accounts."], "related_cwe": ["CWE-287", "CWE-384", "CWE-352"], "related_capec": ["CAPEC-137", "CAPEC-111", "CAPEC-134"], "attack_flow": "An attacker who has hijacked a user's session can attempt to perform sensitive operations. If the application does not require additional authentication, the attacker can execute these operations directly. However, if the application enforces secondary verification, the attacker will be thwarted as they will not have access to the required authentication factor, thereby preventing unauthorized actions."}
{"chapter_id": "V7", "chapter_name": "Session Management", "section_id": "V7.6", "section_name": "Federated Re-authentication", "req_id": "V7.6.1", "req_description": "Verify that session lifetime and termination between Relying Parties (RPs) and Identity Providers (IdPs) behave as documented, requiring re-authentication as necessary such as when the maximum time between IdP authentication events is reached.", "level": "2", "explanation": "This requirement ensures that the session management between Relying Parties (RPs) and Identity Providers (IdPs) is consistent with the documented policies regarding session lifetime and termination. It mandates that users are required to re-authenticate after a specified period of inactivity or after certain events, thereby enhancing security by reducing the risk of unauthorized access due to stale sessions.", "threats_mitigated": ["Session Hijacking", "Replay Attacks", "Unauthorized Access", "Credential Theft"], "insecure_examples": [{"code": "session.setMaxInactiveInterval(3600); // Insecure: No re-authentication required after 1 hour"}, {"code": "if (user.isAuthenticated()) { // No check for session expiration\n  // Allow access\n}"}], "secure_examples": [{"code": "session.setMaxInactiveInterval(3600); // Secure: Require re-authentication after 1 hour of inactivity\nif (session.isExpired()) {\n  redirectToLogin();\n}"}, {"code": "if (user.isAuthenticated() && !session.isExpired()) {\n  // Allow access\n} else {\n  redirectToLogin();\n}"}], "verification_steps": ["Check the session timeout configuration in the application.", "Review the documentation for session management policies.", "Verify that re-authentication is enforced after the session timeout.", "Test the application to ensure that sessions expire as expected.", "Ensure that logs are maintained for session events."], "common_mistakes": ["Not enforcing re-authentication after session expiration.", "Failing to document session management policies clearly.", "Ignoring session management during code reviews.", "Setting overly long session lifetimes without justification."], "related_cwe": ["CWE-613", "CWE-287", "CWE-384"], "related_capec": ["CAPEC-146", "CAPEC-155", "CAPEC-162"], "attack_flow": "An attacker could exploit a stale session by hijacking an existing session token that has not been invalidated or requiring re-authentication. If the session lifetime is not managed properly, the attacker can gain unauthorized access to sensitive information or perform actions on behalf of the legitimate user without their consent."}
{"chapter_id": "V7", "chapter_name": "Session Management", "section_id": "V7.6", "section_name": "Federated Re-authentication", "req_id": "V7.6.2", "req_description": "Verify that creation of a session requires either the user's consent or an explicit action, preventing the creation of new application sessions without user interaction.", "level": "2", "explanation": "This requirement ensures that any new session created within the application must be initiated by the user, either through explicit consent (such as clicking a button) or through a defined action (like logging in). This prevents unauthorized session creation that could lead to session hijacking or other security breaches.", "threats_mitigated": ["Session hijacking", "Unauthorized access", "Account takeover"], "insecure_examples": [{"code": "session.create(); // Session created without user consent"}, {"code": "if (user.isLoggedIn()) { session.create(); } // Implicit session creation"}], "secure_examples": [{"code": "if (userConsentGiven) { session.create(); } // Session created with user consent"}, {"code": "if (user.isLoggedIn() && user.hasClickedLoginButton()) { session.create(); } // Explicit action required"}], "verification_steps": ["Check if session creation is triggered by a user action.", "Review code to ensure there are no implicit session creations.", "Verify that user consent is logged and managed appropriately.", "Test the application to ensure sessions cannot be created without user interaction."], "common_mistakes": ["Assuming that a user is logged in implies consent for session creation.", "Creating sessions automatically upon certain events without user confirmation.", "Not providing clear user interfaces for consent."], "related_cwe": ["CWE-384: Session Fixation", "CWE-287: Improper Authentication"], "related_capec": ["CAPEC-137: Session Fixation Attack", "CAPEC-146: Session Hijacking"], "attack_flow": "An attacker could exploit this requirement by tricking the application into creating a session without user consent, potentially allowing them to gain unauthorized access to the user's account. For example, if a session is created automatically upon a certain event (like a background process), the attacker could leverage this to hijack the session and perform actions as the user."}
{"chapter_id": "V8", "chapter_name": "Authorization", "section_id": "V8.1", "section_name": "Authorization Documentation", "req_id": "V8.1.1", "req_description": "Verify that authorization documentation defines rules for restricting function-level and data-specific access based on consumer permissions and resource attributes.", "level": "1", "explanation": "This requirement emphasizes the need for comprehensive documentation that outlines how access to various functions and data is controlled based on user roles and the attributes of the resources being accessed. It ensures that there are clear guidelines on who can access what, under which conditions, thereby preventing unauthorized access.", "threats_mitigated": ["Unauthorized access to sensitive data", "Privilege escalation", "Data leakage", "Insecure direct object references"], "insecure_examples": ["if (user.role == 'admin') { accessResource(); }", "function accessResource() { return data; } // No checks on user permissions"], "secure_examples": ["if (checkUserPermissions(user, resource)) { accessResource(); }", "function accessResource() { if (!userHasAccess(user, resource)) throw new Error('Access Denied'); return data; }"], "verification_steps": ["Review authorization documentation for completeness.", "Check that all functions and data access points are covered.", "Ensure that user roles and resource attributes are clearly defined.", "Verify that the documentation aligns with the actual implementation."], "common_mistakes": ["Failing to update documentation when access rules change.", "Not considering all user roles and resource types.", "Assuming default permissions without explicit documentation."], "related_cwe": ["CWE-284", "CWE-863", "CWE-732"], "related_capec": ["CAPEC-137", "CAPEC-145", "CAPEC-151"], "attack_flow": "An attacker may exploit inadequate authorization documentation by attempting to access functions or data they are not permitted to. If the rules are not clearly defined or enforced, the attacker can leverage this gap to gain unauthorized access, potentially leading to data breaches or privilege escalation."}
{"chapter_id": "V8", "chapter_name": "Authorization", "section_id": "V8.1", "section_name": "Authorization Documentation", "req_id": "V8.1.2", "req_description": "Verify that authorization documentation defines rules for field-level access restrictions (both read and write) based on consumer permissions and resource attributes. Note that these rules might depend on other attribute values of the relevant data object, such as state or status.", "level": 2, "explanation": "This requirement emphasizes the importance of having clear and comprehensive documentation that outlines how access to specific fields within a resource is controlled based on the permissions assigned to users. It ensures that only authorized users can read or modify sensitive data fields, taking into account the context of the data, such as its current state or status.", "threats_mitigated": ["Unauthorized access to sensitive data", "Data leakage", "Privilege escalation"], "insecure_examples": ["if (user.role == 'admin') { resource.field = newValue; }", "if (user.id == resource.ownerId) { return resource.sensitiveField; }"], "secure_examples": ["if (hasPermission(user, resource, 'write', 'field')) { resource.field = newValue; }", "if (hasPermission(user, resource, 'read', 'sensitiveField')) { return resource.sensitiveField; }"], "verification_steps": ["Review the authorization documentation for clarity and completeness.", "Check that field-level access rules are defined for all sensitive fields.", "Ensure that rules account for user permissions and relevant resource attributes.", "Verify that the implementation adheres to the documented rules."], "common_mistakes": ["Failing to document all field-level access rules.", "Not considering all relevant attributes when defining access rules.", "Assuming that role-based access is sufficient without field-level checks."], "related_cwe": ["CWE-284: Improper Access Control", "CWE-200: Information Exposure"], "related_capec": ["CAPEC-137: Access Control Violation", "CAPEC-139: Bypassing Access Control Mechanisms"], "attack_flow": "An attacker may exploit insufficient field-level access restrictions by manipulating requests to access or modify fields they are not authorized to interact with. This could involve crafting requests that bypass checks or exploiting flaws in the authorization logic to gain access to sensitive information or perform unauthorized actions."}
{"chapter_id": "V8", "chapter_name": "Authorization", "section_id": "V8.1", "section_name": "Authorization Documentation", "req_id": "V8.1.3", "req_description": "Verify that the application's documentation defines the environmental and contextual attributes (including but not limited to, time of day, user location, IP address, or device) that are used in the application to make security decisions, including those pertaining to authentication and authorization.", "level": 3, "explanation": "This requirement emphasizes the importance of having comprehensive documentation that outlines how various contextual factors influence security decisions within the application. It ensures that developers and security teams understand the criteria used for authorization and authentication, which can vary based on environmental conditions.", "threats_mitigated": ["Unauthorized access due to lack of contextual awareness", "Insider threats exploiting knowledge of security decisions", "Misconfiguration of security settings based on environmental factors"], "insecure_examples": ["if (user.isAuthenticated()) { grantAccess(); } // No checks for user location or time of day", "if (user.role == 'admin') { grantAccess(); } // Ignores contextual factors like IP address"], "secure_examples": ["if (user.isAuthenticated() && isValidContext(user)) { grantAccess(); } // Checks user context", "if (user.role == 'admin' && isAccessAllowedBasedOnContext(user)) { grantAccess(); } // Validates contextual factors"], "verification_steps": ["Review application documentation for completeness regarding environmental and contextual attributes.", "Ensure that security decisions are clearly linked to specific contextual factors.", "Check for examples of how different contexts affect authorization outcomes.", "Verify that the documentation is up-to-date with the current application logic."], "common_mistakes": ["Failing to document the contextual factors influencing security decisions.", "Assuming that all users have the same access rights without considering their context.", "Neglecting to update documentation when security policies change."], "related_cwe": ["CWE-20: Improper Input Validation", "CWE-284: Improper Access Control", "CWE-639: Authorization Bypass Through User-Controlled Key"], "related_capec": ["CAPEC-118: Exploiting Insecure Access Control Mechanisms", "CAPEC-154: Bypassing Access Control Mechanisms", "CAPEC-164: Exploiting Contextual Information to Gain Unauthorized Access"], "attack_flow": "An attacker may exploit a lack of documentation on contextual attributes to gain unauthorized access. For instance, if they understand that the application does not check for user location or time of day, they can manipulate their access by using a VPN or changing their device settings, thus bypassing security checks that should be in place."}
{"chapter_id": "V8", "chapter_name": "Authorization", "section_id": "V8.1", "section_name": "Authorization Documentation", "req_id": "V8.1.4", "req_description": "Verify that authentication and authorization documentation defines how environmental and contextual factors are used in decision-making, in addition to function-level, data-specific, and field-level authorization. This should include the attributes evaluated, thresholds for risk, and actions taken (e.g., allow, challenge, deny, step-up authentication).", "level": "3", "explanation": "This requirement emphasizes the importance of comprehensive documentation that outlines how various factors influence authorization decisions. It ensures that developers and security teams understand not just the basic authorization logic, but also how contextual variables (like user location, device type, and time of access) can impact access control decisions. Proper documentation helps maintain consistency in authorization processes and aids in audits and compliance.", "threats_mitigated": ["Unauthorized access due to insufficient context evaluation", "Privilege escalation through misconfigured authorization rules", "Bypassing of security controls due to lack of contextual awareness"], "insecure_examples": ["if (user.role == 'admin') { allowAccess(); }", "if (user.isAuthenticated) { allowAccess(); } // No context checks"], "secure_examples": ["if (user.role == 'admin' && isContextualCheckPassed(user)) { allowAccess(); }", "if (user.isAuthenticated && isUserLocationAllowed(user) && isAccessTimeAllowed(user)) { allowAccess(); }"], "verification_steps": ["Review the authorization documentation for completeness.", "Check if environmental factors are considered in the authorization logic.", "Ensure that thresholds for risk are clearly defined.", "Verify that actions taken for different contexts are documented (allow, challenge, deny).", "Confirm that the documentation is updated regularly and reflects current practices."], "common_mistakes": ["Failing to document all contextual factors affecting authorization.", "Over-relying on role-based access control without considering environmental context.", "Not updating documentation as the application evolves or new threats emerge."], "related_cwe": ["CWE-285: Improper Authorization", "CWE-775: Missing Required Cryptographic Step"], "related_capec": ["CAPEC-137: Bypass Access Control Mechanism", "CAPEC-146: Exploit Role-Based Access Control"], "attack_flow": "An attacker may exploit insufficiently documented authorization processes by manipulating environmental factors (e.g., changing their IP address or using a different device) to gain unauthorized access. If the documentation does not clearly outline how these factors are evaluated, the attacker can exploit the gaps in the authorization logic to escalate privileges or access sensitive data."}
{"chapter_id": "V8", "chapter_name": "Authorization", "section_id": "V8.2", "section_name": "General Authorization Design", "req_id": "V8.2.1", "req_description": "Verify that the application ensures that function-level access is restricted to consumers with explicit permissions.", "level": "1", "explanation": "This requirement mandates that applications implement strict access controls at the function level. This means that users should only be able to access functionalities that they have been explicitly granted permission to use. This is crucial in preventing unauthorized access to sensitive operations within the application.", "threats_mitigated": ["Unauthorized access", "Privilege escalation", "Data leakage"], "insecure_examples": ["if (user.isAdmin()) { performSensitiveAction(); }", "performAction(); // No checks on user permissions"], "secure_examples": ["if (user.hasPermission('performSensitiveAction')) { performSensitiveAction(); }", "if (user.hasPermission('actionName')) { performAction(); }"], "verification_steps": ["Review code for explicit permission checks before sensitive actions.", "Ensure that role-based access control (RBAC) or similar mechanisms are implemented.", "Test the application with users having different roles to verify access restrictions.", "Check for any hardcoded permissions that may bypass checks."], "common_mistakes": ["Assuming that users with certain roles automatically have access to all functions.", "Not validating user permissions at every function entry point.", "Using outdated or overly broad permission checks."], "related_cwe": ["CWE-284", "CWE-863", "CWE-732"], "related_capec": ["CAPEC-135", "CAPEC-146", "CAPEC-153"], "attack_flow": "An attacker may exploit this requirement by attempting to access functions without proper authorization. For example, if the application lacks checks for user permissions, an attacker could manipulate requests to perform sensitive actions or access restricted data, leading to data breaches or unauthorized operations."}
{"chapter_id": "V8", "chapter_name": "Authorization", "section_id": "V8.2", "section_name": "General Authorization Design", "req_id": "V8.2.2", "req_description": "Verify that the application ensures that data-specific access is restricted to consumers with explicit permissions to specific data items to mitigate insecure direct object reference (IDOR) and broken object level authorization (BOLA).", "level": "1", "explanation": "This requirement emphasizes the importance of implementing strict access controls at the data level. It ensures that users can only access data they are explicitly permitted to view or manipulate. This is crucial to prevent unauthorized access to sensitive information and to enforce the principle of least privilege.", "threats_mitigated": ["Insecure Direct Object Reference (IDOR)", "Broken Object Level Authorization (BOLA)"], "insecure_examples": ["GET /api/user/12345 - User with ID 12345 can access this endpoint without any checks, potentially accessing another user's data.", "GET /api/documents/secret_report - An unauthorized user can access sensitive documents by guessing the document ID."], "secure_examples": ["GET /api/user/12345 - Implement authorization checks to ensure the requesting user has permission to access user ID 12345.", "GET /api/documents/secret_report - Ensure that only users with the 'view_document' permission can access this endpoint."], "verification_steps": ["Review the access control mechanisms in place for data access.", "Check that permissions are explicitly defined for each data item.", "Test endpoints with different user roles to ensure unauthorized access is denied.", "Verify that access logs are maintained and reviewed for suspicious access patterns."], "common_mistakes": ["Assuming that user authentication alone is sufficient for data access control.", "Not implementing role-based access controls (RBAC) properly.", "Hardcoding permissions in the code rather than managing them through a centralized policy."], "related_cwe": ["CWE-284", "CWE-639"], "related_capec": ["CAPEC-137", "CAPEC-140"], "attack_flow": "An attacker discovers that the application does not properly validate user permissions for accessing specific data items. They manipulate the request to access data items belonging to other users, leading to unauthorized data exposure or manipulation."}
{"chapter_id": "V8", "chapter_name": "Authorization", "section_id": "V8.2", "section_name": "General Authorization Design", "req_id": "V8.2.3", "req_description": "Verify that the application ensures that field-level access is restricted to consumers with explicit permissions to specific fields to mitigate broken object property level authorization (BOPLA).", "level": 2, "explanation": "This requirement emphasizes the necessity of implementing field-level access controls within an application. It ensures that users can only access data fields for which they have been granted explicit permissions. This is crucial in preventing unauthorized access to sensitive information and maintaining data integrity. Developers must carefully design their authorization mechanisms to check permissions at the field level, rather than relying solely on object-level permissions.", "threats_mitigated": ["Unauthorized data access", "Data leakage", "Privilege escalation"], "insecure_examples": [{"code": "userProfile = getUserProfile(userId); return userProfile.sensitiveField;"}, {"code": "if (user.role == 'admin') { return userProfile.sensitiveField; }"}], "secure_examples": [{"code": "if (userHasPermission(userId, 'view_sensitive_field')) { return userProfile.sensitiveField; }"}, {"code": "if (checkFieldAccess(userId, 'sensitiveField')) { return userProfile.sensitiveField; }"}], "verification_steps": ["Review the code for field-level access checks.", "Ensure that permission checks are implemented for each sensitive field.", "Test with users having different roles to confirm access restrictions.", "Check for any hardcoded permissions that might bypass checks."], "common_mistakes": ["Assuming that object-level permissions are sufficient for field-level access.", "Neglecting to implement checks for all sensitive fields.", "Using overly broad permissions that allow access to more fields than intended."], "related_cwe": ["CWE-732", "CWE-285", "CWE-20"], "related_capec": ["CAPEC-137", "CAPEC-147", "CAPEC-152"], "attack_flow": "An attacker may attempt to access sensitive fields by manipulating requests or responses, exploiting the lack of proper field-level authorization checks. If the application does not verify whether the user has explicit permissions for each field, the attacker could gain unauthorized access to sensitive information, leading to data breaches or privilege escalation."}
{"chapter_id": "V8", "chapter_name": "Authorization", "section_id": "V8.2", "section_name": "General Authorization Design", "req_id": "V8.2.4", "req_description": "Verify that adaptive security controls based on a consumer's environmental and contextual attributes (such as time of day, location, IP address, or device) are implemented for authentication and authorization decisions, as defined in the application's documentation. These controls must be applied when the consumer tries to start a new session and also during an existing session.", "level": "3", "explanation": "This requirement emphasizes the need for dynamic security measures that adapt to the context in which a user is operating. It ensures that authentication and authorization are not static but consider various factors that could indicate a change in risk level. For example, if a user logs in from a new location or device, additional verification steps should be triggered to ensure the legitimacy of the session.", "threats_mitigated": ["Account takeover", "Session hijacking", "Unauthorized access", "Fraudulent transactions"], "insecure_examples": [{"code": "if (userLocation == predefinedLocation) { authenticateUser(); }", "description": "This code only checks if the user is in a predefined location without considering other contextual factors."}, {"code": "sessionActive = true; // No checks for device or IP address", "description": "This code assumes that once a session is active, it remains secure without further checks."}], "secure_examples": [{"code": "if (isUserContextValid(user)) { authenticateUser(); }", "description": "This code checks multiple contextual attributes before authenticating the user."}, {"code": "if (sessionActive && isContextChanged(user)) { requireReauthentication(); }", "description": "This code checks for changes in context during an active session and requires reauthentication if needed."}], "verification_steps": ["Review application documentation for adaptive security controls.", "Check if contextual attributes are being evaluated during authentication.", "Test the application by logging in from different locations and devices.", "Verify that additional authentication steps are triggered based on context changes.", "Ensure that session management includes checks for context during active sessions."], "common_mistakes": ["Failing to implement context checks for session management.", "Hardcoding location or device checks without flexibility.", "Not updating security controls based on evolving threats or user behavior.", "Assuming that once authenticated, a user is always secure."], "related_cwe": ["CWE-287", "CWE-384", "CWE-295"], "related_capec": ["CAPEC-138", "CAPEC-149", "CAPEC-153"], "attack_flow": "An attacker may exploit this requirement by using stolen credentials from a user who is logged in from a trusted location. If the application does not check for contextual changes, the attacker could gain unauthorized access to sensitive information or perform actions on behalf of the user without triggering any security alerts."}
{"chapter_id": "V8", "chapter_name": "Authorization", "section_id": "V8.3", "section_name": "Operation Level Authorization", "req_id": "V8.3.1", "req_description": "Verify that the application enforces authorization rules at a trusted service layer and doesn't rely on controls that an untrusted consumer could manipulate, such as client-side JavaScript.", "level": 1, "explanation": "This requirement emphasizes that authorization decisions must be made on the server side, ensuring that only authenticated and authorized users can access specific operations or resources. Client-side checks can be easily bypassed, so the application must enforce rules in a secure environment.", "threats_mitigated": ["Unauthorized access", "Privilege escalation", "Data leakage"], "insecure_examples": ["if (user.isAdmin) { performAdminAction(); } // Client-side check", "fetch('/api/data').then(response => { if (response.userCanAccess) { displayData(); } }); // Trusting client-side response"], "secure_examples": ["if (user.hasPermission('admin')) { performAdminAction(); } // Server-side check", "fetch('/api/data', { headers: { 'Authorization': token } }).then(response => { if (response.status === 200) { displayData(); } }); // Server validates access"], "verification_steps": ["Check that all authorization logic is implemented on the server side.", "Review API endpoints to ensure they validate user permissions before processing requests.", "Ensure that sensitive operations require explicit authorization checks."], "common_mistakes": ["Implementing authorization checks only in client-side code.", "Assuming that user roles are secure without server validation.", "Failing to review third-party libraries for secure authorization practices."], "related_cwe": ["CWE-285", "CWE-863", "CWE-352"], "related_capec": ["CAPEC-137", "CAPEC-113"], "attack_flow": "An attacker may manipulate client-side code or API requests to bypass authorization checks, gaining access to restricted operations or data. By exploiting these vulnerabilities, they can perform actions that should be restricted to authorized users, leading to potential data breaches or unauthorized actions."}
{"chapter_id": "V8", "chapter_name": "Authorization", "section_id": "V8.3", "section_name": "Operation Level Authorization", "req_id": "V8.3.2", "req_description": "Verify that changes to values on which authorization decisions are made are applied immediately. Where changes cannot be applied immediately, (such as when relying on data in self-contained tokens), there must be mitigating controls to alert when a consumer performs an action when they are no longer authorized to do so and revert the change. Note that this alternative would not mitigate information leakage.", "level": "3", "explanation": "This requirement ensures that any changes to user permissions or roles are reflected in real-time within the application. If a user's permissions are altered, the application must immediately enforce these changes to prevent unauthorized access. In scenarios where immediate application of changes isn't feasible (like with JWTs), the application must implement controls to detect and respond to unauthorized actions, although this may not prevent data exposure.", "threats_mitigated": ["Privilege Escalation", "Unauthorized Access", "Data Breaches"], "insecure_examples": ["if (user.isAdmin) { performSensitiveAction(); } // User's role is cached and not updated immediately", "const token = getTokenFromLocalStorage(); if (token.isValid) { allowAccess(); } // Token validity not checked in real-time"], "secure_examples": ["if (user.isAdmin && user.permissionsUpdated) { performSensitiveAction(); } // Check for updated permissions", "const token = getTokenFromLocalStorage(); if (isTokenValid(token)) { allowAccess(); } // Validate token against server in real-time"], "verification_steps": ["Review the implementation of authorization checks to ensure they reflect the latest user permissions.", "Check for mechanisms that invalidate or refresh tokens upon permission changes.", "Test scenarios where user permissions are altered and verify immediate enforcement of changes."], "common_mistakes": ["Caching user permissions without a mechanism to invalidate or refresh them.", "Relying solely on client-side checks for authorization without server validation.", "Failing to handle race conditions where permissions might change between checks."], "related_cwe": ["CWE-285", "CWE-863"], "related_capec": ["CAPEC-137", "CAPEC-142"], "attack_flow": "An attacker exploits this requirement by manipulating their permissions or roles in a way that the application does not immediately recognize. For instance, if an attacker is granted admin privileges and the application does not immediately apply this change, they could perform sensitive actions before the change is detected, leading to unauthorized access or data manipulation."}
{"chapter_id": "V8", "chapter_name": "Authorization", "section_id": "V8.3", "section_name": "Operation Level Authorization", "req_id": "V8.3.3", "req_description": "Verify that access to an object is based on the originating subject's (e.g. consumer's) permissions, not on the permissions of any intermediary or service acting on their behalf. For example, if a consumer calls a web service using a self-contained token for authentication, and the service then requests data from a different service, the second service will use the consumer's token, rather than a machine-to-machine token from the first service, to make permission decisions.", "level": 3, "explanation": "This requirement emphasizes the importance of ensuring that authorization checks are performed based on the original user's permissions rather than relying on intermediary services. This prevents scenarios where an intermediary service could inadvertently grant access based on its own permissions, which may not align with the original user's rights.", "threats_mitigated": ["Privilege escalation", "Unauthorized access", "Data leakage"], "insecure_examples": [{"code": "function getData(userToken) {\n  // Using service token instead of user token\n  let serviceToken = getServiceToken();\n  return callExternalService(serviceToken);\n}"}, {"code": "function fetchData() {\n  // Assuming the intermediary service has the right permissions\n  return callServiceWithIntermediaryToken();\n}"}], "secure_examples": [{"code": "function getData(userToken) {\n  // Using user token for authorization\n  return callExternalService(userToken);\n}"}, {"code": "function fetchData(userToken) {\n  // Explicitly passing user token for permissions check\n  return callServiceWithUserToken(userToken);\n}"}], "verification_steps": ["Review the code to ensure that the original user's token is used for authorization checks.", "Check that all intermediary services pass the user's credentials when making downstream requests.", "Ensure that there are no hardcoded tokens or service tokens being used for authorization."], "common_mistakes": ["Using service tokens instead of user tokens for downstream service calls.", "Assuming that an intermediary service has the same permissions as the original user.", "Not validating the user's permissions in every service call."], "related_cwe": ["CWE-285", "CWE-863"], "related_capec": ["CAPEC-154", "CAPEC-162"], "attack_flow": "An attacker could exploit this requirement by obtaining a valid user token and making requests to an intermediary service. If the intermediary service does not validate the user's permissions and instead uses its own service token to access resources, the attacker may gain unauthorized access to sensitive data or functionality that they should not have access to."}
{"chapter_id": "V8", "chapter_name": "Authorization", "section_id": "V8.4", "section_name": "Other Authorization Considerations", "req_id": "V8.4.1", "req_description": "Verify that multi-tenant applications use cross-tenant controls to ensure consumer operations will never affect tenants with which they do not have permissions to interact.", "level": 2, "explanation": "This requirement emphasizes the need for robust access controls in multi-tenant applications. It ensures that actions performed by one tenant do not inadvertently impact other tenants. This is crucial for maintaining data integrity and privacy across different user groups within the same application environment.", "threats_mitigated": ["Data leakage between tenants", "Unauthorized access to tenant data", "Denial of service to other tenants", "Privilege escalation"], "insecure_examples": [{"code": "if (user.tenantId == resource.tenantId) { performAction(); }", "description": "This check only verifies tenant ID but does not enforce strict access controls, allowing potential cross-tenant actions."}, {"code": "allowAllActions(user);", "description": "This function allows all actions for a user without validating their tenant permissions."}], "secure_examples": [{"code": "if (user.hasPermission(resource) && user.tenantId == resource.tenantId) { performAction(); }", "description": "This check ensures that the user has the necessary permissions and that the tenant IDs match before performing any action."}, {"code": "restrictActionsToTenant(user);", "description": "This function restricts user actions based on their tenant permissions, ensuring no cross-tenant interference."}], "verification_steps": ["Review the access control logic for tenant-specific resources.", "Ensure that tenant IDs are validated against user permissions in all API endpoints.", "Check for proper error handling that does not expose tenant information.", "Conduct penetration testing to simulate cross-tenant access attempts."], "common_mistakes": ["Failing to implement strict validation checks for tenant IDs.", "Using shared resources without proper isolation mechanisms.", "Assuming that user authentication alone is sufficient for access control.", "Not logging tenant-specific access attempts for audit purposes."], "related_cwe": ["CWE-284", "CWE-200", "CWE-269"], "related_capec": ["CAPEC-137", "CAPEC-149", "CAPEC-162"], "attack_flow": "An attacker could exploit a lack of cross-tenant controls by crafting requests that manipulate tenant identifiers, allowing them to access or modify data belonging to other tenants. This could lead to unauthorized data exposure, service disruptions, or data integrity issues."}
{"chapter_id": "V8", "chapter_name": "Authorization", "section_id": "V8.4", "section_name": "Other Authorization Considerations", "req_id": "V8.4.2", "req_description": "Verify that access to administrative interfaces incorporates multiple layers of security, including continuous consumer identity verification, device security posture assessment, and contextual risk analysis, ensuring that network location or trusted endpoints are not the sole factors for authorization even though they may reduce the likelihood of unauthorized access.", "level": "3", "explanation": "This requirement emphasizes the importance of implementing a multi-faceted approach to securing administrative interfaces. It requires not only verifying the identity of users but also assessing the security posture of their devices and considering the context of their access attempts. This means that simply being on a trusted network or using a trusted device is not enough; continuous verification mechanisms must be in place to adapt to changing risks.", "threats_mitigated": ["Unauthorized access to administrative interfaces", "Session hijacking", "Man-in-the-middle attacks", "Credential theft"], "insecure_examples": ["if (user.isAdmin() && user.isOnTrustedNetwork()) { grantAccess(); }", "if (user.device.isSecure() && user.isFromTrustedLocation()) { allowAdminAccess(); }"], "secure_examples": ["if (user.isAdmin() && verifyIdentity(user) && assessDeviceSecurity(user.device) && analyzeContextualRisk(user)) { grantAccess(); }", "if (user.isAdmin() && continuousIdentityVerification(user) && deviceSecurityPostureAssessment(user.device) && contextualRiskAnalysis(user)) { allowAdminAccess(); }"], "verification_steps": ["Check if continuous identity verification mechanisms are implemented.", "Ensure device security posture assessments are performed before granting access.", "Review contextual risk analysis processes for administrative access.", "Verify that access is not solely based on network location or trusted endpoints."], "common_mistakes": ["Relying solely on IP whitelisting for access control.", "Neglecting to verify the security posture of devices accessing sensitive interfaces.", "Failing to implement continuous verification processes.", "Assuming that trusted networks automatically imply secure access."], "related_cwe": ["CWE-287", "CWE-306", "CWE-200"], "related_capec": ["CAPEC-137", "CAPEC-139", "CAPEC-154"], "attack_flow": "An attacker may initially gain access to a trusted network or use a compromised device that appears secure. If the system only checks for network location or device trust without continuous identity verification or contextual risk analysis, the attacker can exploit this weakness to access administrative interfaces, potentially leading to unauthorized actions or data breaches."}
{"chapter_id": "V9", "chapter_name": "Self-contained Tokens", "section_id": "V9.1", "section_name": "Token source and integrity", "req_id": "V9.1.1", "req_description": "Verify that self-contained tokens are validated using their digital signature or MAC to protect against tampering before accepting the token's contents.", "level": "1", "explanation": "This requirement emphasizes the importance of validating self-contained tokens to ensure that they have not been altered or tampered with. By using digital signatures or Message Authentication Codes (MAC), applications can verify the authenticity and integrity of the token's contents before processing any associated data. This is crucial for maintaining the security of the application and protecting user data.", "threats_mitigated": ["Token tampering", "Replay attacks", "Unauthorized data access"], "insecure_examples": [{"code": "if (tokenIsValid(token)) {\n    // Process token contents\n}", "description": "This example checks if the token is valid without verifying its digital signature or MAC."}], "secure_examples": [{"code": "if (isValidToken(token) && verifySignature(token)) {\n    // Process token contents\n}", "description": "This example validates the token and verifies its digital signature before processing."}], "verification_steps": ["Check that the token is signed with a secure algorithm.", "Verify the digital signature or MAC of the token.", "Ensure the token has not expired.", "Confirm that the token was issued by a trusted source."], "common_mistakes": ["Neglecting to validate the token's signature or MAC.", "Using weak or outdated algorithms for signing tokens.", "Failing to check the expiration of the token."], "related_cwe": ["CWE-347", "CWE-346", "CWE-20"], "related_capec": ["CAPEC-159", "CAPEC-130"], "attack_flow": "An attacker can create a forged token by manipulating its contents. If the application does not validate the digital signature or MAC, it may accept the tampered token as valid, allowing the attacker to gain unauthorized access or perform actions on behalf of a legitimate user."}
{"chapter_id": "V9", "chapter_name": "Self-contained Tokens", "section_id": "V9.1", "section_name": "Token source and integrity", "req_id": "V9.1.2", "req_description": "Verify that only algorithms on an allowlist can be used to create and verify self-contained tokens, for a given context. The allowlist must include the permitted algorithms, ideally only either symmetric or asymmetric algorithms, and must not include the 'None' algorithm. If both symmetric and asymmetric must be supported, additional controls will be needed to prevent key confusion.", "level": "1", "explanation": "This requirement ensures that only trusted algorithms are utilized for creating and verifying tokens, which are crucial for maintaining the integrity and confidentiality of the data they protect. By enforcing an allowlist, developers can mitigate risks associated with the use of weak or outdated algorithms that could be exploited by attackers.", "threats_mitigated": ["Algorithm substitution attacks", "Token forgery", "Replay attacks", "Key confusion attacks"], "insecure_examples": ["token = jwt.encode(payload, key, algorithm='None')", "token = jwt.encode(payload, key, algorithm='HS256') // without allowlist check"], "secure_examples": ["allowed_algorithms = ['HS256', 'RS256']; if algorithm in allowed_algorithms: token = jwt.encode(payload, key, algorithm=algorithm)", "if algorithm not in allowed_algorithms: raise ValueError('Algorithm not allowed')"], "verification_steps": ["Check if the algorithm used for token creation is on the allowlist.", "Ensure the 'None' algorithm is not present in the allowlist.", "Verify that the implementation correctly restricts algorithms based on context.", "Review code for potential key confusion issues when supporting both symmetric and asymmetric algorithms."], "common_mistakes": ["Failing to validate the algorithm against an allowlist.", "Including weak algorithms like 'None' in the allowlist.", "Not considering key confusion when using both symmetric and asymmetric algorithms."], "related_cwe": ["CWE-327: Use of a Broken or Risky Cryptographic Algorithm", "CWE-330: Use of Insufficiently Random Values", "CWE-20: Improper Input Validation"], "related_capec": ["CAPEC-137: Token Manipulation", "CAPEC-157: Token Replay", "CAPEC-158: Token Forgery"], "attack_flow": "An attacker could exploit this requirement by using a weak or unapproved algorithm to create a token, allowing them to forge or manipulate tokens without detection. If the application does not validate the algorithm against an allowlist, the attacker can create a token that appears valid but does not adhere to the security standards, leading to unauthorized access or data breaches."}
{"chapter_id": "V9", "chapter_name": "Self-contained Tokens", "section_id": "V9.1", "section_name": "Token source and integrity", "req_id": "V9.1.3", "req_description": "Verify that key material that is used to validate self-contained tokens is from trusted pre-configured sources for the token issuer, preventing attackers from specifying untrusted sources and keys. For JWTs and other JWS structures, headers such as 'jku', 'x5u', and 'jwk' must be validated against an allowlist of trusted sources.", "level": "1", "explanation": "This requirement ensures that the keys used to validate tokens, such as JWTs, are sourced only from trusted locations. By validating these sources against a pre-defined allowlist, the application mitigates the risk of accepting malicious tokens that could compromise the integrity and authenticity of the application's security mechanisms.", "threats_mitigated": ["Token forgery", "Man-in-the-middle attacks", "Key compromise", "Replay attacks"], "insecure_examples": [{"code": "const token = jwt.verify(tokenString, getKeyFromHeader(tokenString));", "description": "This code retrieves the key directly from the token header without validation, allowing attackers to specify untrusted sources."}, {"code": "const token = jwt.verify(tokenString, someDynamicKeyProvider());", "description": "Using a dynamic key provider without ensuring it is from a trusted source can lead to accepting compromised keys."}], "secure_examples": [{"code": "const key = getKeyFromHeader(tokenString);\nif (!isTrustedSource(key)) throw new Error('Untrusted key source');\nconst token = jwt.verify(tokenString, key);", "description": "This code checks if the key is from a trusted source before using it to verify the token."}, {"code": "const trustedKey = getTrustedKey();\nconst token = jwt.verify(tokenString, trustedKey);", "description": "Here, the key is retrieved from a trusted source, ensuring it is safe to use."}], "verification_steps": ["Check that all keys used for token validation are sourced from a predefined allowlist.", "Ensure that the application rejects any tokens with headers pointing to untrusted sources.", "Review the implementation of key retrieval to confirm it validates against trusted sources."], "common_mistakes": ["Failing to validate the source of keys used for token verification.", "Using hardcoded keys that are not managed or rotated properly.", "Not maintaining an up-to-date allowlist of trusted key sources."], "related_cwe": ["CWE-347", "CWE-295", "CWE-287"], "related_capec": ["CAPEC-137", "CAPEC-145", "CAPEC-149"], "attack_flow": "An attacker can exploit this requirement by crafting a malicious token with a header that points to an untrusted key source. If the application does not validate this source against a trusted allowlist, it may accept the token as valid, allowing the attacker to gain unauthorized access or perform actions on behalf of legitimate users."}
{"chapter_id": "V9", "chapter_name": "Self-contained Tokens", "section_id": "V9.2", "section_name": "Token content", "req_id": "V9.2.1", "req_description": "Verify that, if a validity time span is present in the token data, the token and its content are accepted only if the verification time is within this validity time span. For example, for JWTs, the claims 'nbf' and 'exp' must be verified.", "level": "1", "explanation": "This requirement ensures that tokens, such as JSON Web Tokens (JWTs), are only considered valid if they are used within a specified time frame. The 'nbf' (not before) and 'exp' (expiration) claims in a JWT define the time period during which the token is valid. If a token is used outside this period, it should be rejected to prevent unauthorized access.", "threats_mitigated": ["Replay attacks", "Token misuse", "Unauthorized access due to expired tokens"], "insecure_examples": [{"code": "const token = jwt.verify(tokenString, secret); // No validity check"}, {"code": "if (token.nbf < currentTime) { /* accept token */ } // Incorrect logic"}], "secure_examples": [{"code": "const token = jwt.verify(tokenString, secret); if (token.exp < currentTime) { throw new Error('Token expired'); }"}, {"code": "if (token.nbf > currentTime) { throw new Error('Token not yet valid'); }"}], "verification_steps": ["Check if the token contains 'nbf' and 'exp' claims.", "Ensure the current time is within the range defined by 'nbf' and 'exp'.", "Reject the token if it is outside the validity period."], "common_mistakes": ["Failing to check the 'nbf' and 'exp' claims.", "Incorrectly implementing time comparisons (e.g., using string comparison instead of numeric).", "Assuming tokens are always valid without checking their validity period."], "related_cwe": ["CWE-287", "CWE-20"], "related_capec": ["CAPEC-137", "CAPEC-157"], "attack_flow": "An attacker obtains a valid token and attempts to use it after its expiration time. If the application does not verify the 'exp' claim, the attacker can gain unauthorized access. The attacker may also try to use a token before its 'nbf' time, exploiting a lack of checks to gain access prematurely."}
{"chapter_id": "V9", "chapter_name": "Self-contained Tokens", "section_id": "V9.2", "section_name": "Token content", "req_id": "V9.2.2", "req_description": "Verify that the service receiving a token validates the token to be the correct type and is meant for the intended purpose before accepting the token's contents. For example, only access tokens can be accepted for authorization decisions and only ID Tokens can be used for proving user authentication.", "level": 2, "explanation": "This requirement ensures that tokens are validated based on their type and intended use. It prevents a service from mistakenly accepting a token that is not appropriate for the operation being performed, such as using an ID token for authorization instead of an access token. Proper validation helps maintain the integrity and security of the authentication and authorization processes.", "threats_mitigated": ["Token misuse", "Unauthorized access", "Privilege escalation", "Session hijacking"], "insecure_examples": ["if (token.type === 'ID_TOKEN') { /* process token */ }", "if (token.isValid()) { /* accept token */ }"], "secure_examples": ["if (token.type === 'ACCESS_TOKEN' && token.isValid()) { /* process token for authorization */ }", "if (token.type === 'ID_TOKEN' && token.isValid()) { /* process token for authentication */ }"], "verification_steps": ["Check that the token validation logic distinguishes between token types.", "Ensure that only appropriate tokens are processed based on the operation.", "Review the code for any hardcoded token types that may lead to vulnerabilities.", "Test with various token types to ensure incorrect types are rejected."], "common_mistakes": ["Failing to check the token type before processing.", "Using ID tokens for authorization instead of access tokens.", "Assuming all tokens are valid without proper validation checks."], "related_cwe": ["CWE-287", "CWE-20", "CWE-352"], "related_capec": ["CAPEC-137", "CAPEC-134", "CAPEC-118"], "attack_flow": "An attacker may obtain a valid ID token and attempt to use it as an access token for unauthorized actions. If the service does not validate the token type, it may accept the ID token, allowing the attacker to gain unauthorized access to resources or perform actions they should not be permitted to."}
{"chapter_id": "V9", "chapter_name": "Self-contained Tokens", "section_id": "V9.2", "section_name": "Token content", "req_id": "V9.2.3", "req_description": "Verify that the service only accepts tokens which are intended for use with that service (audience). For JWTs, this can be achieved by validating the 'aud' claim against an allowlist defined in the service.", "level": 2, "explanation": "This requirement ensures that tokens are only accepted if they are specifically meant for the service. This is crucial for preventing unauthorized access and ensuring that tokens are not reused across different services. By validating the 'aud' claim in JWTs, the service can confirm that the token was issued for its intended audience, thus mitigating risks associated with token misuse.", "threats_mitigated": ["Token reuse across services", "Unauthorized access to services", "Token forgery"], "insecure_examples": [{"code": "if (tokenIsValid(token)) { /* process request */ }", "description": "This code does not validate the 'aud' claim, allowing tokens from other services to be accepted."}, {"code": "const payload = decodeJWT(token); if (payload) { /* process request */ }", "description": "This code blindly processes the token without checking if the 'aud' claim matches the service."}], "secure_examples": [{"code": "const payload = decodeJWT(token); if (payload && payload.aud === 'my_service') { /* process request */ }", "description": "This code checks the 'aud' claim to ensure the token is intended for this service."}, {"code": "const payload = decodeJWT(token); if (payload && isValidAudience(payload.aud)) { /* process request */ }", "description": "This code validates the 'aud' claim against an allowlist before processing the request."}], "verification_steps": ["Check if the service validates the 'aud' claim in JWTs.", "Ensure that the allowed audiences are properly defined and managed.", "Review code to confirm that tokens are not accepted if the 'aud' claim does not match."], "common_mistakes": ["Failing to validate the 'aud' claim in tokens.", "Using hardcoded audience values instead of a configurable allowlist.", "Not handling tokens from other services properly, leading to security vulnerabilities."], "related_cwe": ["CWE-287", "CWE-20", "CWE-352"], "related_capec": ["CAPEC-151", "CAPEC-154"], "attack_flow": "An attacker obtains a valid token from a different service and sends it to the target service. If the target service does not validate the 'aud' claim, it will accept the token, granting the attacker unauthorized access. This could lead to data breaches or unauthorized actions within the service."}
{"chapter_id": "V9", "chapter_name": "Self-contained Tokens", "section_id": "V9.2", "section_name": "Token content", "req_id": "V9.2.4", "req_description": "Verify that, if a token issuer uses the same private key for issuing tokens to different audiences, the issued tokens contain an audience restriction that uniquely identifies the intended audiences. This will prevent a token from being reused with an unintended audience. If the audience identifier is dynamically provisioned, the token issuer must validate these audiences in order to make sure that they do not result in audience impersonation.", "level": 2, "explanation": "This requirement ensures that tokens issued by a service are bound to specific audiences, preventing misuse of tokens across different contexts. By including an audience restriction, the issuer can ensure that even if the same private key is used, the tokens can only be used by the intended recipient, thereby mitigating risks associated with token replay attacks and audience impersonation.", "threats_mitigated": ["Token replay attacks", "Audience impersonation", "Unauthorized access due to token misuse"], "insecure_examples": [{"code": "const token = jwt.sign({ userId: user.id }, privateKey); // No audience restriction"}, {"code": "const token = jwt.sign({ userId: user.id, aud: 'default' }, privateKey); // Hardcoded audience"}], "secure_examples": [{"code": "const token = jwt.sign({ userId: user.id, aud: 'specificAudience' }, privateKey); // Audience specified"}, {"code": "const token = jwt.sign({ userId: user.id, aud: dynamicAudience }, privateKey); // Validated dynamic audience"}], "verification_steps": ["Check that tokens include an audience claim.", "Verify that the audience claim is unique to the intended audience.", "Ensure that audience identifiers are validated if dynamically provisioned.", "Review token issuance code for hardcoded audience values."], "common_mistakes": ["Using the same audience value for multiple contexts.", "Not validating dynamically provisioned audience identifiers.", "Omitting audience claims from the token altogether."], "related_cwe": ["CWE-287", "CWE-20", "CWE-352"], "related_capec": ["CAPEC-137", "CAPEC-145", "CAPEC-148"], "attack_flow": "An attacker obtains a token issued for one audience and attempts to use it in a different context. If the token does not have an audience restriction, the attacker can impersonate the legitimate user, gaining unauthorized access to resources intended for the original audience."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.1", "section_name": "Generic OAuth and OIDC Security", "req_id": "V10.1.1", "req_description": "Verify that tokens are only sent to components that strictly need them. For example, when using a backend-for-frontend pattern for browser-based JavaScript applications, access and refresh tokens shall only be accessible for the backend.", "level": 2, "explanation": "This requirement emphasizes the principle of least privilege, ensuring that tokens, which can grant access to sensitive resources, are only transmitted to components that require them for their operations. This minimizes the risk of token leakage and unauthorized access. In a typical setup, access tokens should not be exposed to the client-side code, but rather managed by the backend server that can securely handle them.", "threats_mitigated": ["Token leakage", "Unauthorized access", "Cross-Site Scripting (XSS)", "Man-in-the-Middle (MitM) attacks"], "insecure_examples": [{"code": "fetch('https://api.example.com/data', { headers: { 'Authorization': 'Bearer ' + accessToken } });", "description": "Access token is sent directly from the client-side JavaScript."}, {"code": "const refreshToken = localStorage.getItem('refreshToken');", "description": "Refresh token is stored in local storage, making it accessible to any script on the page."}], "secure_examples": [{"code": "const response = await fetch('/api/data', { method: 'POST', body: JSON.stringify({ data }), credentials: 'include' });", "description": "The backend handles the token without exposing it to the client."}, {"code": "const secureFetch = async () => { const response = await fetch('/api/refresh-token', { method: 'POST', credentials: 'include' }); };", "description": "Refresh token is handled by the backend, and the client only interacts with the backend endpoint."}], "verification_steps": ["Check that access tokens are not stored in client-side storage (e.g., localStorage, sessionStorage).", "Verify that tokens are only sent in requests made from the backend.", "Review the application architecture to ensure a backend-for-frontend pattern is implemented correctly.", "Ensure that token handling is done over secure channels (HTTPS)."], "common_mistakes": ["Storing tokens in client-side storage like localStorage or sessionStorage.", "Sending tokens directly from the client-side to APIs without backend mediation.", "Not using secure cookies for storing session identifiers or tokens."], "related_cwe": ["CWE-200", "CWE-287", "CWE-319"], "related_capec": ["CAPEC-140", "CAPEC-146", "CAPEC-160"], "attack_flow": "An attacker could exploit a vulnerability in the client-side code (e.g., XSS) to access tokens stored in client-side storage. If tokens are sent directly to APIs from the client, the attacker can intercept these tokens during transmission (e.g., via MitM attacks) and use them to gain unauthorized access to resources."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.1", "section_name": "Generic OAuth and OIDC Security", "req_id": "V10.1.2", "req_description": "Verify that the client only accepts values from the authorization server (such as the authorization code or ID Token) if these values result from an authorization flow that was initiated by the same user agent session and transaction. This requires that client-generated secrets, such as the proof key for code exchange (PKCE) 'code_verifier', 'state' or OIDC 'nonce', are not guessable, are specific to the transaction, and are securely bound to both the client and the user agent session in which the transaction was started.", "level": 2, "explanation": "This requirement ensures that the client application only processes authorization responses that are legitimate and originate from the same user interaction that initiated the authorization request. By using mechanisms like PKCE and ensuring that values such as 'state' and 'nonce' are unique and unpredictable, the client can mitigate the risk of attacks such as authorization code interception and replay attacks.", "threats_mitigated": ["Authorization code interception", "Replay attacks", "Cross-site request forgery (CSRF)", "Session fixation"], "insecure_examples": ["if (receivedState !== expectedState) { reject(); } // No validation of session origin", "const token = getTokenFromUrl(); // Accepting token without validating its origin"], "secure_examples": ["if (receivedState === expectedState && isSameSession()) { proceed(); }", "const token = validateAndGetTokenFromUrl(); // Validates token against session and origin"], "verification_steps": ["Check that the 'state' parameter is used and validated on the client side.", "Ensure that the 'nonce' is unique for each authorization request.", "Verify that PKCE is implemented correctly with non-guessable 'code_verifier'.", "Confirm that the client only accepts tokens from the expected authorization server."], "common_mistakes": ["Failing to validate the 'state' parameter properly.", "Using predictable values for 'nonce' or 'code_verifier'.", "Not binding the authorization flow to a specific user agent session.", "Ignoring the importance of session management in OAuth flows."], "related_cwe": ["CWE-287", "CWE-352", "CWE-384"], "related_capec": ["CAPEC-143", "CAPEC-154", "CAPEC-154"], "attack_flow": "An attacker may initiate an authorization request and capture the authorization code or ID token. If the client does not validate the 'state' or 'nonce', the attacker can replay these values in a different session, gaining unauthorized access to the user's account. By ensuring that these parameters are tied to the original session and are not guessable, the client can prevent such attacks."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.2", "section_name": "OAuth Client", "req_id": "V10.2.1", "req_description": "Verify that, if the code flow is used, the OAuth client has protection against browser-based request forgery attacks, commonly known as cross-site request forgery (CSRF), which trigger token requests, either by using proof key for code exchange (PKCE) functionality or checking the 'state' parameter that was sent in the authorization request.", "level": "2", "explanation": "This requirement ensures that OAuth clients are protected from CSRF attacks that can occur during the authorization code flow. By implementing PKCE or validating the 'state' parameter, the client can confirm that the request is legitimate and originated from the user who initiated the authorization process. This is crucial to prevent attackers from hijacking the authorization process and obtaining tokens without the user's consent.", "threats_mitigated": ["Cross-Site Request Forgery (CSRF)", "Token Theft", "Session Hijacking"], "insecure_examples": ["if (request.method == 'POST') { token = request.token; } // No CSRF protection", "const redirectUri = request.query.redirect_uri; // Missing state validation"], "secure_examples": ["if (request.method == 'POST' && validateCSRF(request.csrfToken)) { token = request.token; }", "const state = generateState(); // Generate a unique state parameter"], "verification_steps": ["Check if PKCE is implemented for authorization code flow.", "Verify that the 'state' parameter is generated and validated.", "Ensure that CSRF tokens are used and validated for requests."], "common_mistakes": ["Not implementing PKCE when using authorization code flow.", "Failing to validate the 'state' parameter.", "Using predictable values for 'state' parameter."], "related_cwe": ["CWE-352", "CWE-694"], "related_capec": ["CAPEC-137", "CAPEC-154"], "attack_flow": "An attacker can exploit this requirement by tricking a user into clicking a malicious link that sends a request to the OAuth server to exchange an authorization code for an access token. If the client does not validate the 'state' parameter or implement PKCE, the attacker can obtain the access token without the user's consent, leading to unauthorized access to protected resources."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.2", "section_name": "OAuth Client", "req_id": "V10.2.2", "req_description": "Verify that, if the OAuth client can interact with more than one authorization server, it has a defense against mix-up attacks. For example, it could require that the authorization server return the 'iss' parameter value and validate it in the authorization response and the token response.", "level": "2", "explanation": "This requirement ensures that OAuth clients are capable of distinguishing between different authorization servers to prevent mix-up attacks, where an attacker could exploit the client's inability to validate the source of the response. By validating the 'iss' (issuer) parameter, the client can confirm that the response it receives is from a trusted authorization server, thereby mitigating the risk of accepting tokens or responses from malicious sources.", "threats_mitigated": ["Mix-up attacks", "Token replay attacks", "Phishing attacks"], "insecure_examples": [{"code": "response = oauthClient.getAuthorizationResponse();\n// No validation of issuer\n", "description": "The client accepts any response without validating the 'iss' parameter."}, {"code": "if (response.token) {\n    // Process token without checking issuer\n}", "description": "The client processes the token without verifying its source."}], "secure_examples": [{"code": "response = oauthClient.getAuthorizationResponse();\nif (response.iss !== expectedIssuer) {\n    throw new Error('Invalid issuer');\n}", "description": "The client checks the 'iss' parameter against the expected issuer before processing."}, {"code": "if (response.token && response.iss === expectedIssuer) {\n    // Process token securely\n}", "description": "The client only processes the token if the issuer is valid."}], "verification_steps": ["Check that the OAuth client validates the 'iss' parameter in the authorization response.", "Ensure that the client has a list of trusted authorization servers.", "Review the code for any instances where the issuer validation might be bypassed.", "Test the client with responses from both valid and invalid authorization servers."], "common_mistakes": ["Failing to validate the 'iss' parameter in the responses.", "Hardcoding issuer values instead of using a configurable list.", "Assuming that all responses from the same domain are valid."], "related_cwe": ["CWE-20", "CWE-287", "CWE-295"], "related_capec": ["CAPEC-137", "CAPEC-148", "CAPEC-164"], "attack_flow": "An attacker can exploit a mix-up attack by sending a response from a malicious authorization server to the OAuth client. If the client does not validate the 'iss' parameter, it may accept the response as legitimate, allowing the attacker to gain unauthorized access or perform actions on behalf of the user."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.2", "section_name": "OAuth Client", "req_id": "V10.2.3", "req_description": "Verify that the OAuth client only requests the required scopes (or other authorization parameters) in requests to the authorization server.", "level": 3, "explanation": "This requirement ensures that the OAuth client does not request more permissions than necessary for its operation. By limiting the requested scopes, the application minimizes the potential attack surface and reduces the risk of unauthorized access to sensitive user data.", "threats_mitigated": ["Excessive data exposure", "Unauthorized access to user information", "Scope escalation attacks"], "insecure_examples": [{"code": "oauth2Client.requestAuthorization({ scopes: ['read', 'write', 'admin'] });", "description": "This example requests unnecessary 'admin' scope, which could allow access to sensitive operations."}], "secure_examples": [{"code": "oauth2Client.requestAuthorization({ scopes: ['read'] });", "description": "This example only requests the 'read' scope, which is sufficient for the application's functionality."}], "verification_steps": ["Review the OAuth client configuration to check the requested scopes.", "Ensure that the requested scopes align with the application's functionality.", "Verify that no additional scopes are requested beyond what is necessary."], "common_mistakes": ["Requesting all available scopes without justification.", "Failing to review scope requirements during application updates.", "Assuming that broader scopes are acceptable for convenience."], "related_cwe": ["CWE-284", "CWE-732"], "related_capec": ["CAPEC-137", "CAPEC-147"], "attack_flow": "An attacker could exploit excessive scopes by tricking the OAuth client into requesting more permissions than necessary. If the application is compromised, the attacker could gain access to sensitive user data or perform unauthorized actions on behalf of the user."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.3", "section_name": "OAuth Resource Server", "req_id": "V10.3.1", "req_description": "Verify that the resource server only accepts access tokens that are intended for use with that service (audience). The audience may be included in a structured access token (such as the 'aud' claim in JWT), or it can be checked using the token introspection endpoint.", "level": "2", "explanation": "This requirement ensures that the resource server validates the audience of the access token to confirm that it is meant for that specific service. This prevents tokens from being reused across different services, which could lead to unauthorized access. The audience claim is a critical part of the token's payload that indicates which service the token is intended for. If the audience does not match the expected value for the resource server, the token should be rejected.", "threats_mitigated": ["Token misuse across services", "Unauthorized access to resources", "Token replay attacks"], "insecure_examples": [{"code": "if (tokenIsValid(token)) { /* proceed with access */ }", "description": "This code does not check the audience of the token."}, {"code": "accessResource(token);", "description": "The resource server blindly accepts any valid token without audience verification."}], "secure_examples": [{"code": "if (tokenIsValid(token) && token.aud === expectedAudience) { /* proceed with access */ }", "description": "This code checks both the validity of the token and its audience."}, {"code": "const introspectionResponse = introspectToken(token); if (introspectionResponse.aud === expectedAudience) { /* proceed with access */ }", "description": "Using token introspection to validate the audience."}], "verification_steps": ["Check if the access token contains an 'aud' claim.", "Verify that the 'aud' claim matches the expected audience for the resource server.", "Ensure that tokens are validated against the token introspection endpoint if applicable.", "Review logs for any unauthorized access attempts using invalid audience tokens."], "common_mistakes": ["Failing to validate the audience claim in the access token.", "Assuming all valid tokens are safe without audience checks.", "Not implementing token introspection for additional validation."], "related_cwe": ["CWE-287", "CWE-352", "CWE-20"], "related_capec": ["CAPEC-93", "CAPEC-114"], "attack_flow": "An attacker obtains a valid access token intended for one service and attempts to use it on a different service. If the resource server does not validate the audience claim in the token, it may grant access to the attacker, allowing them to perform unauthorized actions."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.3", "section_name": "OAuth Resource Server", "req_id": "V10.3.2", "req_description": "Verify that the resource server enforces authorization decisions based on claims from the access token that define delegated authorization. If claims such as 'sub', 'scope', and 'authorization_details' are present, they must be part of the decision.", "level": 2, "explanation": "This requirement ensures that the resource server validates the claims provided in the access token before granting access to resources. Claims such as 'sub' (subject), 'scope' (permissions), and 'authorization_details' (additional authorization information) must be used to make informed decisions about whether a user has the right to access a specific resource. This prevents unauthorized access by ensuring that only users with the correct permissions can access certain functionalities or data.", "threats_mitigated": ["Unauthorized access to resources", "Privilege escalation", "Data leakage"], "insecure_examples": [{"code": "if (accessToken.isValid()) {\n    grantAccess();\n}"}, {"code": "if (userHasAccess()) {\n    return resource;\n}"}], "secure_examples": [{"code": "if (accessToken.isValid() && validateClaims(accessToken)) {\n    grantAccess();\n}"}, {"code": "if (userHasAccess() && validateClaims(accessToken)) {\n    return resource;\n}"}], "verification_steps": ["Check if the access token is validated before use.", "Ensure that claims are extracted and checked against the resource access requirements.", "Verify that the resource server logs authorization decisions and reasons for access denial.", "Review the implementation to confirm that claims like 'sub', 'scope', and 'authorization_details' are being utilized in access control logic."], "common_mistakes": ["Not validating the access token before checking claims.", "Ignoring claims when making authorization decisions.", "Assuming that valid tokens always imply valid access without checking claims."], "related_cwe": ["CWE-284", "CWE-863", "CWE-285"], "related_capec": ["CAPEC-137", "CAPEC-146", "CAPEC-153"], "attack_flow": "An attacker could obtain a valid access token and attempt to access resources without proper authorization. If the resource server does not validate claims from the access token, the attacker could exploit this oversight to gain unauthorized access to sensitive data or functions, potentially leading to data breaches or privilege escalation."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.3", "section_name": "OAuth Resource Server", "req_id": "V10.3.3", "req_description": "Verify that if an access control decision requires identifying a unique user from an access token (JWT or related token introspection response), the resource server identifies the user from claims that cannot be reassigned to other users. Typically, it means using a combination of 'iss' and 'sub' claims.", "level": 2, "explanation": "This requirement ensures that the resource server can accurately identify the user associated with an access token. By relying on claims that are unique and cannot be reassigned, such as 'iss' (issuer) and 'sub' (subject), the server mitigates the risk of impersonation and unauthorized access. This is crucial in maintaining the integrity of user sessions and ensuring that access control decisions are based on accurate user identity.", "threats_mitigated": ["Impersonation attacks", "Unauthorized access", "Token replay attacks"], "insecure_examples": [{"code": "const token = getAccessToken();\nconst userId = token.sub; // Potentially reassignable claim"}, {"code": "const user = getUserFromToken(token);\nif (user) {\n  // Access granted based on a claim that can be reassigned\n}"}], "secure_examples": [{"code": "const token = getAccessToken();\nconst claims = parseJwt(token);\nconst userId = claims.iss + claims.sub; // Using a combination of claims"}, {"code": "const user = getUserFromToken(token);\nif (user && isUserIdentifiedByUniqueClaims(user)) {\n  // Access granted based on secure claims\n}"}], "verification_steps": ["Check that the resource server extracts user identity from 'iss' and 'sub' claims.", "Ensure that the claims used for user identification cannot be reassigned to different users.", "Review the access control logic to confirm it relies on the unique combination of claims."], "common_mistakes": ["Using claims that can be easily manipulated or reassigned.", "Not validating the integrity of the access token before extracting claims.", "Assuming all claims are unique without proper verification."], "related_cwe": ["CWE-287", "CWE-352", "CWE-601"], "related_capec": ["CAPEC-131", "CAPEC-122"], "attack_flow": "An attacker could exploit this requirement by obtaining an access token and manipulating the claims to impersonate another user. If the resource server does not validate the uniqueness of the claims, the attacker may gain unauthorized access to resources, leading to data breaches or unauthorized actions on behalf of the legitimate user."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.3", "section_name": "OAuth Resource Server", "req_id": "V10.3.4", "req_description": "Verify that, if the resource server requires specific authentication strength, methods, or recentness, it verifies that the presented access token satisfies these constraints. For example, if present, using the OIDC 'acr', 'amr' and 'auth_time' claims respectively.", "level": "2", "explanation": "This requirement ensures that the resource server checks the claims within the access token to confirm that they meet the security policies defined by the application. This includes verifying the authentication context class reference ('acr'), authentication methods reference ('amr'), and the time of authentication ('auth_time'). Such checks help ensure that the access token is not only valid but also appropriate for the requested resource based on the defined security requirements.", "threats_mitigated": ["Token misuse", "Replay attacks", "Insufficient authentication strength", "Unauthorized access"], "insecure_examples": ["if (tokenIsValid(accessToken)) { /* proceed to access resource */ }", "if (accessToken.hasValidClaims()) { /* access granted */ }"], "secure_examples": ["if (tokenIsValid(accessToken) && checkClaims(accessToken)) { /* proceed to access resource */ }", "if (accessToken.hasValidClaims() && verifyAuthenticationStrength(accessToken)) { /* access granted */ }"], "verification_steps": ["Check if the access token is valid.", "Verify the presence of 'acr', 'amr', and 'auth_time' claims in the access token.", "Ensure that the claims meet the required constraints set by the resource server.", "Review the logic that handles access token validation and claims verification."], "common_mistakes": ["Not checking the claims in the access token at all.", "Assuming all tokens are equally secure without verifying their claims.", "Neglecting to implement checks for 'auth_time' leading to potential replay attacks."], "related_cwe": ["CWE-287", "CWE-352", "CWE-295"], "related_capec": ["CAPEC-138", "CAPEC-151"], "attack_flow": "An attacker obtains a valid access token but does not meet the required authentication strength or recency. If the resource server does not verify the 'acr', 'amr', and 'auth_time' claims, the attacker can use this token to gain unauthorized access to resources that require stronger authentication, leading to potential data breaches or unauthorized actions."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.3", "section_name": "OAuth Resource Server", "req_id": "V10.3.5", "req_description": "Verify that the resource server prevents the use of stolen access tokens or replay of access tokens (from unauthorized parties) by requiring sender-constrained access tokens, either Mutual TLS for OAuth 2 or OAuth 2 Demonstration of Proof of Possession (DPoP).", "level": 3, "explanation": "This requirement ensures that the resource server can verify the identity of the sender of the access token, thus preventing unauthorized parties from using stolen tokens. By implementing sender-constrained access tokens, such as Mutual TLS or DPoP, the server can ensure that the token is valid only when presented by the legitimate client, thereby mitigating risks associated with token theft and replay attacks.", "threats_mitigated": ["Token theft", "Replay attacks", "Man-in-the-middle attacks"], "insecure_examples": [{"code": "const token = getAccessToken();\nconst response = await fetch('https://api.example.com/resource', {\n  headers: { 'Authorization': `Bearer ${token}` }\n});"}, {"code": "const token = getStolenAccessToken();\nconst response = await fetch('https://api.example.com/resource', {\n  headers: { 'Authorization': `Bearer ${token}` }\n});"}], "secure_examples": [{"code": "const token = getAccessToken();\nconst response = await fetch('https://api.example.com/resource', {\n  headers: { 'Authorization': `Bearer ${token}`, 'X-Client-Cert': clientCertificate }\n});"}, {"code": "const token = getAccessToken();\nconst response = await fetch('https://api.example.com/resource', {\n  headers: { 'Authorization': `Bearer ${token}`, 'DPoP': proofOfPossession }\n});"}], "verification_steps": ["Check if the resource server requires Mutual TLS or DPoP for access tokens.", "Verify that the server validates the client certificate or DPoP proof before granting access.", "Test with a stolen access token to ensure it is rejected unless presented with the correct constraints."], "common_mistakes": ["Failing to implement sender-constrained access tokens.", "Not validating the client certificate or DPoP proof properly.", "Assuming that bearer tokens are sufficient without additional constraints."], "related_cwe": ["CWE-287", "CWE-295", "CWE-352"], "related_capec": ["CAPEC-137", "CAPEC-152", "CAPEC-160"], "attack_flow": "An attacker who steals an access token can attempt to use it to access resources. If the resource server does not implement sender constraints, the attacker can successfully access the resources. However, if sender-constrained access tokens are in place, the server will check the client's identity through Mutual TLS or DPoP, and deny access to the attacker, thus preventing the exploitation of the stolen token."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.4", "section_name": "OAuth Authorization Server", "req_id": "V10.4.1", "req_description": "Verify that the authorization server validates redirect URIs based on a client-specific allowlist of pre-registered URIs using exact string comparison.", "level": "1", "explanation": "This requirement ensures that the authorization server only redirects users to URIs that have been explicitly registered by the client application. By using exact string comparison, the server can prevent unauthorized redirection to potentially malicious sites that could capture sensitive information or perform phishing attacks.", "threats_mitigated": ["Open Redirect", "Phishing", "Session Fixation", "Cross-Site Request Forgery (CSRF)"], "insecure_examples": ["if (redirectUri != null) { redirect(redirectUri); }", "redirect(redirectUri); // No validation against allowlist"], "secure_examples": ["if (allowlist.contains(redirectUri)) { redirect(redirectUri); }", "if (isValidRedirectUri(redirectUri)) { redirect(redirectUri); }"], "verification_steps": ["Check if the authorization server maintains a list of pre-registered redirect URIs for each client.", "Verify that the server performs exact string comparison when validating redirect URIs.", "Test with both valid and invalid redirect URIs to ensure only allowed URIs are accepted.", "Review the server's configuration to ensure that no wildcard or regex matching is used for redirect URIs."], "common_mistakes": ["Using regex or wildcard matching for redirect URIs instead of exact string comparison.", "Failing to update the allowlist when new redirect URIs are added.", "Not handling cases where the redirect URI is not provided or is null."], "related_cwe": ["CWE-601", "CWE-20", "CWE-601"], "related_capec": ["CAPEC-153", "CAPEC-154"], "attack_flow": "An attacker crafts a malicious link that redirects to a phishing site. If the authorization server does not validate the redirect URI against the allowlist, the attacker can trick the user into being redirected to the malicious site after authentication, potentially capturing sensitive information such as access tokens or user credentials."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.4", "section_name": "OAuth Authorization Server", "req_id": "V10.4.2", "req_description": "Verify that, if the authorization server returns the authorization code in the authorization response, it can be used only once for a token request. For the second valid request with an authorization code that has already been used to issue an access token, the authorization server must reject a token request and revoke any issued tokens related to the authorization code.", "level": "1", "explanation": "This requirement ensures that authorization codes are single-use, preventing replay attacks where an attacker could reuse an intercepted authorization code to gain unauthorized access. By enforcing single-use codes, the authorization server can maintain a higher level of security and trust in the authorization process.", "threats_mitigated": ["Replay attacks", "Unauthorized access", "Token theft"], "insecure_examples": [{"code": "if (authorizationCodeIsValid(code)) {\n    issueAccessToken(code);\n}", "description": "This code does not check if the authorization code has already been used."}, {"code": "returnTokens(authorizationCode);\n// No revocation of previously issued tokens"}], "secure_examples": [{"code": "if (authorizationCodeIsValid(code) && !isCodeUsed(code)) {\n    issueAccessToken(code);\n    markCodeAsUsed(code);\n}", "description": "This code checks if the authorization code has already been used before issuing a token."}, {"code": "revokeTokens(authorizationCode);\n// Ensure all tokens related to the authorization code are revoked"}], "verification_steps": ["Check if the authorization server rejects a second request with the same authorization code.", "Verify that the authorization server revokes any tokens issued for a used authorization code.", "Test the authorization flow to ensure single-use enforcement is functioning."], "common_mistakes": ["Failing to mark authorization codes as used after issuing tokens.", "Not implementing checks for previously used authorization codes.", "Neglecting to revoke tokens associated with used authorization codes."], "related_cwe": ["CWE-287", "CWE-352"], "related_capec": ["CAPEC-137", "CAPEC-139"], "attack_flow": "An attacker intercepts an authorization code during the authorization process. If the authorization server does not enforce single-use codes, the attacker can reuse the intercepted code to request an access token, gaining unauthorized access to the user's resources. This can lead to data breaches and unauthorized actions on behalf of the user."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.4", "section_name": "OAuth Authorization Server", "req_id": "V10.4.3", "req_description": "Verify that the authorization code is short-lived. The maximum lifetime can be up to 10 minutes for L1 and L2 applications and up to 1 minute for L3 applications.", "level": "1", "explanation": "This requirement emphasizes the importance of limiting the lifespan of authorization codes in OAuth flows. By ensuring that authorization codes expire quickly, the risk of unauthorized access is minimized, as attackers have a reduced window of opportunity to use stolen codes. For Level 1 and 2 applications, a maximum lifetime of 10 minutes is allowed, while Level 3 applications should enforce a stricter limit of 1 minute.", "threats_mitigated": ["Authorization Code Interception", "Replay Attacks", "Session Hijacking"], "insecure_examples": ["const authorizationCode = generateAuthorizationCode();\nsetCodeLifetime(3600); // 1 hour lifetime", "const code = request.query.code;\nif (isValidCode(code)) {\n  // process code\n}"], "secure_examples": ["const authorizationCode = generateAuthorizationCode();\nsetCodeLifetime(600); // 10 minutes lifetime for L1 and L2", "const code = request.query.code;\nif (isValidCode(code) && isCodeNotExpired(code)) {\n  // process code\n}"], "verification_steps": ["Check the configuration settings for authorization code expiration.", "Review the code to ensure that the lifetime of authorization codes is set according to the application level.", "Test the authorization flow to confirm that expired codes are rejected."], "common_mistakes": ["Setting an excessively long expiration time for authorization codes.", "Failing to implement checks for code expiration before processing authorization codes.", "Hardcoding expiration values instead of using configurable settings."], "related_cwe": ["CWE-287", "CWE-200"], "related_capec": ["CAPEC-155", "CAPEC-160"], "attack_flow": "An attacker intercepts an authorization code during the OAuth flow. If the authorization code has a long expiration time, the attacker can use it to gain unauthorized access to the user's resources. By limiting the lifetime of the authorization code, the window of opportunity for the attacker is significantly reduced, thus mitigating the risk of exploitation."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.4", "section_name": "OAuth Authorization Server", "req_id": "V10.4.4", "req_description": "Verify that for a given client, the authorization server only allows the usage of grants that this client needs to use. Note that the grants 'token' (Implicit flow) and 'password' (Resource Owner Password Credentials flow) must no longer be used.", "level": "1", "explanation": "This requirement ensures that the authorization server is configured to only permit specific OAuth grant types that are necessary for the client application. By restricting the grants, it reduces the attack surface and limits the potential for abuse. The implicit flow and resource owner password credentials flow are considered less secure and should not be used in modern applications.", "threats_mitigated": ["Authorization code interception", "Token leakage", "Credential stuffing", "Phishing attacks"], "insecure_examples": [{"code": "const oauth2Client = new OAuth2Client(clientId, clientSecret);\n\n// Insecure usage of password grant\nconst token = await oauth2Client.getToken({\n  username: 'user@example.com',\n  password: 'userpassword'\n});"}, {"code": "const oauth2Client = new OAuth2Client(clientId, clientSecret);\n\n// Insecure usage of implicit flow\nconst redirectUri = 'http://example.com/callback';\nconst authUrl = oauth2Client.generateAuthUrl({\n  access_type: 'offline',\n  scope: 'https://www.googleapis.com/auth/userinfo.profile',\n  response_type: 'token'\n});"}], "secure_examples": [{"code": "const oauth2Client = new OAuth2Client(clientId, clientSecret);\n\n// Secure usage of authorization code grant\nconst authUrl = oauth2Client.generateAuthUrl({\n  access_type: 'offline',\n  scope: 'https://www.googleapis.com/auth/userinfo.profile',\n  response_type: 'code'\n});"}, {"code": "const oauth2Client = new OAuth2Client(clientId, clientSecret);\n\n// Secure usage of authorization code with PKCE\nconst codeChallenge = generateCodeChallenge();\nconst authUrl = oauth2Client.generateAuthUrl({\n  access_type: 'offline',\n  scope: 'https://www.googleapis.com/auth/userinfo.profile',\n  response_type: 'code',\n  code_challenge: codeChallenge,\n  code_challenge_method: 'S256'\n});"}], "verification_steps": ["Review the OAuth server configuration to ensure only necessary grants are enabled.", "Check for the presence of implicit and password grants in the configuration.", "Validate that the client applications are using the secure authorization code grant or other secure flows."], "common_mistakes": ["Leaving implicit and password grants enabled in the OAuth server configuration.", "Not reviewing client applications to ensure they are using secure grant types.", "Assuming that all clients need access to all grant types."], "related_cwe": ["CWE-287", "CWE-295", "CWE-306"], "related_capec": ["CAPEC-132", "CAPEC-145", "CAPEC-153"], "attack_flow": "An attacker could exploit the authorization server by using a client that is improperly configured to allow the implicit or password grant types. They could obtain access tokens through phishing or by intercepting the authorization code, leading to unauthorized access to user data."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.4", "section_name": "OAuth Authorization Server", "req_id": "V10.4.5", "req_description": "Verify that the authorization server mitigates refresh token replay attacks for public clients, preferably using sender-constrained refresh tokens, i.e., Demonstrating Proof of Possession (DPoP) or Certificate-Bound Access Tokens using mutual TLS (mTLS). For L1 and L2 applications, refresh token rotation may be used. If refresh token rotation is used, the authorization server must invalidate the refresh token after usage, and revoke all refresh tokens for that authorization if an already used and invalidated refresh token is provided.", "level": "1", "explanation": "This requirement ensures that refresh tokens, which are used to obtain new access tokens without requiring the user to re-authenticate, are protected against replay attacks. In a replay attack, an attacker could use a stolen refresh token to gain unauthorized access to resources. By implementing sender-constrained refresh tokens, the authorization server can ensure that only the legitimate client can use the refresh token. Techniques such as DPoP and mTLS provide a way to bind the token to the client, making it much harder for attackers to misuse stolen tokens.", "threats_mitigated": ["Refresh token replay attacks", "Unauthorized access due to stolen tokens", "Session hijacking"], "insecure_examples": ["const refreshToken = getRefreshTokenFromStorage();\nconst newAccessToken = await fetch('/token', { method: 'POST', body: JSON.stringify({ refresh_token: refreshToken }) });", "const refreshToken = req.body.refresh_token;\n// No validation or invalidation logic implemented\nconst newAccessToken = generateNewAccessToken(refreshToken);"], "secure_examples": ["const refreshToken = getRefreshTokenFromStorage();\nconst newAccessToken = await fetch('/token', { method: 'POST', headers: { 'Authorization': `DPoP ${generateDpopHeader(refreshToken)}` }, body: JSON.stringify({ refresh_token: refreshToken }) });", "const refreshToken = req.body.refresh_token;\nif (!isValidRefreshToken(refreshToken)) { throw new Error('Invalid refresh token'); }\nconst newAccessToken = generateNewAccessToken(refreshToken);\ninvalidateRefreshToken(refreshToken);"], "verification_steps": ["Check if the authorization server uses sender-constrained refresh tokens.", "Verify that refresh token rotation is implemented for L1 and L2 applications.", "Ensure that refresh tokens are invalidated after use.", "Confirm that all refresh tokens for an authorization are revoked if an invalidated token is used."], "common_mistakes": ["Not implementing sender-constrained tokens for public clients.", "Failing to invalidate refresh tokens after they are used.", "Using the same refresh token multiple times without rotation.", "Neglecting to revoke all refresh tokens upon invalidation."], "related_cwe": ["CWE-287", "CWE-295", "CWE-352"], "related_capec": ["CAPEC-164", "CAPEC-162", "CAPEC-154"], "attack_flow": "An attacker captures a refresh token through various means (e.g., network sniffing, XSS). They then use this token to request a new access token from the authorization server. If the server does not validate the token or if it allows reuse, the attacker gains unauthorized access to the user's resources. By implementing sender-constrained tokens and token invalidation, the server can prevent this flow from succeeding."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.4", "section_name": "OAuth Authorization Server", "req_id": "V10.4.6", "req_description": "Verify that, if the code grant is used, the authorization server mitigates authorization code interception attacks by requiring proof key for code exchange (PKCE). For authorization requests, the authorization server must require a valid 'code_challenge' value and must not accept a 'code_challenge_method' value of 'plain'. For a token request, it must require validation of the 'code_verifier' parameter.", "level": 2, "explanation": "This requirement ensures that the authorization server implements PKCE, which adds an additional layer of security to the OAuth 2.0 authorization code flow. By requiring a 'code_challenge' and validating the 'code_verifier', it helps prevent attackers from intercepting authorization codes and using them to gain unauthorized access to resources.", "threats_mitigated": ["Authorization Code Interception", "Man-in-the-Middle Attacks", "Replay Attacks"], "insecure_examples": [{"code": "GET /authorize?response_type=code&client_id=client_id&redirect_uri=redirect_uri&scope=scope&state=state"}, {"code": "POST /token HTTP/1.1\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=authorization_code&code=authorization_code&redirect_uri=redirect_uri"}], "secure_examples": [{"code": "GET /authorize?response_type=code&client_id=client_id&redirect_uri=redirect_uri&scope=scope&state=state&code_challenge=challenge&code_challenge_method=S256"}, {"code": "POST /token HTTP/1.1\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=authorization_code&code=authorization_code&redirect_uri=redirect_uri&code_verifier=verifier"}], "verification_steps": ["Check that the authorization server requires a 'code_challenge' parameter during authorization requests.", "Ensure that 'code_challenge_method' is not set to 'plain'.", "Verify that the authorization server validates the 'code_verifier' parameter during token requests.", "Review the implementation for proper handling of PKCE in both authorization and token requests."], "common_mistakes": ["Not implementing PKCE for public clients.", "Accepting 'code_challenge_method' as 'plain'.", "Failing to validate the 'code_verifier' in token requests."], "related_cwe": ["CWE-287", "CWE-352", "CWE-295"], "related_capec": ["CAPEC-118", "CAPEC-136", "CAPEC-139"], "attack_flow": "An attacker intercepts the authorization code during the authorization flow. Without PKCE, the attacker can use the intercepted code to request an access token. However, if PKCE is implemented, the attacker would not have the correct 'code_verifier' to exchange for the access token, thus preventing unauthorized access."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.4", "section_name": "OAuth Authorization Server", "req_id": "V10.4.7", "req_description": "Verify that if the authorization server supports unauthenticated dynamic client registration, it mitigates the risk of malicious client applications. It must validate client metadata such as any registered URIs, ensure the user's consent, and warn the user before processing an authorization request with an untrusted client application.", "level": "2", "explanation": "This requirement emphasizes the importance of validating client applications that register dynamically without prior authentication. It mandates that the authorization server should implement checks to ensure that the client applications are legitimate and that the users are aware of the risks involved in granting access to their data. Proper validation of client metadata, including redirect URIs, is crucial to prevent unauthorized access and potential data breaches.", "threats_mitigated": ["Malicious client applications impersonating legitimate clients", "User data leakage due to untrusted client access", "Phishing attacks via misleading authorization requests"], "insecure_examples": [{"code": "client_id = register_client(unauthenticated_data);", "description": "This code snippet allows client registration without validating the provided metadata."}, {"code": "process_authorization_request(client_id);", "description": "This code processes an authorization request without checking if the client is trusted."}], "secure_examples": [{"code": "if (validate_client_metadata(unauthenticated_data)) { client_id = register_client(unauthenticated_data); }", "description": "This code snippet validates the client metadata before registering the client."}, {"code": "if (is_trusted_client(client_id)) { process_authorization_request(client_id); } else { warn_user(); }", "description": "This code checks if the client is trusted before processing the authorization request."}], "verification_steps": ["Check if the authorization server validates client metadata during registration.", "Verify that registered URIs are checked against known patterns.", "Ensure that user consent is obtained and logged.", "Look for warnings presented to users before processing requests from untrusted clients."], "common_mistakes": ["Failing to validate client metadata during dynamic registration.", "Not implementing user consent mechanisms.", "Neglecting to warn users about untrusted client applications."], "related_cwe": ["CWE-20: Improper Input Validation", "CWE-287: Improper Authentication", "CWE-352: Cross-Site Request Forgery (CSRF)"], "related_capec": ["CAPEC-154: Client-Side Injection of Malicious Code", "CAPEC-162: OAuth Token Theft", "CAPEC-181: OAuth Misconfiguration"], "attack_flow": "An attacker may create a malicious client application that registers with the authorization server without proper validation. If the server does not check the client metadata, it may allow the attacker to obtain an access token. The attacker can then use this token to access sensitive user data, leading to data breaches or unauthorized actions on behalf of the user."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.4", "section_name": "OAuth Authorization Server", "req_id": "V10.4.8", "req_description": "Verify that refresh tokens have an absolute expiration, including if sliding refresh token expiration is applied.", "level": 2, "explanation": "This requirement ensures that refresh tokens are not valid indefinitely, which mitigates the risk of token theft. An absolute expiration means that after a certain period, the refresh token cannot be used to obtain new access tokens, forcing users to re-authenticate. This is particularly important in scenarios where tokens may be intercepted or stolen.", "threats_mitigated": ["Token theft", "Replay attacks", "Unauthorized access due to long-lived tokens"], "insecure_examples": [{"code": "const refreshToken = generateRefreshToken();\nstoreTokenInDatabase(refreshToken); // No expiration set"}, {"code": "app.use(oauth2Server({\n  refreshTokenLifetime: 0 // Refresh token never expires\n}));"}], "secure_examples": [{"code": "const refreshToken = generateRefreshToken();\nstoreTokenInDatabase(refreshToken, { expiresIn: '30d' }); // Set expiration to 30 days"}, {"code": "app.use(oauth2Server({\n  refreshTokenLifetime: 86400 // Refresh token expires in 1 day\n}));"}], "verification_steps": ["Check that refresh tokens are stored with an expiration time.", "Verify that the expiration time is not set to infinite.", "Review the implementation of sliding expiration to ensure it is correctly applied.", "Test the behavior of refresh tokens after their expiration time."], "common_mistakes": ["Setting refresh tokens to never expire.", "Failing to implement an expiration mechanism for sliding refresh tokens.", "Not considering the security implications of long-lived refresh tokens."], "related_cwe": ["CWE-295: Improper Certificate Validation", "CWE-287: Improper Authentication"], "related_capec": ["CAPEC-137: Token Theft", "CAPEC-154: Replay Attack"], "attack_flow": "An attacker intercepts a refresh token that does not expire. They can use this token to obtain new access tokens indefinitely, allowing them to access the user's account without detection. By ensuring refresh tokens have an absolute expiration, the window of opportunity for the attacker is reduced significantly."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.4", "section_name": "OAuth Authorization Server", "req_id": "V10.4.9", "req_description": "Verify that refresh tokens and reference access tokens can be revoked by an authorized user using the authorization server user interface, to mitigate the risk of malicious clients or stolen tokens.", "level": 2, "explanation": "This requirement emphasizes the importance of having a mechanism in place that allows authorized users to revoke access tokens and refresh tokens. This is crucial for maintaining control over user sessions and preventing unauthorized access, especially in cases where tokens may have been compromised or when a user wishes to terminate a session. The revocation process should be straightforward and accessible through the authorization server's user interface.", "threats_mitigated": ["Token theft", "Session hijacking", "Unauthorized access", "Malicious client exploitation"], "insecure_examples": [{"code": "if (tokenIsValid) { grantAccess(); } // No revocation mechanism implemented"}, {"code": "userSession = createSession(token); // Tokens cannot be revoked once issued"}], "secure_examples": [{"code": "if (tokenIsValid && !isRevoked(token)) { grantAccess(); } // Implemented revocation check"}, {"code": "userSession = createSession(token); revokeToken(token); // Token revocation after session termination"}], "verification_steps": ["Check if the authorization server provides a user interface for revoking tokens.", "Verify that users can successfully revoke their refresh and access tokens.", "Ensure that revoked tokens cannot be used to gain access.", "Test the revocation process for both refresh and reference tokens."], "common_mistakes": ["Failing to implement a revocation mechanism for tokens.", "Not providing a user-friendly interface for token management.", "Assuming that tokens are safe once issued without considering revocation needs."], "related_cwe": ["CWE-287", "CWE-295", "CWE-352"], "related_capec": ["CAPEC-137", "CAPEC-149", "CAPEC-154"], "attack_flow": "An attacker steals a refresh token and uses it to obtain a new access token. Without a revocation mechanism, the attacker can maintain access indefinitely. However, if the legitimate user revokes the token, the attacker's access is terminated, preventing further exploitation."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.4", "section_name": "OAuth Authorization Server", "req_id": "V10.4.10", "req_description": "Verify that confidential client is authenticated for client-to-authorized server backchannel requests such as token requests, pushed authorization requests (PAR), and token revocation requests.", "level": 2, "explanation": "This requirement ensures that confidential clients, which are capable of keeping their credentials secure, must authenticate themselves when making requests to the authorization server. This is crucial for maintaining the integrity and security of the OAuth flow, preventing unauthorized access to sensitive operations such as token issuance and revocation.", "threats_mitigated": ["Unauthorized access to tokens", "Token leakage", "Impersonation of clients"], "insecure_examples": ["POST /token HTTP/1.1\nHost: authorization-server.com\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=client_credentials&client_id=public_client_id&client_secret=public_client_secret", "POST /token HTTP/1.1\nHost: authorization-server.com\n\ngrant_type=client_credentials"], "secure_examples": ["POST /token HTTP/1.1\nHost: authorization-server.com\nAuthorization: Basic base64(client_id:client_secret)\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=client_credentials", "POST /token HTTP/1.1\nHost: authorization-server.com\nAuthorization: Bearer valid_access_token\n\ngrant_type=client_credentials"], "verification_steps": ["Check if the client is using a secure method to authenticate (e.g., Basic Auth or JWT).", "Verify that the client credentials are not exposed in the request body or URL.", "Ensure that the authorization server validates the client credentials before processing the request."], "common_mistakes": ["Using public clients without proper authentication.", "Exposing client secrets in URLs or logs.", "Not validating client credentials on the server side."], "related_cwe": ["CWE-287", "CWE-200", "CWE-352"], "related_capec": ["CAPEC-112", "CAPEC-137", "CAPEC-139"], "attack_flow": "An attacker may attempt to impersonate a confidential client by sending requests to the authorization server without proper authentication. If the server does not validate the client credentials, the attacker could gain unauthorized access to tokens or perform sensitive operations like token revocation, leading to potential data breaches."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.4", "section_name": "OAuth Authorization Server", "req_id": "V10.4.11", "req_description": "Verify that the authorization server configuration only assigns the required scopes to the OAuth client.", "level": 2, "explanation": "This requirement ensures that OAuth clients are only granted access to the specific scopes they need to function. By limiting the scopes, the authorization server minimizes the potential attack surface and reduces the risk of unauthorized access to sensitive resources.", "threats_mitigated": ["Excessive permissions leading to unauthorized access", "Scope escalation attacks", "Data leakage through over-permissioned clients"], "insecure_examples": [{"code": "client.setScopes(['read', 'write', 'admin']); // Grants more scopes than necessary"}, {"code": "authorizationServer.grantAccess(client, ['read', 'write', 'delete']); // Unrestricted scope assignment"}], "secure_examples": [{"code": "client.setScopes(['read']); // Grants only the necessary scope"}, {"code": "authorizationServer.grantAccess(client, ['read']); // Restricted scope assignment"}], "verification_steps": ["Review the OAuth client configuration for assigned scopes.", "Ensure that only the necessary scopes are granted based on the client's functionality.", "Check for any hardcoded or default scopes that may be excessive.", "Validate that scope changes are documented and reviewed."], "common_mistakes": ["Assigning default scopes without reviewing their necessity.", "Failing to update scopes when client functionality changes.", "Not conducting regular audits of client permissions."], "related_cwe": ["CWE-284", "CWE-732"], "related_capec": ["CAPEC-137", "CAPEC-153"], "attack_flow": "An attacker may exploit a misconfigured authorization server by requesting access tokens with excessive scopes. If granted, the attacker can access sensitive data or perform actions that should be restricted, leading to potential data breaches or unauthorized operations."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.4", "section_name": "OAuth Authorization Server", "req_id": "V10.4.12", "req_description": "Verify that for a given client, the authorization server only allows the 'response_mode' value that this client needs to use. For example, by having the authorization server validate this value against the expected values or by using pushed authorization request (PAR) or JWT-secured Authorization Request (JAR).", "level": 3, "explanation": "This requirement ensures that the authorization server restricts the 'response_mode' parameter to only those values that are necessary for the specific client making the request. This minimizes the attack surface by preventing clients from using unexpected or insecure response modes that could lead to vulnerabilities such as information disclosure or unauthorized access.", "threats_mitigated": ["Open Redirects", "Cross-Site Request Forgery (CSRF)", "Information Disclosure", "Unauthorized Access"], "insecure_examples": ["if (clientResponseMode == 'query') { /* process response */ }", "authorizeRequest(response_mode='fragment'); // No validation of response_mode"], "secure_examples": ["if (isValidResponseMode(clientId, clientResponseMode)) { /* process response */ }", "authorizeRequest(response_mode='query', clientId); // Validated against expected values"], "verification_steps": ["Check that the authorization server only accepts predefined response modes for each client.", "Verify that the validation logic for response modes is implemented correctly.", "Review logs to ensure that invalid response modes are rejected.", "Test the authorization server with various response modes to confirm proper handling."], "common_mistakes": ["Failing to validate the response_mode against a whitelist of acceptable values.", "Allowing clients to specify any response_mode without restriction.", "Neglecting to update the validation logic when new response modes are introduced."], "related_cwe": ["CWE-601: URL Redirection to Untrusted Site ('Open Redirect')", "CWE-352: Cross-Site Request Forgery (CSRF)", "CWE-200: Information Exposure"], "related_capec": ["CAPEC-112: Cross-Site Request Forgery (CSRF)", "CAPEC-139: Open Redirect", "CAPEC-160: OAuth Token Theft"], "attack_flow": "An attacker could exploit this requirement by crafting a request with an unexpected 'response_mode' that the authorization server does not validate properly. If the server accepts this value, it may redirect the user to a malicious site or expose sensitive information, leading to unauthorized access or data leakage."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.4", "section_name": "OAuth Authorization Server", "req_id": "V10.4.13", "req_description": "Verify that grant type 'code' is always used together with pushed authorization requests (PAR).", "level": "3", "explanation": "This requirement ensures that the authorization code grant type is used in conjunction with pushed authorization requests to enhance security. The use of PAR mitigates risks associated with authorization code interception and replay attacks, as it requires the client to send the authorization request to the authorization server in a secure manner before receiving the authorization code.", "threats_mitigated": ["Authorization code interception", "Replay attacks", "Man-in-the-middle attacks"], "insecure_examples": [{"code": "GET /authorize?response_type=code&client_id=abc123&redirect_uri=https://example.com/callback&scope=openid"}, {"code": "POST /authorize HTTP/1.1\nHost: authorization-server.com\nContent-Type: application/x-www-form-urlencoded\n\nresponse_type=code&client_id=abc123&redirect_uri=https://example.com/callback&scope=openid"}], "secure_examples": [{"code": "POST /authorize HTTP/1.1\nHost: authorization-server.com\nContent-Type: application/x-www-form-urlencoded\n\nrequest_uri=https://example.com/pushed_request&client_id=abc123"}], "verification_steps": ["Check that the authorization server supports pushed authorization requests (PAR).", "Ensure that the client application uses the 'code' grant type with PAR in all authorization requests.", "Review the implementation to confirm that authorization requests are sent securely."], "common_mistakes": ["Not using pushed authorization requests when implementing the authorization code grant.", "Failing to validate the integrity and authenticity of the authorization request.", "Using insecure transport methods for authorization requests."], "related_cwe": ["CWE-287", "CWE-295", "CWE-352"], "related_capec": ["CAPEC-139", "CAPEC-145", "CAPEC-148"], "attack_flow": "An attacker intercepts an authorization request that does not use PAR, allowing them to obtain the authorization code. They can then use this code to gain unauthorized access to the user's resources. By ensuring that the 'code' grant type is used with PAR, the authorization server can verify that the request was legitimate and not tampered with."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.4", "section_name": "OAuth Authorization Server", "req_id": "V10.4.14", "req_description": "Verify that the authorization server issues only sender-constrained (Proof-of-Possession) access tokens, either with certificate-bound access tokens using mutual TLS (mTLS) or DPoP-bound access tokens (Demonstration of Proof of Possession).", "level": "3", "explanation": "This requirement ensures that access tokens are tied to the client that requested them, preventing unauthorized use by other parties. By implementing sender-constrained tokens, the authorization server can verify that the token is being used by the legitimate owner, thereby enhancing security against token theft and replay attacks.", "threats_mitigated": ["Token theft", "Replay attacks", "Man-in-the-middle attacks", "Unauthorized access"], "insecure_examples": [{"code": "const token = getAccessToken();\n// Token is not sender-constrained\nuseToken(token);"}, {"code": "const token = requestAccessToken();\n// Token can be used by any client\nsendTokenToResourceServer(token);"}], "secure_examples": [{"code": "const token = getAccessTokenWithMTLS();\n// Token is sender-constrained using mTLS\nuseToken(token);"}, {"code": "const token = requestDPoPAccessToken();\n// Token is bound to the client using DPoP\nsendTokenToResourceServer(token);"}], "verification_steps": ["Check that access tokens are issued with mTLS or DPoP binding.", "Verify the implementation of mutual TLS in the authorization server.", "Ensure that tokens cannot be used without the proper client identity verification.", "Review the token issuance process for sender-constraining mechanisms."], "common_mistakes": ["Issuing bearer tokens without sender constraints.", "Failing to implement mutual TLS correctly.", "Not validating the client identity when processing access tokens.", "Overlooking the need for token binding in API calls."], "related_cwe": ["CWE-287", "CWE-295", "CWE-300"], "related_capec": ["CAPEC-137", "CAPEC-120"], "attack_flow": "An attacker intercepts a token that is not sender-constrained and uses it to access protected resources. By exploiting the lack of binding, the attacker can impersonate the legitimate client and gain unauthorized access to sensitive data or operations."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.4", "section_name": "OAuth Authorization Server", "req_id": "V10.4.15", "req_description": "Verify that, for a server-side client (which is not executed on the end-user device), the authorization server ensures that the 'authorization_details' parameter value is from the client backend and that the user has not tampered with it. For example, by requiring the usage of pushed authorization request (PAR) or JWT-secured Authorization Request (JAR).", "level": "3", "explanation": "This requirement emphasizes the importance of validating the integrity and authenticity of the 'authorization_details' parameter in OAuth flows. Since server-side clients do not run on the end-user device, they are at risk of receiving tampered data. By implementing mechanisms like PAR or JAR, the authorization server can ensure that the data originates from a trusted source and has not been altered during transmission.", "threats_mitigated": ["Parameter tampering", "Replay attacks", "Man-in-the-middle attacks"], "insecure_examples": [{"code": "authorization_details = request.get('authorization_details')\nif not validate_authorization_details(authorization_details):\n    raise Exception('Invalid authorization details')"}, {"code": "if 'authorization_details' in request:\n    process_authorization(request['authorization_details'])"}], "secure_examples": [{"code": "authorization_details = request.get('authorization_details')\nif not validate_authorization_details(authorization_details) or not is_from_trusted_source(authorization_details):\n    raise Exception('Invalid or tampered authorization details')"}, {"code": "if validate_jwt(request['authorization_details']):\n    process_authorization(request['authorization_details'])"}], "verification_steps": ["Check if the 'authorization_details' parameter is validated against a trusted source.", "Ensure that the server uses PAR or JAR for authorization requests.", "Review logs to identify any unauthorized access attempts related to 'authorization_details'.", "Test for tampering by simulating unauthorized modifications to the 'authorization_details' parameter."], "common_mistakes": ["Failing to validate the source of the 'authorization_details' parameter.", "Not using secure methods like PAR or JAR for authorization requests.", "Assuming that client-side validation is sufficient for server-side clients."], "related_cwe": ["CWE-345: Insufficient Verification of Data Authenticity", "CWE-20: Improper Input Validation"], "related_capec": ["CAPEC-137: Parameter Injection", "CAPEC-139: Man-in-the-Middle Attack"], "attack_flow": "An attacker intercepts the authorization request and modifies the 'authorization_details' parameter. If the authorization server does not validate the source or integrity of this parameter, it may process the request, leading to unauthorized access or actions being performed on behalf of the user."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.4", "section_name": "OAuth Authorization Server", "req_id": "V10.4.16", "req_description": "Verify that the client is confidential and the authorization server requires the use of strong client authentication methods (based on public-key cryptography and resistant to replay attacks), such as mutual TLS ('tls_client_auth', 'self_signed_tls_client_auth') or private key JWT ('private_key_jwt').", "level": 3, "explanation": "This requirement ensures that only authorized clients can access the OAuth authorization server by implementing strong authentication mechanisms. Confidential clients must prove their identity using secure methods that prevent unauthorized access and replay attacks. By enforcing techniques like mutual TLS and private key JWT, the server can ensure that the client is legitimate and has the right to request tokens.", "threats_mitigated": ["Unauthorized access to sensitive resources", "Replay attacks", "Man-in-the-middle attacks", "Impersonation of clients"], "insecure_examples": ["Authorization server accepts client requests without verifying client identity.", "Using basic authentication without TLS for client authentication."], "secure_examples": ["Authorization server requires mutual TLS for client authentication, ensuring that only trusted clients can connect.", "Using private key JWT for client authentication, where the client signs the request with its private key."], "verification_steps": ["Check if mutual TLS is implemented for client connections.", "Verify that the authorization server supports and enforces private key JWT.", "Ensure that client secrets are stored securely and not hard-coded.", "Review logs for any unauthorized access attempts."], "common_mistakes": ["Failing to implement mutual TLS due to lack of understanding.", "Using weak client authentication methods like basic auth.", "Not validating client certificates properly.", "Hardcoding sensitive credentials in the application."], "related_cwe": ["CWE-287", "CWE-295", "CWE-300"], "related_capec": ["CAPEC-118", "CAPEC-130", "CAPEC-146"], "attack_flow": "An attacker could exploit a lack of client authentication by impersonating a legitimate client. If the authorization server does not verify the client's identity, the attacker could obtain access tokens and use them to access protected resources. Additionally, without strong authentication methods, replay attacks could allow the attacker to reuse valid requests to gain unauthorized access."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.5", "section_name": "OIDC Client", "req_id": "V10.5.1", "req_description": "Verify that the client (as the relying party) mitigates ID Token replay attacks. For example, by ensuring that the 'nonce' claim in the ID Token matches the 'nonce' value sent in the authentication request to the OpenID Provider (in OAuth2 refereed to as the authorization request sent to the authorization server).", "level": 2, "explanation": "This requirement ensures that the application verifies the integrity and authenticity of the ID Token received from the OpenID Provider by checking the 'nonce' value. The 'nonce' is a unique value generated by the client and sent in the authentication request. If an attacker can replay an ID Token, they could impersonate a user or gain unauthorized access. By matching the 'nonce' in the ID Token with the one sent in the request, the application can confirm that the token is fresh and has not been reused.", "threats_mitigated": ["ID Token replay attacks", "Session fixation attacks", "Unauthorized access"], "insecure_examples": ["if (idToken.nonce !== expectedNonce) { /* process token */ }", "const isValid = verifyToken(idToken); if (!isValid) { /* proceed without nonce check */ }"], "secure_examples": ["if (idToken.nonce === expectedNonce) { /* process token */ } else { throw new Error('Invalid nonce'); }", "const isValid = verifyToken(idToken); if (isValid && idToken.nonce === expectedNonce) { /* proceed */ }"], "verification_steps": ["Check that the 'nonce' value is included in the authentication request.", "Ensure the 'nonce' value in the ID Token matches the one sent in the request.", "Verify the signature of the ID Token.", "Confirm that the ID Token is not expired."], "common_mistakes": ["Failing to generate a unique nonce for each authentication request.", "Not validating the nonce in the ID Token against the request.", "Assuming that the ID Token is always valid without proper checks."], "related_cwe": ["CWE-287", "CWE-352"], "related_capec": ["CAPEC-137", "CAPEC-155"], "attack_flow": "An attacker captures a valid ID Token and replays it to the application. If the application does not validate the 'nonce', it may accept the replayed token, allowing the attacker to impersonate the user or gain unauthorized access. By checking the 'nonce', the application can detect the replay and reject the token."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.5", "section_name": "OIDC Client", "req_id": "V10.5.2", "req_description": "Verify that the client uniquely identifies the user from ID Token claims, usually the 'sub' claim, which cannot be reassigned to other users (for the scope of an identity provider).", "level": 2, "explanation": "This requirement ensures that the client application can uniquely identify a user based on the ID Token received from the identity provider. The 'sub' claim is a standard claim in OpenID Connect that represents the unique identifier for the user. It is crucial that this identifier remains constant and is not reused for different users to prevent identity confusion and impersonation attacks.", "threats_mitigated": ["Identity Confusion", "Impersonation", "Session Fixation"], "insecure_examples": ["if (idToken.sub == anotherUserId) { /* Incorrectly reassigning sub */ }", "let userId = getUserIdFromToken(idToken); if (userId != expectedUserId) { /* Logic flaw */ }"], "secure_examples": ["if (idToken.sub == expectedUserId) { /* Correctly validating sub */ }", "let userId = idToken.sub; if (userId == expectedUserId) { /* Secure logic */ }"], "verification_steps": ["Check that the 'sub' claim in the ID Token is present.", "Ensure the 'sub' claim is unique and not reused across different users.", "Verify that the application logic correctly uses the 'sub' claim for user identification."], "common_mistakes": ["Reusing the 'sub' claim across different user accounts.", "Not validating the 'sub' claim correctly against expected user identifiers.", "Assuming that the 'sub' claim will always be unique without proper checks."], "related_cwe": ["CWE-287", "CWE-384"], "related_capec": ["CAPEC-137", "CAPEC-153"], "attack_flow": "An attacker may exploit a flaw in the handling of the 'sub' claim by manipulating the ID Token to impersonate another user. If the application does not properly validate the 'sub' claim, the attacker could gain unauthorized access to resources or perform actions as the victim user."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.5", "section_name": "OIDC Client", "req_id": "V10.5.3", "req_description": "Verify that the client rejects attempts by a malicious authorization server to impersonate another authorization server through authorization server metadata. The client must reject authorization server metadata if the issuer URL in the authorization server metadata does not exactly match the pre-configured issuer URL expected by the client.", "level": "2", "explanation": "This requirement ensures that the OpenID Connect (OIDC) client only trusts authorization server metadata from a known and trusted issuer. By validating the issuer URL against a pre-configured value, the client can prevent attacks where a malicious server attempts to impersonate a legitimate authorization server, thereby protecting user authentication and authorization processes.", "threats_mitigated": ["Authorization Server Impersonation", "Man-in-the-Middle Attacks", "Phishing Attacks"], "insecure_examples": [{"code": "const metadata = fetchAuthorizationServerMetadata();\nif (metadata.issuer !== expectedIssuer) {\n  // No rejection logic implemented\n}"}, {"code": "const issuer = metadata.issuer;\nif (issuer.includes('trusted.com')) {\n  // Accepting any issuer that contains 'trusted.com'\n}"}], "secure_examples": [{"code": "const metadata = fetchAuthorizationServerMetadata();\nif (metadata.issuer !== expectedIssuer) {\n  throw new Error('Invalid issuer');\n}"}, {"code": "const issuer = metadata.issuer;\nif (issuer === expectedIssuer) {\n  // Proceed with authentication\n} else {\n  throw new Error('Unauthorized issuer');\n}"}], "verification_steps": ["Check that the issuer URL in the authorization server metadata matches the pre-configured issuer URL exactly.", "Ensure that there are no wildcards or partial matches being accepted.", "Review error handling to confirm that invalid issuer URLs are properly rejected."], "common_mistakes": ["Using loose string comparison instead of strict equality checks.", "Failing to validate the issuer URL at all.", "Allowing issuer URLs with wildcards or partial matches."], "related_cwe": ["CWE-290: Authentication Bypass by Spoofing", "CWE-287: Improper Authentication"], "related_capec": ["CAPEC-116: Session Fixation", "CAPEC-159: Impersonation of a User"], "attack_flow": "An attacker sets up a malicious authorization server that mimics a legitimate one. They trick the client into accepting the malicious server's metadata by providing an incorrect issuer URL. If the client does not validate the issuer against a pre-configured list, it may accept the malicious server's responses, leading to unauthorized access to user data and potential account takeovers."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.5", "section_name": "OIDC Client", "req_id": "V10.5.4", "req_description": "Verify that the client validates that the ID Token is intended to be used for that client (audience) by checking that the 'aud' claim from the token is equal to the 'client_id' value for the client.", "level": 2, "explanation": "This requirement ensures that the client application checks the 'aud' (audience) claim in the ID Token to confirm that the token is meant for it. This prevents tokens issued for one client from being used by another, thereby ensuring that only authorized clients can access the user's information.", "threats_mitigated": ["Token misuse", "Impersonation attacks", "Cross-client attacks"], "insecure_examples": [{"code": "if (token.aud !== clientId) { throw new Error('Invalid audience'); }"}, {"code": "if (!token.aud) { return; } // Fails to check audience"}], "secure_examples": [{"code": "if (token.aud === clientId) { // proceed with processing the token } else { throw new Error('Invalid audience'); }"}, {"code": "if (token.aud && token.aud === clientId) { // valid audience, proceed } else { throw new Error('Invalid audience'); }"}], "verification_steps": ["Check if the 'aud' claim is present in the ID Token.", "Verify that the 'aud' claim matches the expected 'client_id'.", "Ensure that any errors related to audience validation are logged."], "common_mistakes": ["Not checking the 'aud' claim at all.", "Assuming the token is valid without validating the audience.", "Using a hardcoded client ID instead of a dynamic one."], "related_cwe": ["CWE-287", "CWE-20"], "related_capec": ["CAPEC-137", "CAPEC-154"], "attack_flow": "An attacker obtains a valid ID Token that was issued for a different client. If the client application does not validate the 'aud' claim, the attacker can use this token to impersonate a legitimate user, gaining unauthorized access to resources or sensitive information."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.5", "section_name": "OIDC Client", "req_id": "V10.5.5", "req_description": "Verify that, when using OIDC back-channel logout, the relying party mitigates denial of service through forced logout and cross-JWT confusion in the logout flow. The client must verify that the logout token is correctly typed with a value of 'logout+jwt', contains the 'event' claim with the correct member name, and does not contain a 'nonce' claim. Note that it is also recommended to have a short expiration (e.g., 2 minutes).", "level": "2", "explanation": "This requirement ensures that when a user logs out of an application using OpenID Connect (OIDC), the logout process is secure against potential denial of service attacks and confusion between different JWTs. Specifically, it mandates that the logout token must be of a specific type, must include certain claims, and must not include claims that could lead to vulnerabilities. By enforcing these checks, applications can prevent attackers from exploiting the logout flow to disrupt services or impersonate users.", "threats_mitigated": ["Denial of Service (DoS)", "Cross-JWT confusion", "Session fixation attacks"], "insecure_examples": [{"code": "if (logoutToken.type !== 'logout+jwt') { throw new Error('Invalid token type'); }", "description": "This code does not validate the presence of required claims or the absence of the 'nonce' claim."}, {"code": "const claims = parseJWT(logoutToken); if (!claims.event) { throw new Error('Missing event claim'); }", "description": "This code fails to check the type of the token and does not handle the 'nonce' claim properly."}], "secure_examples": [{"code": "if (logoutToken.type === 'logout+jwt' && claims.event && !claims.nonce) { /* proceed with logout */ } else { throw new Error('Invalid logout token'); }", "description": "This code correctly checks the token type, ensures the presence of the 'event' claim, and confirms that the 'nonce' claim is absent."}, {"code": "const claims = parseJWT(logoutToken); if (claims.exp < Date.now() / 1000) { throw new Error('Token expired'); }", "description": "This code checks for token expiration, ensuring that logout tokens are only valid for a short duration."}], "verification_steps": ["Check that the logout token type is 'logout+jwt'.", "Verify that the token contains the 'event' claim with the correct member name.", "Ensure that the token does not contain a 'nonce' claim.", "Confirm that the token has a short expiration time (e.g., 2 minutes).", "Review the logout flow for potential denial of service vulnerabilities."], "common_mistakes": ["Neglecting to validate the type of the logout token.", "Failing to check for the presence of required claims like 'event'.", "Allowing the 'nonce' claim in the logout token.", "Not implementing a short expiration time for logout tokens."], "related_cwe": ["CWE-20", "CWE-287", "CWE-295"], "related_capec": ["CAPEC-138", "CAPEC-145", "CAPEC-153"], "attack_flow": "An attacker could exploit a vulnerability in the logout flow by sending a crafted logout token that either lacks the required claims or includes a 'nonce' claim. If the relying party does not validate the token properly, the attacker could force a logout of legitimate users, causing a denial of service. Additionally, if the logout token is not correctly typed or validated, the attacker could confuse the logout process with other JWTs, leading to unauthorized access or session fixation."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.6", "section_name": "OpenID Provider", "req_id": "V10.6.1", "req_description": "Verify that the OpenID Provider only allows values 'code', 'ciba', 'id_token', or 'id_token code' for response mode. Note that 'code' is preferred over 'id_token code' (the OIDC Hybrid flow), and 'token' (any Implicit flow) must not be used.", "level": 2, "explanation": "This requirement ensures that the OpenID Provider restricts the response modes to a predefined set of secure options. Using only 'code', 'ciba', 'id_token', or 'id_token code' helps mitigate risks associated with less secure flows, such as the Implicit flow, which exposes tokens directly in the URL and can lead to security vulnerabilities.", "threats_mitigated": ["Authorization Code Interception", "Token Leakage", "Phishing Attacks", "Open Redirects"], "insecure_examples": ["response_mode=token", "response_mode=implicit"], "secure_examples": ["response_mode=code", "response_mode=id_token", "response_mode=ciba"], "verification_steps": ["Review the OpenID Provider configuration.", "Check the allowed response modes in the application settings.", "Ensure that only 'code', 'ciba', 'id_token', or 'id_token code' are permitted.", "Verify that 'token' or any Implicit flow options are not present."], "common_mistakes": ["Allowing the 'token' response mode due to misunderstanding of OAuth flows.", "Not validating the response mode against a whitelist.", "Using legacy or outdated configurations that permit insecure response modes."], "related_cwe": ["CWE-200: Information Exposure", "CWE-287: Improper Authentication", "CWE-295: Improper Certificate Validation"], "related_capec": ["CAPEC-137: OAuth Token Leakage", "CAPEC-154: OpenID Authentication Bypass"], "attack_flow": "An attacker could exploit this requirement by manipulating the response mode parameter to 'token' or other insecure values. If the OpenID Provider accepts these values, the attacker could intercept access tokens or authorization codes, leading to unauthorized access to user data or services."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.6", "section_name": "OpenID Provider", "req_id": "V10.6.2", "req_description": "Verify that the OpenID Provider mitigates denial of service through forced logout. By obtaining explicit confirmation from the end-user or, if present, validating parameters in the logout request (initiated by the relying party), such as the 'id_token_hint'.", "level": 2, "explanation": "This requirement ensures that the OpenID Provider implements mechanisms to prevent denial of service attacks that can occur through forced logouts. It requires the provider to confirm the user's intent to log out, either through user interaction or by validating specific parameters in the logout request. This helps prevent malicious actors from logging out users without their consent, which could lead to service disruptions.", "threats_mitigated": ["Denial of Service (DoS)", "User session hijacking", "Account takeover"], "insecure_examples": [{"code": "GET /logout?id_token_hint=abc123&force=true"}, {"code": "POST /logout without user confirmation"}], "secure_examples": [{"code": "GET /logout?id_token_hint=abc123&force=true&confirm=true"}, {"code": "POST /logout with user confirmation prompt"}], "verification_steps": ["Check if the logout endpoint requires user confirmation.", "Verify that the 'id_token_hint' is validated against the user's session.", "Ensure that logout requests are logged and monitored for unusual patterns.", "Test for forced logout scenarios to confirm that they are handled appropriately."], "common_mistakes": ["Failing to validate the 'id_token_hint' parameter.", "Not implementing user confirmation for logout requests.", "Allowing logout requests without proper authentication checks."], "related_cwe": ["CWE-307: Improper Restriction of Excessive Authentication Attempts", "CWE-20: Improper Input Validation"], "related_capec": ["CAPEC-114: Forced Logout", "CAPEC-153: Session Fixation"], "attack_flow": "An attacker sends a logout request to the OpenID Provider with a valid 'id_token_hint' for a user session they do not control, potentially forcing the user to log out without their consent. This can disrupt the user's access to the application and may lead to further attacks such as session fixation or account takeover."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.7", "section_name": "Consent Management", "req_id": "V10.7.1", "req_description": "Verify that the authorization server ensures that the user consents to each authorization request. If the identity of the client cannot be assured, the authorization server must always explicitly prompt the user for consent.", "level": "2", "explanation": "This requirement mandates that users must be informed and give explicit consent for each request made by an application to access their resources. If the authorization server cannot verify the identity of the requesting client, it must prompt the user for consent to ensure they are aware of what data is being accessed and by whom. This is crucial for protecting user privacy and maintaining trust.", "threats_mitigated": ["Unauthorized access to user data", "Phishing attacks", "Client impersonation", "Data leakage"], "insecure_examples": ["if (clientIdentityNotVerified) { authorizeUser(); }", "authorizeUserWithoutPrompt();"], "secure_examples": ["if (clientIdentityNotVerified) { promptUserForConsent(); }", "authorizeUserWithPrompt();"], "verification_steps": ["Check if the authorization server prompts for user consent on each request.", "Verify that the consent prompt includes details about the client and requested resources.", "Ensure that the system logs consent decisions for auditing purposes.", "Review the implementation of client identity verification."], "common_mistakes": ["Assuming consent is granted without explicit user confirmation.", "Failing to provide clear information about what data is being accessed.", "Not logging consent decisions for future reference.", "Using generic consent prompts that do not specify the client identity."], "related_cwe": ["CWE-345", "CWE-20", "CWE-200"], "related_capec": ["CAPEC-132", "CAPEC-157"], "attack_flow": "An attacker could impersonate a legitimate client application and send an authorization request to the user. If the authorization server does not verify the client's identity and does not prompt the user for consent, the user may unknowingly grant access to their sensitive information, leading to unauthorized data exposure."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.7", "section_name": "Consent Management", "req_id": "V10.7.2", "req_description": "Verify that when the authorization server prompts for user consent, it presents sufficient and clear information about what is being consented to. When applicable, this should include the nature of the requested authorizations (typically based on scope, resource server, Rich Authorization Requests (RAR) authorization details), the identity of the authorized application, and the lifetime of these authorizations.", "level": "2", "explanation": "This requirement ensures that users are fully informed about the permissions they are granting when they consent to an application accessing their data. It is critical for user trust and security that the consent dialog clearly states what data will be accessed, how it will be used, and for how long. This transparency helps users make informed decisions about their privacy and data sharing.", "threats_mitigated": ["Unauthorized data access", "User confusion leading to consent errors", "Phishing attacks through misleading consent prompts"], "insecure_examples": ["Authorization server displays a generic consent message without specifying the application or the data being accessed.", "Consent prompt only states 'This application requires access to your data' without details on the scope."], "secure_examples": ["Authorization server displays a detailed consent message stating: 'Application XYZ requests access to your email and contacts for personalized recommendations. This access will last for 30 days.'", "Consent prompt includes a clear breakdown of the requested scopes and their purposes."], "verification_steps": ["Check that the consent prompt includes the application's name and purpose.", "Verify that the consent prompt lists all requested scopes with clear descriptions.", "Ensure that the duration of the consent is specified.", "Review user feedback on the clarity of the consent prompt."], "common_mistakes": ["Failing to provide detailed information about the data being accessed.", "Using technical jargon that confuses users.", "Not specifying the duration for which consent is granted."], "related_cwe": ["CWE-20: Improper Input Validation", "CWE-75: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')"], "related_capec": ["CAPEC-112: Phishing", "CAPEC-148: Credential Harvesting"], "attack_flow": "An attacker could exploit vague or misleading consent prompts to trick users into granting excessive permissions, leading to unauthorized access to sensitive data. For example, if a consent prompt does not clearly indicate the data being accessed, users may unknowingly allow access to their personal information."}
{"chapter_id": "V10", "chapter_name": "OAuth and OIDC", "section_id": "V10.7", "section_name": "Consent Management", "req_id": "V10.7.3", "req_description": "Verify that the user can review, modify, and revoke consents which the user has granted through the authorization server.", "level": 2, "explanation": "This requirement ensures that users have control over the permissions they grant to applications. Users should be able to see what consents they have given, change them if necessary, and revoke them at any time. This is crucial for maintaining user privacy and trust.", "threats_mitigated": ["Unauthorized access to user data", "Data leakage", "User consent abuse", "Phishing attacks"], "insecure_examples": [{"code": "if (userConsentGranted) { accessUserData(); } // No option to revoke consent"}, {"code": "grantConsent(userId); // Consent granted without user review"}], "secure_examples": [{"code": "if (userConsentGranted) { showConsentOptions(); } // User can review and revoke consent"}, {"code": "grantConsent(userId); // Consent granted after user review"}], "verification_steps": ["Check if users can view their granted consents.", "Verify that users can modify existing consents.", "Ensure users can revoke consents at any time.", "Test the interface for clarity and usability."], "common_mistakes": ["Not providing a clear interface for users to manage consents.", "Failing to notify users when their consent is being used.", "Not allowing users to revoke consent easily.", "Assuming users remember what consents they granted."], "related_cwe": ["CWE-284", "CWE-200", "CWE-275"], "related_capec": ["CAPEC-131", "CAPEC-137"], "attack_flow": "An attacker may exploit the lack of consent management by tricking users into granting permissions without their knowledge. If users cannot revoke or modify these consents, the attacker can access sensitive data or perform actions on behalf of the user without their consent, leading to potential data breaches and privacy violations."}
{"chapter_id": "V11", "chapter_name": "Cryptography", "section_id": "V11.1", "section_name": "Cryptographic Inventory and Documentation", "req_id": "V11.1.1", "req_description": "Verify that there is a documented policy for management of cryptographic keys and a cryptographic key lifecycle that follows a key management standard such as NIST SP 800-57. This should include ensuring that keys are not overshared (for example, with more than two entities for shared secrets and more than one entity for private keys).", "level": 2, "explanation": "This requirement emphasizes the importance of having a structured approach to managing cryptographic keys throughout their lifecycle. It mandates the documentation of policies that govern key generation, distribution, storage, usage, rotation, and destruction. Adhering to established standards like NIST SP 800-57 ensures that cryptographic practices are robust and reduce the risk of key compromise.", "threats_mitigated": ["Key compromise", "Unauthorized access to sensitive data", "Data breaches due to weak key management"], "insecure_examples": ["const char* key = \"my_secret_key\"; // Hardcoded key in source code", "key = getSharedSecret(); // Shared secret without proper access control"], "secure_examples": ["const char* key = getKeyFromSecureStore(); // Retrieve key from a secure storage", "key = getSharedSecretWithAccessControl(); // Retrieve shared secret with strict access control"], "verification_steps": ["Check for the existence of a documented key management policy.", "Review the policy to ensure it aligns with NIST SP 800-57.", "Verify that the policy includes guidelines on key sharing limits.", "Examine implementation to ensure adherence to the documented policy."], "common_mistakes": ["Failing to document key management policies.", "Oversharing keys without proper access controls.", "Neglecting to rotate keys regularly.", "Using hardcoded keys in source code."], "related_cwe": ["CWE-320: Key Management Errors", "CWE-326: Inadequate Encryption Strength", "CWE-259: Use of Hard-coded Password"], "related_capec": ["CAPEC-113: Key Recovery Attack", "CAPEC-132: Cryptographic Key Exposure", "CAPEC-138: Cryptographic Key Management Attack"], "attack_flow": "An attacker may exploit weak key management by gaining access to cryptographic keys that are overshared or poorly documented. Once they obtain these keys, they can decrypt sensitive data, impersonate users, or perform unauthorized actions within the system, leading to potential data breaches and loss of confidentiality."}
{"chapter_id": "V11", "chapter_name": "Cryptography", "section_id": "V11.1", "section_name": "Cryptographic Inventory and Documentation", "req_id": "V11.1.2", "req_description": "Verify that a cryptographic inventory is performed, maintained, regularly updated, and includes all cryptographic keys, algorithms, and certificates used by the application. It must also document where keys can and cannot be used in the system, and the types of data that can and cannot be protected using the keys.", "level": "2", "explanation": "This requirement emphasizes the importance of maintaining a comprehensive inventory of all cryptographic materials used within an application. This includes documenting the specific algorithms and keys employed, their usage contexts, and the types of sensitive data they protect. Regular updates ensure that any changes in cryptographic practices or technologies are reflected, thereby maintaining security integrity.", "threats_mitigated": ["Key compromise", "Improper key usage", "Data exposure due to weak cryptography", "Unintended data access"], "insecure_examples": ["const crypto = require('crypto');\n// No documentation of keys or algorithms used\nconst secret = 'my_secret_key';\nconst hash = crypto.createHash('sha256').update('my_data').digest('hex');", "const key = '12345';\n// Using a hardcoded key without any inventory or documentation\nconst cipher = crypto.createCipher('aes-256-cbc', key);"], "secure_examples": ["const crypto = require('crypto');\nconst key = getKeyFromInventory('my_key_id');\nconst hash = crypto.createHash('sha256').update('my_data').digest('hex');", "const key = getKeyFromInventory('secure_key_id');\nconst cipher = crypto.createCipher('aes-256-cbc', key); // Key is retrieved from a documented inventory"], "verification_steps": ["Check if a cryptographic inventory document exists.", "Verify that all cryptographic keys, algorithms, and certificates are listed.", "Ensure that the inventory is regularly updated.", "Confirm that usage contexts for keys are documented.", "Review the types of data protected by each key."], "common_mistakes": ["Failing to document all cryptographic keys and algorithms.", "Using hardcoded keys without proper inventory management.", "Neglecting to update the inventory after changes in cryptographic practices.", "Not specifying where keys can and cannot be used."], "related_cwe": ["CWE-320: Key Management Errors", "CWE-310: Cryptographic Issues"], "related_capec": ["CAPEC-137: Key Recovery Attack", "CAPEC-138: Key Compromise Attack"], "attack_flow": "An attacker may exploit the lack of a cryptographic inventory by discovering weak or hardcoded keys. If keys are not documented, the attacker can use them in unintended contexts, leading to unauthorized data access or manipulation. Furthermore, if cryptographic materials are outdated or improperly managed, the attacker can leverage these weaknesses to compromise the integrity and confidentiality of sensitive information."}
{"chapter_id": "V11", "chapter_name": "Cryptography", "section_id": "V11.1", "section_name": "Cryptographic Inventory and Documentation", "req_id": "V11.1.3", "req_description": "Verify that cryptographic discovery mechanisms are employed to identify all instances of cryptography in the system, including encryption, hashing, and signing operations.", "level": "3", "explanation": "This requirement mandates that organizations implement mechanisms to discover and document all cryptographic operations within their systems. This includes identifying where encryption, hashing, and signing are utilized, ensuring that all cryptographic methods are accounted for and managed appropriately. This helps in assessing the security of cryptographic implementations and ensuring compliance with security policies.", "threats_mitigated": ["Unauthorized access to sensitive data", "Data integrity attacks", "Weak cryptographic practices", "Misconfiguration of cryptographic systems"], "insecure_examples": [{"code_snippet": "String password = \"password123\"; // Storing plaintext password"}, {"code_snippet": "public void encryptData() { Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\"); // Using insecure mode without IV }"}], "secure_examples": [{"code_snippet": "String hashedPassword = BCrypt.hashpw(password, BCrypt.gensalt()); // Storing hashed password securely"}, {"code_snippet": "public void encryptData() { Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\"); // Using secure mode with proper IV management }"}], "verification_steps": ["Check for documentation of all cryptographic algorithms used in the application.", "Verify that all cryptographic keys are stored securely and managed properly.", "Ensure that there is a process for regularly reviewing and updating cryptographic methods.", "Confirm that all instances of cryptography are logged and monitored."], "common_mistakes": ["Failing to document all cryptographic operations in the system.", "Using outdated or weak cryptographic algorithms.", "Not managing cryptographic keys securely.", "Ignoring the need for regular reviews of cryptographic practices."], "related_cwe": ["CWE-310", "CWE-327", "CWE-329"], "related_capec": ["CAPEC-102", "CAPEC-104", "CAPEC-138"], "attack_flow": "An attacker may exploit the lack of cryptographic discovery by identifying unprotected sensitive data or weak cryptographic implementations. If cryptographic operations are undocumented, it could lead to the use of insecure algorithms or configurations, making it easier for the attacker to compromise the confidentiality or integrity of the data."}
{"chapter_id": "V11", "chapter_name": "Cryptography", "section_id": "V11.1", "section_name": "Cryptographic Inventory and Documentation", "req_id": "V11.1.4", "req_description": "Verify that a cryptographic inventory is maintained. This must include a documented plan that outlines the migration path to new cryptographic standards, such as post-quantum cryptography, in order to react to future threats.", "level": 3, "explanation": "This requirement emphasizes the importance of maintaining an up-to-date inventory of cryptographic algorithms and protocols used within an application. It also necessitates having a strategic plan for transitioning to newer cryptographic standards as they become necessary, particularly in light of emerging threats such as quantum computing. This proactive approach ensures that the application remains secure against evolving attack vectors.", "threats_mitigated": ["Cryptographic algorithm compromise", "Inadequate response to emerging threats", "Use of deprecated cryptographic standards"], "insecure_examples": ["const cryptoAlgorithms = ['AES-128', 'SHA-1']; // No inventory or migration plan documented", "function useOldCrypto() { return 'Using deprecated algorithm'; } // Fails to consider future threats"], "secure_examples": ["const cryptoInventory = { algorithms: ['AES-256', 'SHA-256'], migrationPlan: 'Transition to post-quantum algorithms by 2025' };", "function secureCryptoUsage() { return 'Using current secure algorithms'; } // Follows documented migration plan"], "verification_steps": ["Check for a documented cryptographic inventory.", "Review the inventory for inclusion of current cryptographic standards.", "Ensure there is a documented migration plan for future cryptographic standards.", "Verify that the migration plan addresses potential threats such as quantum computing."], "common_mistakes": ["Failing to update the cryptographic inventory regularly.", "Neglecting to document the migration path for new standards.", "Using outdated cryptographic algorithms without a plan for replacement."], "related_cwe": ["CWE-310: Cryptographic Issues", "CWE-326: Inadequate Encryption Strength", "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"], "related_capec": ["CAPEC-139: Exploiting Weaknesses in Cryptographic Algorithms", "CAPEC-142: Cryptographic Key Recovery", "CAPEC-143: Cryptographic Key Exposure"], "attack_flow": "An attacker may exploit the lack of a cryptographic inventory by using known weaknesses in outdated algorithms to decrypt sensitive data. If there is no migration plan, the application may remain vulnerable to future threats, such as those posed by quantum computing, allowing attackers to break encryption easily."}
{"chapter_id": "V11", "chapter_name": "Cryptography", "section_id": "V11.2", "section_name": "Secure Cryptography Implementation", "req_id": "V11.2.1", "req_description": "Verify that industry-validated implementations (including libraries and hardware-accelerated implementations) are used for cryptographic operations.", "level": "2", "explanation": "This requirement emphasizes the importance of using cryptographic libraries and hardware implementations that have been validated by industry standards. It ensures that the cryptographic algorithms are implemented correctly and securely, reducing the risk of vulnerabilities due to poor implementation or outdated algorithms.", "threats_mitigated": ["Man-in-the-Middle (MitM) attacks", "Data breaches due to weak encryption", "Replay attacks", "Cryptographic attacks exploiting weak algorithms"], "insecure_examples": ["String plaintext = 'password';\nbyte[] key = new byte[16];\nSecretKeySpec secretKey = new SecretKeySpec(key, 'AES');\nCipher cipher = Cipher.getInstance('AES/ECB/PKCS5Padding');\ncipher.init(Cipher.ENCRYPT_MODE, secretKey);\nbyte[] encrypted = cipher.doFinal(plaintext.getBytes());", "Cipher cipher = Cipher.getInstance('AES'); // No validation of the implementation\ncipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, 'AES'));\nbyte[] encrypted = cipher.doFinal(data);"], "secure_examples": ["Cipher cipher = Cipher.getInstance('AES/GCM/NoPadding', 'BC'); // Using an industry-validated provider\ncipher.init(Cipher.ENCRYPT_MODE, secretKey, new GCMParameterSpec(128, iv));\nbyte[] encrypted = cipher.doFinal(plaintext.getBytes());", "Cipher cipher = Cipher.getInstance('AES/CBC/PKCS5Padding', 'SunJCE'); // Specifying a validated implementation\ncipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, 'AES'), new IvParameterSpec(iv));\nbyte[] encrypted = cipher.doFinal(data);"], "verification_steps": ["Check that cryptographic libraries are from reputable sources.", "Ensure that the library versions are up-to-date and validated.", "Review the configuration settings for the cryptographic operations.", "Verify that the cryptographic algorithms used are recommended by standards (e.g., NIST).", "Check for any known vulnerabilities associated with the chosen libraries."], "common_mistakes": ["Using outdated or deprecated cryptographic libraries.", "Implementing custom cryptographic algorithms instead of using validated libraries.", "Neglecting to validate the configuration of cryptographic operations.", "Using weak or insecure default settings for cryptographic algorithms."], "related_cwe": ["CWE-326: Inadequate Encryption Strength", "CWE-327: Use of a Broken or Risky Cryptographic Algorithm", "CWE-330: Use of Insufficiently Random Values"], "related_capec": ["CAPEC-112: Cryptographic Algorithm Exploitation", "CAPEC-136: Cryptographic Key Recovery", "CAPEC-139: Cryptographic Protocol Manipulation"], "attack_flow": "An attacker could exploit a weak or improperly implemented cryptographic operation by intercepting encrypted data that can be decrypted due to vulnerabilities in the algorithm or implementation. This could lead to unauthorized access to sensitive information, allowing attackers to read, modify, or replay messages without detection."}
{"chapter_id": "V11", "chapter_name": "Cryptography", "section_id": "V11.2", "section_name": "Secure Cryptography Implementation", "req_id": "V11.2.2", "req_description": "Verify that the application is designed with crypto agility such that random number, authenticated encryption, MAC, or hashing algorithms, key lengths, rounds, ciphers and modes can be reconfigured, upgraded, or swapped at any time, to protect against cryptographic breaks. Similarly, it must also be possible to replace keys and passwords and re-encrypt data. This will allow for seamless upgrades to post-quantum cryptography (PQC), once high-assurance implementations of approved PQC schemes or standards are widely available.", "level": 2, "explanation": "Crypto agility refers to the ability of an application to adapt to new cryptographic algorithms and standards as they become available or necessary. This includes the capability to update cryptographic primitives without extensive changes to the application codebase, thereby ensuring that the application remains secure against emerging threats and vulnerabilities. It is crucial for maintaining the confidentiality, integrity, and authenticity of data, especially as cryptographic standards evolve over time.", "threats_mitigated": ["Cryptographic attacks", "Key compromise", "Algorithm deprecation", "Post-quantum threats"], "insecure_examples": [{"code_snippet": "cipher = AES.new(key, AES.MODE_ECB)", "description": "Using a fixed AES mode without the ability to change it or upgrade to a more secure mode."}, {"code_snippet": "hash = SHA256(data)", "description": "Hardcoding a specific hashing algorithm without the option to switch to a stronger algorithm."}], "secure_examples": [{"code_snippet": "cipher = get_cipher_from_config()", "description": "Using a configuration-driven approach to select the cipher and mode."}, {"code_snippet": "hash = get_hash_algorithm_from_config(data)", "description": "Dynamically selecting the hashing algorithm based on a configuration setting."}], "verification_steps": ["Check if the application allows configuration of cryptographic algorithms.", "Verify that the application can switch between different key lengths and modes.", "Ensure there is a mechanism to update cryptographic keys and re-encrypt data.", "Review documentation for procedures on updating to post-quantum cryptography."], "common_mistakes": ["Hardcoding cryptographic parameters in the code.", "Failing to provide a mechanism for updating cryptographic algorithms.", "Not considering the need for future-proofing against quantum attacks."], "related_cwe": ["CWE-327", "CWE-326", "CWE-310"], "related_capec": ["CAPEC-137", "CAPEC-147"], "attack_flow": "An attacker could exploit a lack of crypto agility by leveraging known vulnerabilities in outdated cryptographic algorithms or by compromising keys that cannot be replaced or updated. This could lead to unauthorized access to sensitive data or the ability to forge messages, ultimately undermining the security of the entire application."}
{"chapter_id": "V11", "chapter_name": "Cryptography", "section_id": "V11.2", "section_name": "Secure Cryptography Implementation", "req_id": "V11.2.3", "req_description": "Verify that all cryptographic primitives utilize a minimum of 128-bits of security based on the algorithm, key size, and configuration. For example, a 256-bit ECC key provides roughly 128 bits of security where RSA requires a 3072-bit key to achieve 128 bits of security.", "level": "2", "explanation": "This requirement emphasizes the importance of using cryptographic algorithms and key sizes that provide a minimum level of security. Cryptographic primitives, such as symmetric and asymmetric encryption algorithms, have different key size requirements to ensure that the security they provide is robust against brute-force attacks. This requirement helps ensure that applications are using cryptography that is considered secure by current standards.", "threats_mitigated": ["Brute-force attacks", "Cryptographic attacks", "Data breaches", "Unauthorized data access"], "insecure_examples": [{"code": "String encryptedData = encryptData(data, \"RSA\", 2048); // Using RSA with insufficient key size"}, {"code": "String encryptedData = encryptData(data, \"AES\", 128); // Using AES with insufficient key size"}], "secure_examples": [{"code": "String encryptedData = encryptData(data, \"RSA\", 3072); // Using RSA with sufficient key size"}, {"code": "String encryptedData = encryptData(data, \"AES\", 256); // Using AES with sufficient key size"}], "verification_steps": ["Review the cryptographic libraries used in the application.", "Check the key sizes specified for each cryptographic algorithm.", "Ensure that all cryptographic operations utilize keys that provide at least 128 bits of security.", "Consult current cryptographic standards and guidelines to verify key size adequacy."], "common_mistakes": ["Using outdated or weak cryptographic algorithms.", "Selecting key sizes that do not meet current security standards.", "Failing to update cryptographic practices as standards evolve."], "related_cwe": ["CWE-327", "CWE-310", "CWE-326"], "related_capec": ["CAPEC-104", "CAPEC-106"], "attack_flow": "An attacker may exploit weak cryptographic implementations by using brute-force techniques to guess encryption keys. If the keys used are below the minimum security threshold, the attacker can potentially decrypt sensitive data or impersonate users, leading to data breaches or unauthorized access."}
{"chapter_id": "V11", "chapter_name": "Cryptography", "section_id": "V11.2", "section_name": "Secure Cryptography Implementation", "req_id": "V11.2.4", "req_description": "Verify that all cryptographic operations are constant-time, with no 'short-circuit' operations in comparisons, calculations, or returns, to avoid leaking information.", "level": "3", "explanation": "This requirement emphasizes the importance of implementing cryptographic operations in a manner that does not reveal information through timing variations. When operations are not constant-time, attackers can exploit timing differences to infer sensitive information, such as keys or data. Constant-time algorithms ensure that execution time does not depend on input values, thereby mitigating side-channel attacks.", "threats_mitigated": ["Timing attacks", "Side-channel attacks", "Information leakage"], "insecure_examples": ["if (a == b) { return true; } else { return false; } // Short-circuit evaluation", "for (int i = 0; i < key.length; i++) { if (key[i] != expectedKey[i]) return false; } // Comparison leaks information"], "secure_examples": ["return compareConstantTime(a, b); // A function that compares in constant time", "for (int i = 0; i < key.length; i++) { result ^= key[i] ^ expectedKey[i]; } return result == 0; // Constant-time comparison"], "verification_steps": ["Review cryptographic code for timing dependencies.", "Ensure that all comparisons and calculations are implemented in constant-time.", "Check for any use of short-circuiting logic in conditional statements.", "Test the implementation with varying inputs to confirm consistent execution time."], "common_mistakes": ["Using standard comparison operators that may short-circuit.", "Not considering the impact of branching on execution time.", "Implementing cryptographic algorithms without awareness of timing attacks."], "related_cwe": ["CWE-203: Observable Timing Discrepancy", "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"], "related_capec": ["CAPEC-135: Timing Attack", "CAPEC-152: Side-Channel Attack"], "attack_flow": "An attacker observes the time taken for cryptographic operations. By analyzing variations in execution time based on different inputs, the attacker can deduce sensitive information, such as cryptographic keys or plaintext data. This can lead to unauthorized access or data breaches."}
{"chapter_id": "V11", "chapter_name": "Cryptography", "section_id": "V11.2", "section_name": "Secure Cryptography Implementation", "req_id": "V11.2.5", "req_description": "Verify that all cryptographic modules fail securely, and errors are handled in a way that does not enable vulnerabilities, such as Padding Oracle attacks.", "level": "3", "explanation": "This requirement emphasizes the importance of ensuring that cryptographic modules do not expose sensitive information when they encounter errors. Secure failure means that the system should not leak information that could be exploited by an attacker, such as error messages that reveal details about the cryptographic process or the underlying implementation. Proper handling of errors can prevent attacks that exploit predictable error responses, such as Padding Oracle attacks, where an attacker can gain information about the plaintext by observing how the system responds to different inputs.", "threats_mitigated": ["Padding Oracle attacks", "Information leakage", "Cryptographic key exposure", "Replay attacks"], "insecure_examples": [{"code": "if (decrypt(data) == null) { throw new Exception(\"Decryption failed\"); }"}, {"code": "if (ciphertext.length() != expectedLength) { return \"Invalid ciphertext length\"; }"}], "secure_examples": [{"code": "try { decrypt(data); } catch (Exception e) { log.error(\"Decryption error occurred\"); }"}, {"code": "if (ciphertext.length() != expectedLength) { throw new SecurityException(\"Invalid input\"); }"}], "verification_steps": ["Review error handling in cryptographic modules.", "Ensure that error messages do not reveal sensitive information.", "Check for consistent logging of errors without exposing details.", "Test the application for predictable responses to invalid inputs."], "common_mistakes": ["Exposing detailed error messages to users.", "Using default error handling that reveals implementation details.", "Failing to log errors securely.", "Not considering the impact of error messages on cryptographic operations."], "related_cwe": ["CWE-209", "CWE-20", "CWE-203"], "related_capec": ["CAPEC-137", "CAPEC-151"], "attack_flow": "An attacker sends a series of crafted inputs to the cryptographic module, observing the system's responses. If the system reveals different error messages or response times based on the input, the attacker can use this information to infer details about the plaintext or the cryptographic keys, ultimately leading to successful decryption of sensitive data."}
{"chapter_id": "V11", "chapter_name": "Cryptography", "section_id": "V11.3", "section_name": "Encryption Algorithms", "req_id": "V11.3.1", "req_description": "Verify that insecure block modes (e.g., ECB) and weak padding schemes (e.g., PKCS#1 v1.5) are not used.", "level": "1", "explanation": "This requirement emphasizes the importance of using secure encryption algorithms and modes. Insecure block modes, such as ECB (Electronic Codebook), do not provide adequate security as they can reveal patterns in the plaintext. Similarly, weak padding schemes like PKCS#1 v1.5 can be exploited through various attacks, including padding oracle attacks. Developers must ensure that only secure modes and padding schemes are utilized to protect sensitive data.", "threats_mitigated": ["Data exposure through pattern recognition", "Padding oracle attacks", "Replay attacks"], "insecure_examples": [{"code": "Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");"}, {"code": "Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");"}], "secure_examples": [{"code": "Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");"}, {"code": "Cipher cipher = Cipher.getInstance(\"RSA/OAEPWithSHA-256AndMGF1Padding\");"}], "verification_steps": ["Check the encryption algorithm used in the code.", "Verify the block mode of the encryption algorithm.", "Ensure that secure padding schemes are implemented.", "Review documentation for the cryptographic library used."], "common_mistakes": ["Using ECB mode for encryption due to its simplicity.", "Not validating the padding scheme used in RSA encryption.", "Failing to update legacy code that may still use insecure algorithms."], "related_cwe": ["CWE-327", "CWE-326", "CWE-310"], "related_capec": ["CAPEC-120", "CAPEC-139"], "attack_flow": "An attacker can exploit the use of insecure block modes like ECB by analyzing the ciphertext for patterns, which may reveal sensitive information. For example, if the same plaintext is encrypted multiple times, the same ciphertext will be produced, allowing the attacker to infer relationships between the plaintexts. In the case of weak padding schemes, an attacker can manipulate the ciphertext and exploit the padding validation process to recover plaintext data."}
{"chapter_id": "V11", "chapter_name": "Cryptography", "section_id": "V11.3", "section_name": "Encryption Algorithms", "req_id": "V11.3.2", "req_description": "Verify that only approved ciphers and modes such as AES with GCM are used.", "level": 1, "explanation": "This requirement emphasizes the importance of using strong and approved cryptographic algorithms and modes to ensure the confidentiality and integrity of sensitive data. Using outdated or weak ciphers can expose data to unauthorized access and attacks.", "threats_mitigated": ["Data Breach", "Man-in-the-Middle Attack", "Replay Attack", "Cipher Block Chaining (CBC) Attacks"], "insecure_examples": [{"code": "Cipher cipher = Cipher.getInstance(\"DES\");"}, {"code": "Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");"}], "secure_examples": [{"code": "Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\");"}], "verification_steps": ["Review the cryptographic libraries used in the application.", "Check the configuration for cipher algorithms and modes.", "Ensure that only approved ciphers like AES with GCM are implemented.", "Look for any hardcoded cipher specifications in the codebase."], "common_mistakes": ["Using outdated ciphers like DES or 3DES.", "Implementing custom cryptographic algorithms instead of using established libraries.", "Neglecting to update cipher configurations in response to new vulnerabilities."], "related_cwe": ["CWE-327", "CWE-326", "CWE-310"], "related_capec": ["CAPEC-154", "CAPEC-60"], "attack_flow": "An attacker may exploit weak or outdated ciphers to decrypt sensitive data transmitted over the network. By intercepting the data, they can use known vulnerabilities in those ciphers to gain access to plaintext information, leading to potential data breaches and unauthorized access."}
{"chapter_id": "V11", "chapter_name": "Cryptography", "section_id": "V11.3", "section_name": "Encryption Algorithms", "req_id": "V11.3.3", "req_description": "Verify that encrypted data is protected against unauthorized modification preferably by using an approved authenticated encryption method or by combining an approved encryption method with an approved MAC algorithm.", "level": 2, "explanation": "This requirement emphasizes the importance of ensuring that encrypted data cannot be tampered with by unauthorized parties. It suggests using authenticated encryption methods, which provide both confidentiality and integrity, or combining encryption with a Message Authentication Code (MAC) to ensure that any modifications to the encrypted data can be detected.", "threats_mitigated": ["Data tampering", "Replay attacks", "Man-in-the-middle attacks"], "insecure_examples": [{"code": "ciphertext = encrypt(plaintext, key); // No integrity check"}, {"code": "ciphertext = encrypt(plaintext, key); mac = generateMAC(ciphertext); // MAC not verified during decryption"}], "secure_examples": [{"code": "ciphertext = encrypt(plaintext, key); mac = generateMAC(ciphertext); // Store both securely"}, {"code": "if (verifyMAC(ciphertext, mac)) { plaintext = decrypt(ciphertext, key); } else { throw new Exception('Data integrity check failed'); }"}], "verification_steps": ["Check if an authenticated encryption method is used.", "Verify that a MAC is used in conjunction with encryption.", "Ensure that the MAC is verified during decryption.", "Review the implementation for any potential weaknesses."], "common_mistakes": ["Using encryption without integrity checks.", "Neglecting to verify the MAC before decrypting.", "Using outdated or weak encryption algorithms."], "related_cwe": ["CWE-329", "CWE-345", "CWE-300"], "related_capec": ["CAPEC-112", "CAPEC-125"], "attack_flow": "An attacker intercepts encrypted data and modifies it. If the data is not protected by an integrity check, the recipient may decrypt and use the altered data without knowing it has been tampered with, leading to unauthorized actions or data corruption."}
{"chapter_id": "V11", "chapter_name": "Cryptography", "section_id": "V11.3", "section_name": "Encryption Algorithms", "req_id": "V11.3.4", "req_description": "Verify that nonces, initialization vectors, and other single-use numbers are not used for more than one encryption key and data-element pair. The method of generation must be appropriate for the algorithm being used.", "level": "3", "explanation": "This requirement ensures that nonces and initialization vectors (IVs) are unique and not reused across different encryption operations. Reusing these values can lead to vulnerabilities such as replay attacks or key recovery attacks. Proper generation methods, such as cryptographically secure random number generators, should be employed to ensure uniqueness and unpredictability.", "threats_mitigated": ["Replay Attacks", "Key Recovery Attacks", "Chosen Plaintext Attacks", "Ciphertext Manipulation"], "insecure_examples": ["String nonce = \"123456\"; // Hardcoded nonce used multiple times\nCipher.encrypt(key, nonce, data);", "byte[] iv = new byte[16]; // Same IV reused for multiple encryptions\nCipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(iv));"], "secure_examples": ["SecureRandom random = new SecureRandom();\nbyte[] nonce = new byte[12];\nrandom.nextBytes(nonce);\nCipher.encrypt(key, nonce, data);", "byte[] iv = new byte[16];\nSecureRandom random = new SecureRandom();\nrandom.nextBytes(iv);\nCipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(iv));"], "verification_steps": ["Check that nonces and IVs are generated using a cryptographically secure random number generator.", "Verify that nonces and IVs are unique for each encryption operation.", "Review the code for any hardcoded values that may be reused.", "Ensure that the method of generation is appropriate for the encryption algorithm used."], "common_mistakes": ["Using static or hardcoded values for nonces or IVs.", "Reusing nonces or IVs across different encryption operations.", "Not validating the uniqueness of generated nonces or IVs."], "related_cwe": ["CWE-327: Use of a Broken or Risky Cryptographic Algorithm", "CWE-329: Not Using a Random IV with CBC Mode", "CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)"], "related_capec": ["CAPEC-136: Replay Attack", "CAPEC-147: Chosen Plaintext Attack", "CAPEC-176: Key Recovery Attack"], "attack_flow": "An attacker can exploit the reuse of nonces or IVs by capturing encrypted messages and replaying them, or by manipulating the ciphertext to derive information about the plaintext or the encryption key. This can lead to unauthorized access to sensitive data or the ability to decrypt previously encrypted messages."}
{"chapter_id": "V11", "chapter_name": "Cryptography", "section_id": "V11.3", "section_name": "Encryption Algorithms", "req_id": "V11.3.5", "req_description": "Verify that any combination of an encryption algorithm and a MAC algorithm is operating in encrypt-then-MAC mode.", "level": "3", "explanation": "The encrypt-then-MAC mode ensures that the data is encrypted first and then a Message Authentication Code (MAC) is applied to the ciphertext. This order prevents an attacker from manipulating the ciphertext without detection, as the MAC will not validate if the ciphertext has been altered. This requirement mandates that developers implement this order to enhance the integrity and authenticity of the encrypted data.", "threats_mitigated": ["Data integrity attacks", "Replay attacks", "Man-in-the-middle attacks", "Ciphertext manipulation"], "insecure_examples": [{"code": "ciphertext = encrypt(data, key);\nmac = compute_mac(ciphertext, mac_key);"}, {"code": "mac = compute_mac(data, mac_key);\nciphertext = encrypt(data, key);"}], "secure_examples": [{"code": "ciphertext = encrypt(data, key);\nmac = compute_mac(ciphertext, mac_key);"}], "verification_steps": ["Check that encryption is performed before MAC generation.", "Ensure that the MAC is verified before decryption.", "Review the implementation of the encryption and MAC algorithms for compliance with standards."], "common_mistakes": ["Implementing MAC generation before encryption.", "Using the same key for both encryption and MAC generation.", "Neglecting to verify the MAC before decrypting the ciphertext."], "related_cwe": ["CWE-329", "CWE-327", "CWE-310"], "related_capec": ["CAPEC-138", "CAPEC-141"], "attack_flow": "An attacker intercepts the ciphertext and alters it. If the MAC is computed before encryption, the attacker can manipulate the ciphertext without the MAC reflecting these changes. When the victim decrypts the altered ciphertext, they may not detect the manipulation, leading to unauthorized access or data corruption."}
{"chapter_id": "V11", "chapter_name": "Cryptography", "section_id": "V11.4", "section_name": "Hashing and Hash-based Functions", "req_id": "V11.4.1", "req_description": "Verify that only approved hash functions are used for general cryptographic use cases, including digital signatures, HMAC, KDF, and random bit generation. Disallowed hash functions, such as MD5, must not be used for any cryptographic purpose.", "level": "1", "explanation": "This requirement ensures that only secure and approved hashing algorithms are employed in cryptographic operations. Using weak or outdated hash functions can lead to vulnerabilities such as collision attacks, where two different inputs produce the same hash output, undermining the integrity of the data. Approved hash functions like SHA-256 or SHA-3 should be used instead of deprecated ones like MD5 or SHA-1.", "threats_mitigated": ["Collision attacks", "Pre-image attacks", "Second pre-image attacks", "Replay attacks"], "insecure_examples": [{"code": "String passwordHash = DigestUtils.md5Hex(password); // Using MD5 for hashing"}, {"code": "String hmac = HmacUtils.hmacMd5(secretKey, data); // Using MD5 for HMAC"}], "secure_examples": [{"code": "String passwordHash = DigestUtils.sha256Hex(password); // Using SHA-256 for hashing"}, {"code": "String hmac = HmacUtils.hmacSha256(secretKey, data); // Using SHA-256 for HMAC"}], "verification_steps": ["Review the codebase for hashing functions used.", "Check the documentation for the hash functions to ensure they are approved.", "Ensure that no deprecated hash functions like MD5 are present.", "Verify that secure alternatives are implemented correctly."], "common_mistakes": ["Using deprecated hash functions like MD5 or SHA-1.", "Not updating hash functions when vulnerabilities are discovered.", "Assuming that all hash functions are secure without proper validation."], "related_cwe": ["CWE-327", "CWE-916", "CWE-760"], "related_capec": ["CAPEC-133", "CAPEC-146", "CAPEC-153"], "attack_flow": "An attacker can exploit the use of a weak hash function by generating two different inputs that produce the same hash (collision). This can be used to forge digital signatures or manipulate data integrity checks, allowing the attacker to impersonate legitimate users or alter data without detection."}
{"chapter_id": "V11", "chapter_name": "Cryptography", "section_id": "V11.4", "section_name": "Hashing and Hash-based Functions", "req_id": "V11.4.2", "req_description": "Verify that passwords are stored using an approved, computationally intensive, key derivation function (also known as a 'password hashing function'), with parameter settings configured based on current guidance. The settings should balance security and performance to make brute-force attacks sufficiently challenging for the required level of security.", "level": "2", "explanation": "This requirement emphasizes the importance of using a secure method for storing passwords. A key derivation function (KDF) is designed to make it computationally expensive to derive the original password from the hash, thereby increasing the time and resources required for an attacker to successfully perform a brute-force attack. It is crucial to select appropriate parameters for the KDF to ensure that it remains effective against evolving attack techniques.", "threats_mitigated": ["Brute-force attacks", "Rainbow table attacks", "Credential stuffing"], "insecure_examples": [{"code": "String passwordHash = hash(password); // Simple hash function without salting or iteration"}, {"code": "String passwordHash = MD5(password); // Using MD5 for password hashing"}], "secure_examples": [{"code": "String passwordHash = PBKDF2.hash(password, salt, iterations); // Using PBKDF2 with a secure salt and high iteration count"}, {"code": "String passwordHash = BCrypt.hashpw(password, BCrypt.gensalt()); // Using BCrypt for password hashing"}], "verification_steps": ["Check that a secure key derivation function is used (e.g., PBKDF2, BCrypt, Argon2).", "Verify that a unique salt is generated and used for each password.", "Ensure that the number of iterations or work factor is set to a recommended level.", "Review the implementation for compliance with current cryptographic guidelines."], "common_mistakes": ["Using outdated or weak hashing algorithms (e.g., MD5, SHA-1).", "Not using a unique salt for each password.", "Setting the iteration count too low, making it easy for attackers to brute-force passwords."], "related_cwe": ["CWE-760: Use of a One-Way Hash without a Salt", "CWE-916: Use of Password Hash with Insufficient Computational Effort"], "related_capec": ["CAPEC-137: Brute Force Attack", "CAPEC-152: Password Cracking"], "attack_flow": "An attacker may obtain a hashed password database and attempt to crack the passwords using brute-force techniques. If weak hashing algorithms or insufficient iterations are used, the attacker can quickly guess the original passwords. By using a strong KDF with appropriate parameters, the time and resources required for the attacker to successfully crack passwords are significantly increased, thereby protecting user credentials."}
{"chapter_id": "V11", "chapter_name": "Cryptography", "section_id": "V11.4", "section_name": "Hashing and Hash-based Functions", "req_id": "V11.4.3", "req_description": "Verify that hash functions used in digital signatures, as part of data authentication or data integrity are collision resistant and have appropriate bit-lengths. If collision resistance is required, the output length must be at least 256 bits. If only resistance to second pre-image attacks is required, the output length must be at least 128 bits.", "level": "2", "explanation": "This requirement emphasizes the importance of using secure hash functions that are resistant to collisions, meaning it should be computationally infeasible to find two different inputs that produce the same hash output. It also specifies the minimum output lengths for different levels of security, ensuring that the hash functions used in digital signatures provide adequate protection against potential attacks.", "threats_mitigated": ["Collision attacks", "Second pre-image attacks", "Data integrity violations", "Unauthorized data authentication"], "insecure_examples": ["import hashlib\n\n# Insecure hash function with insufficient bit-length\nhash_value = hashlib.md5(b'Some data').hexdigest()", "import hashlib\n\n# Using SHA-1 which is considered weak\nhash_value = hashlib.sha1(b'Some data').hexdigest()"], "secure_examples": ["import hashlib\n\n# Secure hash function with appropriate bit-length\nhash_value = hashlib.sha256(b'Some data').hexdigest()", "import hashlib\n\n# Using SHA-256 for secure hashing\nhash_value = hashlib.sha256(b'Some data').hexdigest()"], "verification_steps": ["Check the hash function used in the application.", "Verify the output length of the hash function.", "Ensure that the hash function is resistant to collision attacks.", "Confirm that the hash function is suitable for the intended security level."], "common_mistakes": ["Using outdated hash functions like MD5 or SHA-1.", "Not verifying the output length of the hash function.", "Assuming that any hash function is secure without understanding its properties."], "related_cwe": ["CWE-327", "CWE-328", "CWE-346"], "related_capec": ["CAPEC-54", "CAPEC-131", "CAPEC-146"], "attack_flow": "An attacker could exploit a weak hash function by generating two different inputs that produce the same hash output (collision), allowing them to substitute malicious data for legitimate data without detection. Alternatively, if a hash function is not sufficiently long, the attacker could use brute-force methods to find a second input that produces the same hash output, compromising data integrity."}
{"chapter_id": "V11", "chapter_name": "Cryptography", "section_id": "V11.4", "section_name": "Hashing and Hash-based Functions", "req_id": "V11.4.4", "req_description": "Verify that the application uses approved key derivation functions with key stretching parameters when deriving secret keys from passwords. The parameters in use must balance security and performance to prevent brute-force attacks from compromising the resulting cryptographic key.", "level": 2, "explanation": "This requirement emphasizes the importance of using strong key derivation functions (KDFs) that are designed to securely derive cryptographic keys from passwords. The key stretching parameters, such as iteration count, salt length, and output length, must be carefully chosen to ensure that the derived keys are resistant to brute-force attacks, while still maintaining acceptable performance for user experience.", "threats_mitigated": ["Brute-force attacks", "Dictionary attacks", "Rainbow table attacks"], "insecure_examples": [{"code_snippet": "String password = \"userPassword\";\nbyte[] key = MessageDigest.getInstance(\"SHA-256\").digest(password.getBytes());"}, {"code_snippet": "String password = \"userPassword\";\nbyte[] key = new byte[32];\nRandom random = new Random();\nrandom.nextBytes(key);"}], "secure_examples": [{"code_snippet": "String password = \"userPassword\";\nbyte[] salt = SecureRandom.getInstanceStrong().generateSeed(16);\nSecretKeySpec key = new SecretKeySpec(PBKDF2WithHmacSHA256(password.getBytes(), salt, 100000, 32), \"AES\");"}, {"code_snippet": "String password = \"userPassword\";\nbyte[] key = PBKDF2.hash(password, salt, 100000, 32);"}], "verification_steps": ["Check that an approved key derivation function is used (e.g., PBKDF2, bcrypt, Argon2).", "Verify that the key stretching parameters (iterations, salt length) are configured appropriately.", "Ensure that the application does not use deprecated or weak hashing functions (e.g., MD5, SHA-1).", "Review the implementation for proper handling of salts and iterations."], "common_mistakes": ["Using a simple hash function without key stretching.", "Not using a unique salt for each password.", "Setting iteration counts too low, making it easy for attackers to brute-force passwords."], "related_cwe": ["CWE- hash function not used", "CWE-760: Use of a One-Way Hash without a Salt", "CWE-916: Use of Password Hash With Insufficient Computational Effort"], "related_capec": ["CAPEC-137: Brute Force Password Guessing", "CAPEC-160: Dictionary Attack", "CAPEC-129: Rainbow Table Attack"], "attack_flow": "An attacker may attempt to gain unauthorized access by exploiting weak password storage mechanisms. If the application uses a weak hashing algorithm or insufficient key stretching parameters, the attacker can quickly guess or compute the original password through brute-force or dictionary attacks. By successfully deriving the original password, the attacker can then access user accounts or sensitive data."}
{"chapter_id": "V11", "chapter_name": "Cryptography", "section_id": "V11.5", "section_name": "Random Values", "req_id": "V11.5.1", "req_description": "Verify that all random numbers and strings which are intended to be non-guessable must be generated using a cryptographically secure pseudo-random number generator (CSPRNG) and have at least 128 bits of entropy. Note that UUIDs do not respect this condition.", "level": "2", "explanation": "This requirement ensures that any random values used in the application, such as session tokens, cryptographic keys, or any other values that need to be unpredictable, are generated using a secure method. A CSPRNG provides a higher level of randomness and unpredictability compared to standard random number generators, which can be predictable and thus vulnerable to attacks. The requirement for at least 128 bits of entropy ensures that the generated values are sufficiently complex to resist brute-force attacks.", "threats_mitigated": ["Predictable session tokens", "Brute-force attacks on cryptographic keys", "Session fixation attacks", "Replay attacks"], "insecure_examples": [{"code": "String token = UUID.randomUUID().toString(); // Insecure: UUIDs are predictable"}, {"code": "int randomValue = new Random().nextInt(); // Insecure: Not cryptographically secure"}], "secure_examples": [{"code": "SecureRandom secureRandom = new SecureRandom(); byte[] randomBytes = new byte[16]; secureRandom.nextBytes(randomBytes); // Secure: Uses CSPRNG"}, {"code": "String secureToken = Base64.getEncoder().encodeToString(randomBytes); // Secure: Encodes random bytes"}], "verification_steps": ["Check that all random values are generated using a CSPRNG.", "Verify that the entropy of the generated values is at least 128 bits.", "Review code to ensure that UUIDs are not used for security tokens.", "Test the randomness of the generated values to ensure they are not predictable."], "common_mistakes": ["Using standard random number generators instead of CSPRNGs.", "Relying on UUIDs for security-sensitive applications.", "Not verifying the entropy of generated random values."], "related_cwe": ["CWE-331: Insufficient Entropy", "CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator"], "related_capec": ["CAPEC-138: Brute Force Attack", "CAPEC-141: Session Fixation Attack"], "attack_flow": "An attacker could exploit predictable random values by guessing session tokens or cryptographic keys generated using insecure methods. For example, if a non-cryptographically secure random number generator is used, an attacker may be able to predict future values based on previous outputs, allowing them to hijack sessions or decrypt sensitive data."}
{"chapter_id": "V11", "chapter_name": "Cryptography", "section_id": "V11.5", "section_name": "Random Values", "req_id": "V11.5.2", "req_description": "Verify that the random number generation mechanism in use is designed to work securely, even under heavy demand.", "level": 3, "explanation": "This requirement emphasizes the importance of using a secure random number generator (RNG) that can maintain its security properties even when subjected to high usage. An RNG should produce unpredictable and unbiased random values, ensuring that it does not become a point of weakness in cryptographic operations. The design should account for potential exhaustion of entropy sources and ensure that the RNG can continue to function securely under load.", "threats_mitigated": ["Predictable random number generation", "Denial of service through RNG exhaustion", "Cryptographic key compromise due to weak RNG"], "insecure_examples": [{"code": "import random\n\n# Insecure random number generation\nrandom.seed(123)\nprint(random.randint(1, 100))"}, {"code": "import os\n\n# Using /dev/random without handling blocking\nrandom_value = os.urandom(16)\n# If /dev/random is exhausted, this could block indefinitely."}], "secure_examples": [{"code": "import secrets\n\n# Secure random number generation\nsecure_random = secrets.randbelow(100)\nprint(secure_random)"}, {"code": "import os\n\n# Using os.urandom which is non-blocking and secure\nrandom_value = os.urandom(16)"}], "verification_steps": ["Check that the RNG uses a cryptographically secure algorithm.", "Verify that the RNG is not seeded with predictable values.", "Ensure that the RNG can handle high demand without performance degradation.", "Test the RNG under load to confirm it maintains security properties."], "common_mistakes": ["Using non-cryptographic RNGs like Math.random() in security-sensitive contexts.", "Failing to consider entropy sources when designing the RNG.", "Not validating the randomness of generated values."], "related_cwe": ["CWE-338", "CWE-331", "CWE-835"], "related_capec": ["CAPEC-131", "CAPEC-134"], "attack_flow": "An attacker may exploit a weak RNG by predicting the output of the random number generation process. If the RNG is predictable or can be manipulated, the attacker could generate valid cryptographic keys or tokens, leading to unauthorized access or data compromise. In scenarios where the RNG is exhausted, the attacker could cause the system to block or degrade performance, potentially leading to a denial of service."}
{"chapter_id": "V11", "chapter_name": "Cryptography", "section_id": "V11.6", "section_name": "Public Key Cryptography", "req_id": "V11.6.1", "req_description": "Verify that only approved cryptographic algorithms and modes of operation are used for key generation and seeding, and digital signature generation and verification. Key generation algorithms must not generate insecure keys vulnerable to known attacks, for example, RSA keys which are vulnerable to Fermat factorization.", "level": "2", "explanation": "This requirement emphasizes the importance of using well-established and secure cryptographic algorithms for key generation and digital signatures. It ensures that developers do not use outdated or insecure algorithms that could be easily compromised, thereby protecting sensitive data and maintaining the integrity of digital signatures.", "threats_mitigated": ["Key compromise", "Man-in-the-middle attacks", "Replay attacks", "Data integrity violations"], "insecure_examples": [{"code_snippet": "import Crypto.PublicKey.RSA\nkey = Crypto.PublicKey.RSA.generate(512)  # Insecure key size"}, {"code_snippet": "import hashlib\nsignature = hashlib.md5(data).hexdigest()  # Using insecure hash function for signing"}], "secure_examples": [{"code_snippet": "import Crypto.PublicKey.RSA\nkey = Crypto.PublicKey.RSA.generate(2048)  # Secure key size"}, {"code_snippet": "import hashlib\nsignature = hashlib.sha256(data).hexdigest()  # Using secure hash function for signing"}], "verification_steps": ["Check the cryptographic libraries used in the application.", "Ensure that only approved algorithms and key sizes are implemented.", "Review the key generation and digital signature processes.", "Verify that no deprecated or insecure algorithms are in use."], "common_mistakes": ["Using outdated algorithms like MD5 or SHA-1 for hashing.", "Generating RSA keys with insufficient length (e.g., less than 2048 bits).", "Failing to validate the strength of cryptographic keys."], "related_cwe": ["CWE-327", "CWE-326", "CWE-310"], "related_capec": ["CAPEC-137", "CAPEC-148", "CAPEC-155"], "attack_flow": "An attacker may exploit insecure key generation by using known weaknesses in the algorithm to derive the private key from the public key, allowing them to decrypt sensitive information or forge signatures. For example, if RSA keys are generated with a weak algorithm, the attacker could use Fermat's factorization method to break the key and gain unauthorized access."}
{"chapter_id": "V11", "chapter_name": "Cryptography", "section_id": "V11.6", "section_name": "Public Key Cryptography", "req_id": "V11.6.2", "req_description": "Verify that approved cryptographic algorithms are used for key exchange (such as Diffie-Hellman) with a focus on ensuring that key exchange mechanisms use secure parameters. This will prevent attacks on the key establishment process which could lead to adversary-in-the-middle attacks or cryptographic breaks.", "level": 3, "explanation": "This requirement emphasizes the importance of using well-established and approved cryptographic algorithms for key exchange processes. It ensures that the parameters used in these algorithms are secure and not susceptible to attacks. By adhering to this requirement, organizations can significantly reduce the risk of adversaries intercepting or manipulating key exchanges, which could compromise the confidentiality and integrity of communications.", "threats_mitigated": ["Man-in-the-Middle (MitM) attacks", "Cryptographic breaks", "Key compromise"], "insecure_examples": [{"code": "publicKey = generateKey();\n// Using weak parameters for Diffie-Hellman\nDHParameter = new DHParameterSpec(p, g);\nkeyExchange = new DiffieHellman(DHParameter);"}, {"code": "publicKey = generateKey();\n// Using non-approved algorithms for key exchange\nkeyExchange = new CustomKeyExchange();"}], "secure_examples": [{"code": "DHParameter = new DHParameterSpec(approvedP, approvedG);\nkeyExchange = new DiffieHellman(DHParameter);"}, {"code": "publicKey = generateKey();\n// Using approved algorithms for key exchange\nkeyExchange = new ApprovedKeyExchange();"}], "verification_steps": ["Check that the key exchange algorithm is an approved standard (e.g., Diffie-Hellman).", "Verify that secure parameters are being used in the key exchange process.", "Review the cryptographic library documentation to ensure compliance with the latest security standards.", "Conduct a security review of the implementation to identify any potential weaknesses."], "common_mistakes": ["Using outdated or deprecated cryptographic algorithms.", "Failing to validate the parameters used in key exchange algorithms.", "Relying on custom implementations instead of established libraries."], "related_cwe": ["CWE-326", "CWE-327", "CWE-330"], "related_capec": ["CAPEC-138", "CAPEC-155", "CAPEC-156"], "attack_flow": "An attacker can intercept the key exchange process by exploiting weak parameters or non-approved algorithms. By doing so, they can perform a man-in-the-middle attack, allowing them to decrypt and manipulate the communication between two parties. If the key exchange is not secure, the attacker can establish their own key with each party, leading to compromised confidentiality and integrity."}
{"chapter_id": "V11", "chapter_name": "Cryptography", "section_id": "V11.7", "section_name": "In-Use Data Cryptography", "req_id": "V11.7.1", "req_description": "Verify that full memory encryption is in use that protects sensitive data while it is in use, preventing access by unauthorized users or processes.", "level": "3", "explanation": "This requirement emphasizes the importance of encrypting sensitive data in memory to protect it from unauthorized access during its lifecycle. Full memory encryption ensures that even if an attacker gains access to the system's memory, they cannot read or manipulate sensitive information without the appropriate decryption keys. This is particularly crucial for applications that handle sensitive data such as personal information, financial records, or cryptographic keys.", "threats_mitigated": ["Unauthorized access to sensitive data in memory", "Memory scraping attacks", "Data breaches resulting from exposed sensitive information"], "insecure_examples": [{"code": "char sensitiveData[256]; // Sensitive data stored in plain text\nstrcpy(sensitiveData, \"Sensitive Information\");"}, {"code": "String sensitiveData = \"Sensitive Information\"; // Stored in plain text in memory"}], "secure_examples": [{"code": "char sensitiveData[256]; // Sensitive data stored in encrypted format\nencrypt(sensitiveData, \"EncryptionKey\");"}, {"code": "String sensitiveData = encrypt(\"Sensitive Information\", \"EncryptionKey\"); // Stored securely in memory"}], "verification_steps": ["Check if the application uses full memory encryption.", "Verify that sensitive data is encrypted before being stored in memory.", "Review the encryption keys management process.", "Conduct memory analysis to ensure sensitive data is not exposed in plain text."], "common_mistakes": ["Storing sensitive data in plain text in memory.", "Failing to encrypt data before it is processed or stored.", "Neglecting to manage encryption keys securely."], "related_cwe": ["CWE-200", "CWE-312", "CWE-315"], "related_capec": ["CAPEC-144", "CAPEC-146"], "attack_flow": "An attacker exploits this requirement by gaining access to the system's memory, either through a memory scraping attack or by exploiting vulnerabilities in the application. If sensitive data is not encrypted in memory, the attacker can read the data directly, leading to potential data breaches and unauthorized access to sensitive information."}
{"chapter_id": "V11", "chapter_name": "Cryptography", "section_id": "V11.7", "section_name": "In-Use Data Cryptography", "req_id": "V11.7.2", "req_description": "Verify that data minimization ensures the minimal amount of data is exposed during processing, and ensure that data is encrypted immediately after use or as soon as feasible.", "level": 3, "explanation": "This requirement emphasizes the importance of minimizing the amount of sensitive data that is exposed during processing. It mandates that any sensitive data should be encrypted as soon as it is no longer needed in its plaintext form, thereby reducing the risk of unauthorized access or data breaches.", "threats_mitigated": ["Data exposure during processing", "Data breaches due to unencrypted data", "Insider threats accessing sensitive data"], "insecure_examples": [{"code": "String sensitiveData = getSensitiveData();\nprocessData(sensitiveData);\n// sensitiveData is still in memory unencrypted"}, {"code": "List<User> users = userService.getAllUsers();\n// users list is exposed without encryption"}], "secure_examples": [{"code": "String sensitiveData = getSensitiveData();\nprocessData(sensitiveData);\nsensitiveData = null; // Clear sensitive data from memory"}, {"code": "List<User> users = userService.getAllUsers();\nString encryptedUsers = encrypt(users.toString()); // Encrypt data immediately after use"}], "verification_steps": ["Check that sensitive data is minimized during processing.", "Verify that sensitive data is encrypted immediately after use.", "Review code for instances of sensitive data remaining in memory or logs.", "Ensure that data handling policies enforce data minimization and encryption."], "common_mistakes": ["Failing to clear sensitive data from memory after use.", "Delaying encryption of sensitive data until after processing is complete.", "Not considering data minimization principles when designing data flows."], "related_cwe": ["CWE-200", "CWE-22", "CWE-77"], "related_capec": ["CAPEC-137", "CAPEC-148"], "attack_flow": "An attacker could exploit this requirement by intercepting sensitive data that is processed in plaintext. If data is not minimized and remains in memory or logs, it can be accessed by unauthorized users, leading to potential data breaches and exploitation of sensitive information."}
{"chapter_id": "V12", "chapter_name": "Secure Communication", "section_id": "V12.1", "section_name": "General TLS Security Guidance", "req_id": "V12.1.1", "req_description": "Verify that only the latest recommended versions of the TLS protocol are enabled, such as TLS 1.2 and TLS 1.3. The latest version of the TLS protocol must be the preferred option.", "level": "1", "explanation": "This requirement emphasizes the importance of using up-to-date versions of the TLS protocol to ensure secure communication over networks. Older versions of TLS, such as TLS 1.0 and TLS 1.1, are known to have vulnerabilities that can be exploited by attackers. By enforcing the use of TLS 1.2 and TLS 1.3, organizations can leverage improved security features and mitigations against known attacks.", "threats_mitigated": ["Man-in-the-Middle (MitM) attacks", "Eavesdropping", "Data tampering", "Protocol downgrade attacks"], "insecure_examples": ["server.enable_tls('1.0');", "server.enable_tls('1.1');"], "secure_examples": ["server.enable_tls('1.2');", "server.enable_tls('1.3');"], "verification_steps": ["Check the server configuration for enabled TLS versions.", "Verify that only TLS 1.2 and TLS 1.3 are listed as enabled protocols.", "Test the server with tools to ensure older TLS versions are not supported.", "Review logs for any attempts to negotiate older protocols."], "common_mistakes": ["Failing to disable older TLS versions in the server configuration.", "Not regularly updating server configurations to reflect the latest security recommendations.", "Assuming that all clients support the latest versions without testing."], "related_cwe": ["CWE-319: Cleartext Transmission of Sensitive Information", "CWE-295: Improper Certificate Validation", "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"], "related_capec": ["CAPEC-119: Man-in-the-Middle Attack", "CAPEC-139: SSL Stripping", "CAPEC-148: Downgrade Attack"], "attack_flow": "An attacker can exploit the use of outdated TLS versions by intercepting communication between the client and server. By forcing a downgrade to an older version, the attacker can leverage known vulnerabilities to decrypt sensitive data, inject malicious content, or impersonate one of the parties involved in the communication."}
{"chapter_id": "V12", "chapter_name": "Secure Communication", "section_id": "V12.1", "section_name": "General TLS Security Guidance", "req_id": "V12.1.2", "req_description": "Verify that only recommended cipher suites are enabled, with the strongest cipher suites set as preferred. L3 applications must only support cipher suites which provide forward secrecy.", "level": "2", "explanation": "This requirement emphasizes the importance of using strong, secure cipher suites for TLS connections. Cipher suites determine how data is encrypted and authenticated during transmission. By ensuring that only recommended and strong cipher suites are enabled, applications can protect against various attacks that exploit weak encryption methods. Forward secrecy ensures that session keys are not compromised even if the server's private key is compromised in the future.", "threats_mitigated": ["Man-in-the-middle attacks", "Eavesdropping", "Data tampering", "Replay attacks"], "insecure_examples": [{"code": "SSLContext context = SSLContext.getInstance(\"TLS\");\ncontext.init(null, new TrustManager[]{new InsecureTrustManager()}, new SecureRandom());\nServerSocketFactory factory = context.getServerSocketFactory();\nServerSocket socket = factory.createServerSocket(port);"}, {"code": "server.setEnabledCipherSuites(new String[]{\"RC4-SHA\", \"DES-CBC3-SHA\"});"}], "secure_examples": [{"code": "SSLContext context = SSLContext.getInstance(\"TLS\");\ncontext.init(null, null, new SecureRandom());\nServerSocketFactory factory = context.getServerSocketFactory();\nServerSocket socket = factory.createServerSocket(port);"}, {"code": "server.setEnabledCipherSuites(new String[]{\"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\", \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\"});"}], "verification_steps": ["Review the server configuration for enabled cipher suites.", "Ensure that only strong cipher suites are enabled.", "Check for the presence of forward secrecy in the enabled cipher suites.", "Test the application using tools like SSL Labs to verify the strength of the cipher suites."], "common_mistakes": ["Using outdated or weak cipher suites.", "Not enabling forward secrecy.", "Failing to regularly review and update the cipher suite configuration."], "related_cwe": ["CWE-326", "CWE-327", "CWE-295"], "related_capec": ["CAPEC-144", "CAPEC-145", "CAPEC-146"], "attack_flow": "An attacker intercepts the communication between the client and server. If weak cipher suites are enabled, the attacker can downgrade the connection to a less secure cipher suite, allowing them to decrypt the transmitted data. If forward secrecy is not implemented, the attacker can also capture the session keys and decrypt past communications if they gain access to the server's private key."}
{"chapter_id": "V12", "chapter_name": "Secure Communication", "section_id": "V12.1", "section_name": "General TLS Security Guidance", "req_id": "V12.1.3", "req_description": "Verify that the application validates that mTLS client certificates are trusted before using the certificate identity for authentication or authorization.", "level": 2, "explanation": "This requirement emphasizes the importance of validating the trustworthiness of client certificates in mutual TLS (mTLS) scenarios. Before accepting a client certificate for authentication or authorization, the application must ensure that the certificate is issued by a trusted Certificate Authority (CA) and has not been revoked. This validation process helps prevent unauthorized access and ensures that only legitimate clients can interact with the application.", "threats_mitigated": ["Man-in-the-Middle (MitM) attacks", "Unauthorized access to sensitive resources", "Impersonation of legitimate clients"], "insecure_examples": [{"code": "if (clientCertificate != null) {\n    authenticateClient(clientCertificate);\n}"}, {"code": "authenticateClient(clientCertificate); // No validation of trust"}], "secure_examples": [{"code": "if (clientCertificate != null && isTrustedCertificate(clientCertificate)) {\n    authenticateClient(clientCertificate);\n} else {\n    rejectClient();\n}"}, {"code": "if (isCertificateRevoked(clientCertificate)) {\n    rejectClient();\n} else {\n    authenticateClient(clientCertificate);\n}"}], "verification_steps": ["Check if the application verifies the issuer of the client certificate.", "Ensure that the application checks the revocation status of the client certificate.", "Review the configuration of the trusted CA certificates in the application.", "Test the application with both valid and invalid client certificates."], "common_mistakes": ["Failing to check if the client certificate is issued by a trusted CA.", "Not implementing certificate revocation checks.", "Assuming all client certificates are valid without proper validation."], "related_cwe": ["CWE-295: Improper Certificate Validation", "CWE-287: Improper Authentication"], "related_capec": ["CAPEC-148: Man-in-the-Middle Attack", "CAPEC-156: Certificate Spoofing"], "attack_flow": "An attacker could present a forged or stolen client certificate that appears valid. If the application does not validate the certificate against a trusted CA or does not check if it has been revoked, the attacker could gain unauthorized access to the application, leading to data breaches or other malicious actions."}
{"chapter_id": "V12", "chapter_name": "Secure Communication", "section_id": "V12.1", "section_name": "General TLS Security Guidance", "req_id": "V12.1.4", "req_description": "Verify that proper certification revocation, such as Online Certificate Status Protocol (OCSP) Stapling, is enabled and configured.", "level": 3, "explanation": "This requirement emphasizes the importance of ensuring that the certificates used in secure communications are still valid and have not been revoked. OCSP Stapling is a method that allows the server to check the revocation status of its certificates and provide this information to clients during the TLS handshake, enhancing security by preventing the use of revoked certificates.", "threats_mitigated": ["Man-in-the-Middle (MitM) attacks", "Use of revoked certificates", "Certificate spoofing"], "insecure_examples": [{"code": "SSLContext sslContext = SSLContext.getInstance(\"TLS\");\nsslContext.init(null, null, null); // No revocation check configured"}, {"code": "HttpsURLConnection connection = (HttpsURLConnection) new URL(\"https://example.com\").openConnection();\nconnection.setSSLSocketFactory(sslContext.getSocketFactory()); // OCSP Stapling not enabled"}], "secure_examples": [{"code": "SSLContext sslContext = SSLContext.getInstance(\"TLS\");\nsslContext.init(null, new TrustManager[] { new CustomTrustManager() }, null); // Proper revocation checks configured"}, {"code": "HttpsURLConnection connection = (HttpsURLConnection) new URL(\"https://example.com\").openConnection();\nconnection.setSSLSocketFactory(sslContext.getSocketFactory());\nconnection.setRequestProperty(\"Accept\", \"application/json\"); // OCSP Stapling enabled"}], "verification_steps": ["Check if OCSP Stapling is enabled on the server.", "Verify that the server is configured to check the revocation status of certificates.", "Ensure that the server's certificate chain is valid and does not include revoked certificates.", "Test the TLS handshake to confirm that OCSP responses are being correctly stapled."], "common_mistakes": ["Not enabling OCSP Stapling on the server.", "Failing to configure proper trust anchors for certificate validation.", "Ignoring the importance of checking certificate revocation status."], "related_cwe": ["CWE-295: Improper Certificate Validation", "CWE-300: Channel Accessible by Non-Endpoint", "CWE-295: Certificate Validation"], "related_capec": ["CAPEC-118: Man-in-the-Middle Attack", "CAPEC-137: Certificate Spoofing", "CAPEC-131: Certificate Revocation Attack"], "attack_flow": "An attacker could exploit the lack of proper certificate revocation checks by using a revoked certificate to impersonate a legitimate server. If the client does not check for revocation, it may establish a secure connection with the attacker, allowing the attacker to intercept or manipulate sensitive data."}
{"chapter_id": "V12", "chapter_name": "Secure Communication", "section_id": "V12.1", "section_name": "General TLS Security Guidance", "req_id": "V12.1.5", "req_description": "Verify that Encrypted Client Hello (ECH) is enabled in the application's TLS settings to prevent exposure of sensitive metadata, such as the Server Name Indication (SNI), during TLS handshake processes.", "level": "3", "explanation": "Encrypted Client Hello (ECH) enhances the privacy of the TLS handshake by encrypting the ClientHello message, which contains sensitive information like the Server Name Indication (SNI). Enabling ECH helps to obscure this information from potential eavesdroppers, thereby reducing the risk of targeted attacks based on the metadata that is typically exposed during the handshake.", "threats_mitigated": ["Eavesdropping on TLS handshakes", "Traffic analysis", "Metadata leakage", "Targeted attacks based on SNI information"], "insecure_examples": [{"code": "server.enable_tls(); // ECH not enabled"}, {"code": "tls_settings = { 'enable_sni': true }; // SNI exposed"}], "secure_examples": [{"code": "server.enable_tls({ 'ech': true }); // ECH enabled"}, {"code": "tls_settings = { 'enable_sni': false, 'ech': true }; // SNI hidden"}], "verification_steps": ["Check the TLS configuration settings for ECH support.", "Verify that the ClientHello message is encrypted during the handshake.", "Ensure that no sensitive metadata is exposed in network traffic."], "common_mistakes": ["Not enabling ECH due to lack of awareness or understanding.", "Misconfiguring TLS settings that lead to unencrypted ClientHello messages.", "Assuming that enabling SNI is harmless without considering privacy implications."], "related_cwe": ["CWE-319", "CWE-200", "CWE-284"], "related_capec": ["CAPEC-150", "CAPEC-159"], "attack_flow": "An attacker intercepts the TLS handshake and captures the ClientHello message. Without ECH, the SNI is visible, allowing the attacker to determine the target server and potentially launch targeted attacks. By enabling ECH, the ClientHello message is encrypted, preventing the attacker from accessing this sensitive information."}
{"chapter_id": "V12", "chapter_name": "Secure Communication", "section_id": "V12.2", "section_name": "HTTPS Communication with External Facing Services", "req_id": "V12.2.1", "req_description": "Verify that TLS is used for all connectivity between a client and external facing, HTTP-based services, and does not fall back to insecure or unencrypted communications.", "level": "1", "explanation": "This requirement ensures that all data transmitted between clients and external services is encrypted using TLS (Transport Layer Security). This prevents eavesdropping, tampering, and man-in-the-middle attacks by ensuring that sensitive information is not transmitted in plaintext over the network.", "threats_mitigated": ["Eavesdropping", "Man-in-the-middle attacks", "Data tampering", "Session hijacking"], "insecure_examples": [{"code": "http://example.com/api/data"}, {"code": "fetch('http://example.com/api/data')"}], "secure_examples": [{"code": "https://example.com/api/data"}, {"code": "fetch('https://example.com/api/data')"}], "verification_steps": ["Check that all API endpoints use HTTPS.", "Verify that the server is configured to reject HTTP connections.", "Ensure that the application does not allow fallback to insecure protocols.", "Review the TLS configuration for vulnerabilities and ensure up-to-date cipher suites are used."], "common_mistakes": ["Using HTTP instead of HTTPS for API calls.", "Failing to enforce HTTPS redirection.", "Allowing mixed content (HTTP and HTTPS) on the same page."], "related_cwe": ["CWE-319", "CWE-295", "CWE-300"], "related_capec": ["CAPEC-118", "CAPEC-130", "CAPEC-137"], "attack_flow": "An attacker intercepts HTTP traffic between the client and the server, capturing sensitive information such as credentials or session tokens. By exploiting the lack of encryption, the attacker can manipulate the data being sent and received, leading to unauthorized access or data breaches."}
{"chapter_id": "V12", "chapter_name": "Secure Communication", "section_id": "V12.2", "section_name": "HTTPS Communication with External Facing Services", "req_id": "V12.2.2", "req_description": "Verify that external facing services use publicly trusted TLS certificates.", "level": "1", "explanation": "This requirement ensures that any external-facing services utilize TLS certificates that are issued by a publicly trusted certificate authority (CA). Publicly trusted certificates are essential for establishing a secure connection between clients and servers, as they verify the identity of the server and encrypt the data transmitted over the network. Using self-signed or untrusted certificates can lead to man-in-the-middle attacks, where an attacker can intercept and manipulate the data being transmitted.", "threats_mitigated": ["Man-in-the-Middle (MitM) attacks", "Eavesdropping on sensitive data", "Data tampering during transmission"], "insecure_examples": [{"code_snippet": "curl -k https://example.com", "description": "Using the -k flag in curl allows connections to SSL sites without certificates, which can expose the connection to security risks."}, {"code_snippet": "https://selfsigned.example.com", "description": "Accessing a service with a self-signed certificate that is not trusted by the client."}], "secure_examples": [{"code_snippet": "curl https://example.com", "description": "Using curl to access a service with a valid, publicly trusted TLS certificate."}, {"code_snippet": "https://trusted.example.com", "description": "Accessing a service with a valid certificate issued by a trusted CA."}], "verification_steps": ["Check that the service uses HTTPS.", "Inspect the certificate details to ensure it is issued by a trusted CA.", "Verify that the certificate is not expired.", "Ensure that the certificate chain is complete and valid."], "common_mistakes": ["Using self-signed certificates in production environments.", "Failing to renew certificates before they expire.", "Not validating the certificate chain properly."], "related_cwe": ["CWE-295: Improper Certificate Validation", "CWE-300: Channel Accessible by Non-Endpoint ('Man-in-the-Middle')"], "related_capec": ["CAPEC-145: Man-in-the-Middle Attack", "CAPEC-148: SSL Stripping"], "attack_flow": "An attacker can exploit a service that does not use a publicly trusted TLS certificate by intercepting the communication between the client and the server. They can present a self-signed or invalid certificate to the client, which may trust it due to lack of proper validation. This allows the attacker to read and modify the data being transmitted, leading to potential data breaches or unauthorized access."}
{"chapter_id": "V12", "chapter_name": "Secure Communication", "section_id": "V12.3", "section_name": "General Service to Service Communication Security", "req_id": "V12.3.1", "req_description": "Verify that an encrypted protocol such as TLS is used for all inbound and outbound connections to and from the application, including monitoring systems, management tools, remote access and SSH, middleware, databases, mainframes, partner systems, or external APIs. The server must not fall back to insecure or unencrypted protocols.", "level": "2", "explanation": "This requirement mandates that all communications involving the application must utilize encryption to protect data in transit. This includes not only user-facing connections but also internal communications between services and systems. The use of protocols like TLS ensures that data is encrypted, preventing eavesdropping and tampering. Additionally, it is crucial to configure servers to reject any attempts to negotiate insecure protocols, thereby enforcing security standards.", "threats_mitigated": ["Man-in-the-Middle (MitM) attacks", "Eavesdropping", "Data tampering", "Session hijacking"], "insecure_examples": ["http://example.com/api/data", "ssh -o 'KexAlgorithms=+diffie-hellman-group1-sha1' user@host"], "secure_examples": ["https://example.com/api/data", "ssh -o 'KexAlgorithms=diffie-hellman-group-exchange-sha256' user@host"], "verification_steps": ["Check that all endpoints use HTTPS or other encrypted protocols.", "Verify server configurations to ensure they do not allow fallback to unencrypted protocols.", "Review application code for any hardcoded URLs that use insecure protocols.", "Test for proper certificate validation in the application."], "common_mistakes": ["Using hardcoded HTTP URLs in the application code.", "Failing to configure servers to disable insecure protocols.", "Neglecting to update TLS configurations to use strong cipher suites.", "Assuming that internal communications do not require encryption."], "related_cwe": ["CWE-319", "CWE-295", "CWE-300"], "related_capec": ["CAPEC-132", "CAPEC-137", "CAPEC-144"], "attack_flow": "An attacker intercepts communication between the client and server, exploiting the use of an insecure protocol. By capturing the data packets, the attacker can read sensitive information or manipulate the data being sent, leading to unauthorized access or data breaches."}
{"chapter_id": "V12", "chapter_name": "Secure Communication", "section_id": "V12.3", "section_name": "General Service to Service Communication Security", "req_id": "V12.3.2", "req_description": "Verify that TLS clients validate certificates received before communicating with a TLS server.", "level": "2", "explanation": "This requirement ensures that TLS clients perform proper validation of the server's TLS certificate to prevent man-in-the-middle (MITM) attacks and ensure that they are communicating with the intended server. Proper validation includes checking the certificate's validity period, ensuring it is signed by a trusted Certificate Authority (CA), and verifying that the certificate matches the server's hostname.", "threats_mitigated": ["Man-in-the-Middle (MITM) attacks", "Impersonation of legitimate servers", "Data interception during transmission"], "insecure_examples": [{"code": "var client = new HttpClient();\nclient.BaseAddress = new Uri(\"https://example.com\");\nvar response = await client.GetAsync(\"/api/data\");"}, {"code": "var httpClient = new HttpClient();\nhttpClient.DefaultRequestHeaders.Accept.Clear();\nhttpClient.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue(\"application/json\"));\nvar result = await httpClient.GetAsync(\"https://unverified-server.com\");"}], "secure_examples": [{"code": "var handler = new HttpClientHandler();\nhandler.ServerCertificateCustomValidationCallback = (message, cert, chain, sslPolicyErrors) => {\n    return sslPolicyErrors == SslPolicyErrors.None;\n};\nvar client = new HttpClient(handler);\nclient.BaseAddress = new Uri(\"https://example.com\");\nvar response = await client.GetAsync(\"/api/data\");"}, {"code": "var handler = new HttpClientHandler();\nhandler.ServerCertificateCustomValidationCallback = (message, cert, chain, sslPolicyErrors) => {\n    return cert.GetCertHashString() == \"EXPECTED_HASH\";\n};\nvar httpClient = new HttpClient(handler);\nvar result = await httpClient.GetAsync(\"https://verified-server.com\");"}], "verification_steps": ["Check that the application uses TLS for all communications.", "Ensure that the client validates the server's certificate against a trusted CA.", "Verify that hostname verification is implemented.", "Check for proper handling of certificate errors."], "common_mistakes": ["Not validating the server's certificate at all.", "Using self-signed certificates without proper validation.", "Ignoring SSL/TLS errors in production environments.", "Hardcoding certificate details instead of validating dynamically."], "related_cwe": ["CWE-295", "CWE-300", "CWE-287"], "related_capec": ["CAPEC-154", "CAPEC-139"], "attack_flow": "An attacker intercepts the communication between the client and server, presenting a fraudulent certificate. If the client does not validate the server's certificate, it may establish a connection with the attacker, allowing them to eavesdrop or manipulate the data being transmitted."}
{"chapter_id": "V12", "chapter_name": "Secure Communication", "section_id": "V12.3", "section_name": "General Service to Service Communication Security", "req_id": "V12.3.3", "req_description": "Verify that TLS or another appropriate transport encryption mechanism used for all connectivity between internal, HTTP-based services within the application, and does not fall back to insecure or unencrypted communications.", "level": 2, "explanation": "This requirement mandates the use of secure transport protocols, such as TLS, for all internal communications between services. It ensures that sensitive data is encrypted in transit, protecting it from eavesdropping and tampering. It also emphasizes the importance of preventing fallback to insecure protocols, which can expose data to potential attacks.", "threats_mitigated": ["Man-in-the-Middle (MitM) attacks", "Eavesdropping", "Data tampering", "Session hijacking"], "insecure_examples": ["http://internal-service.example.com/api/data", "curl -X GET http://internal-service.example.com/api/data"], "secure_examples": ["https://internal-service.example.com/api/data", "curl -X GET https://internal-service.example.com/api/data"], "verification_steps": ["Check that all service-to-service communications use HTTPS or another secure protocol.", "Review configuration files for any instances of HTTP instead of HTTPS.", "Ensure that there are no fallback mechanisms to unencrypted protocols.", "Test the application to verify that it does not accept insecure connections."], "common_mistakes": ["Using HTTP instead of HTTPS for internal service communication.", "Failing to enforce strict transport security policies.", "Neglecting to update TLS configurations to use strong cipher suites."], "related_cwe": ["CWE-319", "CWE-295", "CWE-300"], "related_capec": ["CAPEC-92", "CAPEC-155"], "attack_flow": "An attacker intercepts the communication between two internal services by exploiting the use of HTTP instead of HTTPS. They can capture sensitive data being transmitted, manipulate the data, or impersonate one of the services, leading to unauthorized access or data breaches."}
{"chapter_id": "V12", "chapter_name": "Secure Communication", "section_id": "V12.3", "section_name": "General Service to Service Communication Security", "req_id": "V12.3.4", "req_description": "Verify that TLS connections between internal services use trusted certificates. Where internally generated or self-signed certificates are used, the consuming service must be configured to only trust specific internal CAs and specific self-signed certificates.", "level": "2", "explanation": "This requirement ensures that all internal service communications are secured using TLS (Transport Layer Security) with certificates that are validated against trusted Certificate Authorities (CAs). This prevents man-in-the-middle attacks and ensures data integrity and confidentiality during transmission. When using self-signed certificates, it is crucial to configure services to trust only specific certificates to avoid accepting any potentially malicious certificates.", "threats_mitigated": ["Man-in-the-Middle (MitM) attacks", "Eavesdropping on sensitive data", "Data tampering during transmission", "Unauthorized access to internal services"], "insecure_examples": ["serviceA.connect(serviceB, { tls: true }); // No certificate validation", "const tls = require('tls'); const socket = tls.connect(port, host); // Using self-signed cert without validation"], "secure_examples": ["const fs = require('fs'); const tls = require('tls'); const options = { ca: fs.readFileSync('trustedCA.pem') }; const socket = tls.connect(port, host, options); // Validating against trusted CA", "serviceA.connect(serviceB, { tls: true, ca: [trustedCACert] }); // Ensuring only trusted CA is used"], "verification_steps": ["Check that TLS is enforced for all internal service communications.", "Verify that trusted certificates are used for TLS connections.", "Ensure that self-signed certificates are explicitly trusted by the consuming service.", "Review the configuration to confirm that only specific internal CAs are trusted."], "common_mistakes": ["Using default or self-signed certificates without proper validation.", "Failing to configure services to trust only specific internal CAs.", "Not enforcing TLS for all internal communications.", "Ignoring certificate expiration and renewal processes."], "related_cwe": ["CWE-295: Improper Certificate Validation", "CWE-300: Channel Accessible by Non-Endpoint ('Man-in-the-Middle')"], "related_capec": ["CAPEC-100: Man-in-the-Middle Attack", "CAPEC-119: SSL Stripping"], "attack_flow": "An attacker could intercept the communication between two internal services by exploiting a lack of proper certificate validation. If the services do not verify the authenticity of the certificates, the attacker could present a fraudulent certificate, allowing them to decrypt and manipulate the data being transmitted between the services."}
{"chapter_id": "V12", "chapter_name": "Secure Communication", "section_id": "V12.3", "section_name": "General Service to Service Communication Security", "req_id": "V12.3.5", "req_description": "Verify that services communicating internally within a system (intra-service communications) use strong authentication to ensure that each endpoint is verified. Strong authentication methods, such as TLS client authentication, must be employed to ensure identity, using public-key infrastructure and mechanisms that are resistant to replay attacks. For microservice architectures, consider using a service mesh to simplify certificate management and enhance security.", "level": 3, "explanation": "This requirement emphasizes the importance of securing internal communications between services in a system. It mandates the use of strong authentication methods to verify the identity of each service endpoint. By employing techniques like TLS client authentication, services can ensure that they are communicating with legitimate endpoints, thereby preventing unauthorized access and potential data breaches. The use of a service mesh can further streamline the management of certificates and enhance overall security in microservice architectures.", "threats_mitigated": ["Unauthorized access to services", "Man-in-the-middle attacks", "Replay attacks", "Impersonation of services"], "insecure_examples": [{"code_snippet": "httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\"Bearer\", token);"}, {"code_snippet": "serviceUrl = \"http://internal-service\"; // No authentication"}], "secure_examples": [{"code_snippet": "var handler = new HttpClientHandler(); handler.ClientCertificateOptions = ClientCertificateOption.Manual; handler.SslProtocols = SslProtocols.Tls12; httpClient = new HttpClient(handler);"}, {"code_snippet": "serviceUrl = \"https://internal-service\"; // Uses HTTPS with client authentication"}], "verification_steps": ["Check that TLS is enforced for all internal service communications.", "Verify that client certificates are used for authentication.", "Ensure that service endpoints are configured to validate the identity of clients.", "Review the implementation of service mesh for certificate management."], "common_mistakes": ["Using plain HTTP for internal service communication.", "Not validating client certificates properly.", "Failing to rotate certificates regularly.", "Ignoring replay attack prevention mechanisms."], "related_cwe": ["CWE-287", "CWE-295", "CWE-300"], "related_capec": ["CAPEC-113", "CAPEC-128", "CAPEC-139"], "attack_flow": "An attacker could intercept communications between two services if they are not using strong authentication. By exploiting this weakness, the attacker could impersonate one of the services, gaining unauthorized access to sensitive data or functionality. If the communication lacks replay attack resistance, the attacker could also replay previously captured messages to manipulate the system's behavior."}
{"chapter_id": "V13", "chapter_name": "Configuration", "section_id": "V13.1", "section_name": "Configuration Documentation", "req_id": "V13.1.1", "req_description": "Verify that all communication needs for the application are documented. This must include external services which the application relies upon and cases where an end user might be able to provide an external location to which the application will then connect.", "level": "2", "explanation": "This requirement emphasizes the importance of maintaining comprehensive documentation regarding all communication channels utilized by the application. This includes detailing external services that the application interacts with, as well as any user-supplied inputs that could lead to external connections. Proper documentation helps in understanding the application's architecture and identifying potential security risks associated with these communications.", "threats_mitigated": ["Unauthorized access to external services", "Data leakage through unmonitored connections", "Injection attacks via user-supplied endpoints"], "insecure_examples": ["const apiUrl = userInput; // User input directly used without validation\nfetch(apiUrl);", "const externalService = 'http://example.com/api';\n// No documentation of this external service's purpose or security posture."], "secure_examples": ["const apiUrl = validateAndSanitize(userInput); // User input is validated and sanitized before use\nfetch(apiUrl);", "const externalService = 'http://example.com/api';\n// Documented external service with purpose and security considerations."], "verification_steps": ["Check for documentation of all external services the application interacts with.", "Verify that user-supplied endpoints are validated and documented.", "Ensure that there is a clear understanding of the communication flow in the application."], "common_mistakes": ["Failing to document third-party services used in the application.", "Neglecting to validate user inputs that are used to construct external requests.", "Assuming that all communication is secure without proper documentation."], "related_cwe": ["CWE-20: Improper Input Validation", "CWE-284: Improper Access Control", "CWE-200: Information Exposure"], "related_capec": ["CAPEC-137: Exploiting External Services", "CAPEC-145: Injection of Malicious Code via User Input", "CAPEC-91: Misuse of External APIs"], "attack_flow": "An attacker may exploit a lack of documentation by providing a malicious endpoint as user input. If this input is not properly validated, the application may connect to this endpoint, leading to unauthorized data access or manipulation. The absence of documentation can also prevent developers from understanding the risks associated with external communications, increasing the likelihood of successful attacks."}
{"chapter_id": "V13", "chapter_name": "Configuration", "section_id": "V13.1", "section_name": "Configuration Documentation", "req_id": "V13.1.2", "req_description": "Verify that for each service the application uses, the documentation defines the maximum number of concurrent connections (e.g., connection pool limits) and how the application behaves when that limit is reached, including any fallback or recovery mechanisms, to prevent denial of service conditions.", "level": 3, "explanation": "This requirement emphasizes the importance of documenting the limits on concurrent connections for services used by the application. It ensures that developers and operators understand how the application will respond when these limits are reached, which is crucial for maintaining service availability and preventing denial of service (DoS) attacks. Proper documentation should outline the maximum connection thresholds and the strategies employed to handle situations where these limits are exceeded, such as queuing requests, returning error messages, or gracefully degrading service functionality.", "threats_mitigated": ["Denial of Service (DoS)", "Resource exhaustion", "Service unavailability"], "insecure_examples": ["connectionPool.setMaxConnections(100); // No documentation on behavior when limit is reached", "app.use(service).maxConnections = 50; // No fallback mechanism defined"], "secure_examples": ["connectionPool.setMaxConnections(100); // Documentation includes behavior on reaching limit: 'Requests will be queued until a connection is available.'", "app.use(service).maxConnections = 50; // Documentation specifies fallback: 'Returns HTTP 503 when limit is reached, with retry-after header.'"], "verification_steps": ["Check if the documentation specifies maximum concurrent connection limits for each service.", "Verify that the documentation describes the application's behavior when limits are reached.", "Ensure fallback or recovery mechanisms are documented and appropriate.", "Review code to confirm implementation aligns with documented behavior."], "common_mistakes": ["Failing to document maximum connection limits.", "Not specifying how the application handles limits being reached.", "Ignoring fallback mechanisms in the documentation.", "Assuming default behaviors without verification."], "related_cwe": ["CWE-400: Uncontrolled Resource Consumption", "CWE-770: Allocation of Resources Without Limits"], "related_capec": ["CAPEC-137: Resource Exhaustion", "CAPEC-149: Denial of Service via Resource Consumption"], "attack_flow": "An attacker may attempt to overwhelm the application by sending a large number of requests, exceeding the defined maximum concurrent connections. If the application is not properly documented and lacks adequate fallback mechanisms, it may either crash or become unresponsive, leading to denial of service for legitimate users. Proper documentation and implementation of connection limits and fallback strategies can help mitigate this risk."}
{"chapter_id": "V13", "chapter_name": "Configuration", "section_id": "V13.1", "section_name": "Configuration Documentation", "req_id": "V13.1.3", "req_description": "Verify that the application documentation defines resourceâ€‘management strategies for every external system or service it uses (e.g., databases, file handles, threads, HTTP connections). This should include resourceâ€‘release procedures, timeout settings, failure handling, and where retry logic is implemented, specifying retry limits, delays, and backâ€‘off algorithms. For synchronous HTTP requestâ€“response operations it should mandate short timeouts and either disable retries or strictly limit retries to prevent cascading delays and resource exhaustion.", "level": "3", "explanation": "This requirement emphasizes the importance of having comprehensive documentation that outlines how resources are managed when interacting with external systems. Proper documentation helps ensure that developers know how to handle resources effectively, which can prevent issues such as resource leaks, excessive retries leading to performance degradation, and system crashes due to resource exhaustion. It is crucial for maintaining application performance and reliability.", "threats_mitigated": ["Resource exhaustion", "Denial of Service (DoS)", "Performance degradation", "Cascading failures"], "insecure_examples": [{"code": "httpClient.setRetryPolicy(new RetryPolicy()); // No limits on retries"}, {"code": "while (true) { // Infinite loop without timeout or release of resources\n  // Perform HTTP request\n}"}], "secure_examples": [{"code": "httpClient.setRetryPolicy(new RetryPolicy(3, 1000, 2)); // Limit to 3 retries with back-off"}, {"code": "try (Resource resource = getResource()) { // Use try-with-resources to ensure proper release\n  // Perform HTTP request\n}"}], "verification_steps": ["Review application documentation for resource management strategies.", "Check for defined timeout settings for external service calls.", "Verify that retry logic is documented with limits and back-off strategies.", "Ensure that resource release procedures are clearly outlined.", "Confirm that synchronous HTTP operations have short timeout settings."], "common_mistakes": ["Failing to document resource management strategies.", "Not implementing timeout settings for external service calls.", "Allowing unlimited retries without back-off logic.", "Neglecting to release resources properly after use."], "related_cwe": ["CWE-400", "CWE-770", "CWE-754"], "related_capec": ["CAPEC-137", "CAPEC-153"], "attack_flow": "An attacker can exploit the lack of proper resource management documentation by intentionally overwhelming the application with requests. If the application does not have limits on retries or timeout settings, this can lead to resource exhaustion, causing the application to slow down or crash. The attacker may leverage this to perform a Denial of Service attack, rendering the application unavailable to legitimate users."}
{"chapter_id": "V13", "chapter_name": "Configuration", "section_id": "V13.1", "section_name": "Configuration Documentation", "req_id": "V13.1.4", "req_description": "Verify that the application's documentation defines the secrets that are critical for the security of the application and a schedule for rotating them, based on the organization's threat model and business requirements.", "level": 3, "explanation": "This requirement emphasizes the importance of maintaining comprehensive documentation regarding sensitive information, such as API keys, passwords, and cryptographic keys. It should detail which secrets are critical for the application's security and establish a rotation schedule to mitigate the risk of exposure. This documentation should align with the organization's threat model, which assesses potential risks and vulnerabilities, and business requirements, which dictate how often secrets should be rotated to maintain security.", "threats_mitigated": ["Unauthorized access due to leaked secrets", "Data breaches resulting from static credentials", "Insider threats exploiting outdated secrets"], "insecure_examples": ["1. Hardcoded secrets in source code:\n   const API_KEY = '12345-ABCDE';\n\n2. Lack of documentation on secret rotation:\n   // No mention of how often to change API keys"], "secure_examples": ["1. Use environment variables to store secrets:\n   const API_KEY = process.env.API_KEY;\n\n2. Documentation includes a rotation schedule:\n   'API keys should be rotated every 90 days as per the security policy.'"], "verification_steps": ["Check if the documentation exists for critical secrets.", "Verify that the documentation includes a defined rotation schedule.", "Ensure the secrets are not hardcoded in the source code.", "Review the alignment of the documentation with the organization's threat model."], "common_mistakes": ["Failing to update documentation after changing secrets.", "Not having a defined rotation schedule.", "Hardcoding secrets in the application code."], "related_cwe": ["CWE-256: Unencrypted Storage of Sensitive Information", "CWE-798: Use of Hard-coded Credentials"], "related_capec": ["CAPEC-137: Credential Dumping", "CAPEC-143: Credential Theft via Keylogging"], "attack_flow": "An attacker may gain access to the application's source code or configuration files where secrets are hardcoded or poorly documented. If the documentation does not specify a rotation schedule, the attacker can exploit the static secrets for unauthorized access, leading to data breaches or further attacks on the system."}
{"chapter_id": "V13", "chapter_name": "Configuration", "section_id": "V13.2", "section_name": "Backend Communication Configuration", "req_id": "V13.2.1", "req_description": "Verify that communications between backend application components that don't support the application's standard user session mechanism, including APIs, middleware, and data layers, are authenticated. Authentication must use individual service accounts, short-term tokens, or certificate-based authentication and not unchanging credentials such as passwords, API keys, or shared accounts with privileged access.", "level": "2", "explanation": "This requirement emphasizes the importance of authenticating backend communications in a secure manner. It mandates the use of secure authentication methods that prevent unauthorized access and ensure that only legitimate services can communicate with each other. By avoiding static credentials, the risk of credential theft and misuse is significantly reduced.", "threats_mitigated": ["Unauthorized access to backend services", "Credential theft", "Man-in-the-middle attacks", "Replay attacks"], "insecure_examples": [{"code": "const apiKey = '12345-ABCDE';\nfetch('https://api.example.com/data', {\n  headers: { 'Authorization': `Bearer ${apiKey}` }\n});"}, {"code": "const username = 'admin';\nconst password = 'password';\n\nconst response = await fetch('https://api.example.com/secure-data', {\n  method: 'GET',\n  headers: { 'Authorization': 'Basic ' + btoa(username + ':' + password) }\n});"}], "secure_examples": [{"code": "const token = generateShortTermToken();\nfetch('https://api.example.com/data', {\n  headers: { 'Authorization': `Bearer ${token}` }\n});"}, {"code": "const cert = loadServiceCertificate();\nconst response = await fetch('https://api.example.com/secure-data', {\n  method: 'GET',\n  headers: { 'Authorization': `Bearer ${cert}` }\n});"}], "verification_steps": ["Check that all backend component communications are authenticated.", "Ensure that individual service accounts are used for authentication.", "Verify that short-term tokens or certificate-based authentication is implemented.", "Review code for hardcoded credentials and replace them with secure methods."], "common_mistakes": ["Using static API keys or passwords for backend authentication.", "Sharing service accounts among multiple components.", "Neglecting to implement token expiration and renewal mechanisms.", "Failing to validate the authenticity of certificates."], "related_cwe": ["CWE-287", "CWE-798", "CWE-295"], "related_capec": ["CAPEC-137", "CAPEC-156"], "attack_flow": "An attacker can exploit this requirement by intercepting unprotected communications between backend components. If static credentials are used, the attacker can gain unauthorized access to services, potentially leading to data breaches or manipulation of sensitive information. By using techniques such as replay attacks, they can impersonate legitimate services and perform actions without authorization."}
{"chapter_id": "V13", "chapter_name": "Configuration", "section_id": "V13.2", "section_name": "Backend Communication Configuration", "req_id": "V13.2.2", "req_description": "Verify that communications between backend application components, including local or operating system services, APIs, middleware, and data layers, are performed with accounts assigned the least necessary privileges.", "level": "2", "explanation": "This requirement emphasizes the principle of least privilege, which states that any component or service should operate using the minimum level of access rights necessary to perform its function. This minimizes the potential attack surface and limits the damage that can occur if a component is compromised.", "threats_mitigated": ["Unauthorized access to sensitive data", "Privilege escalation", "Data leakage", "Service disruption"], "insecure_examples": [{"code": "const apiClient = new ApiClient({ user: 'admin', password: 'admin123' });"}, {"code": "dbConnection = new DatabaseConnection({ user: 'root', password: 'rootpass' });"}], "secure_examples": [{"code": "const apiClient = new ApiClient({ user: 'limitedUser', password: 'securePassword' });"}, {"code": "dbConnection = new DatabaseConnection({ user: 'appUser', password: 'strongPassword' });"}], "verification_steps": ["Review the configuration of backend components to ensure they are using non-administrative accounts.", "Check for hardcoded credentials in the codebase.", "Audit the permissions assigned to service accounts to ensure they are limited to only what is necessary.", "Verify that access controls are enforced at the API and database levels."], "common_mistakes": ["Using administrative accounts for routine operations.", "Hardcoding sensitive credentials in the source code.", "Failing to regularly review and update service account permissions.", "Assuming that all components require full administrative access."], "related_cwe": ["CWE-250: Execution with Unnecessary Privileges", "CWE-276: Incorrect Default Permissions"], "related_capec": ["CAPEC-116: Exploiting Privileged Access", "CAPEC-137: Credential Theft"], "attack_flow": "An attacker may exploit a backend component that operates with excessive privileges to gain unauthorized access to sensitive data or services. For example, if a service is running with administrative privileges, an attacker could leverage this to execute arbitrary commands, manipulate data, or escalate their access within the system."}
{"chapter_id": "V13", "chapter_name": "Configuration", "section_id": "V13.2", "section_name": "Backend Communication Configuration", "req_id": "V13.2.3", "req_description": "Verify that if a credential has to be used for service authentication, the credential being used by the consumer is not a default credential (e.g., root/root or admin/admin).", "level": "2", "explanation": "This requirement emphasizes the importance of using unique, non-default credentials for service authentication. Default credentials are widely known and can be easily exploited by attackers. By ensuring that services do not use default credentials, the security posture of the application is significantly improved, reducing the risk of unauthorized access.", "threats_mitigated": ["Unauthorized access", "Credential stuffing attacks", "Brute force attacks"], "insecure_examples": ["const username = 'admin';\nconst password = 'admin';\n// Using default credentials for service authentication", "service.authenticate('root', 'root'); // Default credentials used"], "secure_examples": ["const username = 'uniqueUser';\nconst password = 'strongPassword123!';\n// Using custom credentials for service authentication", "service.authenticate('user123', 'secureP@ssw0rd'); // Secure credentials used"], "verification_steps": ["Review the authentication configuration for services.", "Check for the presence of default credentials in the codebase.", "Verify that all service accounts have unique credentials.", "Test the application to ensure that default credentials cannot be used."], "common_mistakes": ["Failing to change default credentials after deployment.", "Using easily guessable usernames and passwords.", "Neglecting to audit service accounts for default credentials."], "related_cwe": ["CWE-798: Use of Hard-coded Credentials", "CWE-307: Improper Restriction of Excessive Authentication Attempts"], "related_capec": ["CAPEC-137: Default Credentials Attack", "CAPEC-155: Credential Stuffing"], "attack_flow": "An attacker identifies a service that uses default credentials. They attempt to authenticate using these credentials, gaining unauthorized access to the service. Once inside, the attacker can manipulate data, escalate privileges, or further compromise the system."}
{"chapter_id": "V13", "chapter_name": "Configuration", "section_id": "V13.2", "section_name": "Backend Communication Configuration", "req_id": "V13.2.4", "req_description": "Verify that an allowlist is used to define the external resources or systems with which the application is permitted to communicate (e.g., for outbound requests, data loads, or file access). This allowlist can be implemented at the application layer, web server, firewall, or a combination of different layers.", "level": "2", "explanation": "This requirement emphasizes the importance of restricting an application's communication to only those external resources that are explicitly permitted. By implementing an allowlist, developers can prevent unauthorized access to sensitive data and reduce the risk of data breaches or malicious activities. The allowlist should be carefully maintained and reviewed regularly to ensure that only necessary resources are included.", "threats_mitigated": ["Data exfiltration", "Unauthorized access to external systems", "Man-in-the-middle attacks", "Injection attacks through untrusted external resources"], "insecure_examples": [{"code": "fetch('http://untrusted.example.com/data')"}, {"code": "httpClient.get('http://example.com/api/resource')"}], "secure_examples": [{"code": "const allowedUrls = ['https://trusted.example.com/data']; if (allowedUrls.includes(url)) { fetch(url); }"}, {"code": "const allowedDomains = ['https://api.example.com']; if (allowedDomains.includes(request.url)) { httpClient.get(request.url); }"}], "verification_steps": ["Review the application's configuration files for allowlist implementation.", "Check for external communication points in the codebase.", "Ensure that all external resources are included in the allowlist.", "Test the application to confirm that it only communicates with allowed resources."], "common_mistakes": ["Failing to update the allowlist when new resources are added.", "Using a blocklist instead of an allowlist, which is less secure.", "Not reviewing the allowlist regularly for outdated or unnecessary entries."], "related_cwe": ["CWE-20: Improper Input Validation", "CWE-284: Improper Access Control", "CWE-918: Server-Side Request Forgery (SSRF)"], "related_capec": ["CAPEC-138: Exploiting Insecure External Resource References", "CAPEC-145: Data Exfiltration via External Services"], "attack_flow": "An attacker could exploit a lack of an allowlist by sending requests to unauthorized external resources, potentially leading to data theft or manipulation. For example, if the application allows communication with any external URL, an attacker could craft a request to a malicious server to exfiltrate sensitive information or to perform actions on behalf of the application."}
{"chapter_id": "V13", "chapter_name": "Configuration", "section_id": "V13.2", "section_name": "Backend Communication Configuration", "req_id": "V13.2.5", "req_description": "Verify that the web or application server is configured with an allowlist of resources or systems to which the server can send requests or load data or files from.", "level": 2, "explanation": "This requirement mandates that the server should only communicate with predefined, trusted resources. By implementing an allowlist, you restrict the server's ability to interact with potentially harmful or untrusted external systems, thereby reducing the attack surface and preventing unauthorized data exfiltration or interaction.", "threats_mitigated": ["Server-Side Request Forgery (SSRF)", "Data Exfiltration", "Unauthorized API Access", "Malicious External Resource Interaction"], "insecure_examples": ["fetch('http://untrusted.example.com/resource');", "const response = await axios.get('http://malicious.example.com/data');"], "secure_examples": ["const allowedUrls = ['https://trusted.example.com/resource']; if (allowedUrls.includes(requestedUrl)) { fetch(requestedUrl); }", "const response = await axios.get('https://trusted.example.com/data');"], "verification_steps": ["Review server configuration files for allowlist settings.", "Check that all external requests are validated against the allowlist.", "Ensure that the allowlist is regularly updated and maintained.", "Conduct penetration testing to verify that unauthorized requests are blocked."], "common_mistakes": ["Failing to update the allowlist when new trusted resources are added.", "Using a broad allowlist that includes untrusted domains.", "Not validating user input before sending requests to external systems."], "related_cwe": ["CWE-918: Server-Side Request Forgery (SSRF)", "CWE-200: Information Exposure", "CWE-284: Improper Access Control"], "related_capec": ["CAPEC-139: Server-Side Request Forgery", "CAPEC-152: External Service Interaction"], "attack_flow": "An attacker can exploit this requirement by tricking the server into making requests to malicious external systems. If the server is not configured with an allowlist, it may inadvertently send sensitive data or perform actions on behalf of the attacker, leading to unauthorized access or data breaches."}
{"chapter_id": "V13", "chapter_name": "Configuration", "section_id": "V13.2", "section_name": "Backend Communication Configuration", "req_id": "V13.2.6", "req_description": "Verify that where the application connects to separate services, it follows the documented configuration for each connection, such as maximum parallel connections, behavior when maximum allowed connections is reached, connection timeouts, and retry strategies.", "level": 3, "explanation": "This requirement ensures that applications adhere to predefined configurations when communicating with external services. Proper configuration helps manage resource utilization, prevents service overload, and ensures reliability in communication. It is essential to define limits on connections and have strategies in place for handling failures or timeouts.", "threats_mitigated": ["Denial of Service (DoS)", "Resource exhaustion", "Service unavailability", "Inconsistent application behavior"], "insecure_examples": ["const axios = require('axios');\n\naxios.get('https://example.com/api', { maxRedirects: 5 }); // No connection limits or timeout settings", "const connectionPool = new Pool();\nconnectionPool.connect(); // No handling for maximum connections or retries"], "secure_examples": ["const axios = require('axios');\n\naxios.get('https://example.com/api', { timeout: 5000, maxRedirects: 5, maxConnections: 10 }); // Configured with timeout and connection limits", "const connectionPool = new Pool({ max: 10, connectionTimeoutMillis: 5000 });\nconnectionPool.connect().catch(err => { /* handle connection error */ }); // Properly configured with limits and error handling"], "verification_steps": ["Check the configuration documentation for each service connection.", "Verify that maximum parallel connections are defined and enforced.", "Ensure that connection timeouts are set appropriately.", "Review retry strategies and confirm they are implemented correctly.", "Test the application under load to ensure it behaves as expected when limits are reached."], "common_mistakes": ["Failing to document connection settings leading to inconsistent configurations.", "Not setting connection limits, resulting in potential service overload.", "Ignoring timeout settings, which can lead to hanging requests.", "Lack of retry logic, causing failures on transient issues."], "related_cwe": ["CWE-400", "CWE-770", "CWE-754"], "related_capec": ["CAPEC-137", "CAPEC-148"], "attack_flow": "An attacker may exploit a lack of connection limits by initiating numerous requests to the service, overwhelming it and causing a denial of service. If timeouts are not configured, the application may hang, leading to resource exhaustion. Without retry strategies, transient network issues can cause the application to fail, resulting in inconsistent behavior and potential data loss."}
{"chapter_id": "V13", "chapter_name": "Configuration", "section_id": "V13.3", "section_name": "Secret Management", "req_id": "V13.3.1", "req_description": "Verify that a secrets management solution, such as a key vault, is used to securely create, store, control access to, and destroy backend secrets. These could include passwords, key material, integrations with databases and third-party systems, keys and seeds for time-based tokens, other internal secrets, and API keys. Secrets must not be included in application source code or included in build artifacts. For an L3 application, this must involve a hardware-backed solution such as an HSM.", "level": 2, "explanation": "This requirement emphasizes the importance of using a dedicated secrets management solution to handle sensitive information securely. It ensures that secrets are not hardcoded in the application code or stored in insecure locations. A proper secrets management solution should provide features like encryption, access control, and auditing to protect sensitive data throughout its lifecycle.", "threats_mitigated": ["Exposure of sensitive information", "Unauthorized access to backend systems", "Data breaches", "Credential theft"], "insecure_examples": [{"code_snippet": "const apiKey = '12345-abcde'; // Hardcoded API key in source code"}, {"code_snippet": "dbPassword = 'password123'; // Hardcoded database password in configuration file"}], "secure_examples": [{"code_snippet": "const apiKey = process.env.API_KEY; // API key retrieved from environment variable"}, {"code_snippet": "dbPassword = secretsManager.getSecret('dbPassword'); // Securely fetched from a secrets management solution"}], "verification_steps": ["Check that secrets are not hardcoded in the source code.", "Verify that a secrets management solution is in place.", "Ensure that secrets are encrypted both at rest and in transit.", "Review access control policies for the secrets management solution.", "Confirm that secrets are rotated regularly and old secrets are destroyed."], "common_mistakes": ["Hardcoding secrets directly in the source code.", "Storing secrets in version control systems.", "Neglecting to rotate secrets periodically.", "Using weak access controls for secrets management."], "related_cwe": ["CWE-256", "CWE-798", "CWE-312"], "related_capec": ["CAPEC-138", "CAPEC-145", "CAPEC-153"], "attack_flow": "An attacker may exploit this requirement by searching for hardcoded secrets in the source code or build artifacts. If found, these secrets can be used to gain unauthorized access to backend systems or services, leading to data breaches or further exploitation of the application."}
{"chapter_id": "V13", "chapter_name": "Configuration", "section_id": "V13.3", "section_name": "Secret Management", "req_id": "V13.3.2", "req_description": "Verify that access to secret assets adheres to the principle of least privilege.", "level": 2, "explanation": "This requirement emphasizes that access to sensitive information, such as API keys, passwords, and other secret assets, should be limited to only those users or systems that absolutely need it to perform their functions. This minimizes the risk of unauthorized access and potential data breaches.", "threats_mitigated": ["Unauthorized access to sensitive information", "Data breaches", "Privilege escalation attacks"], "insecure_examples": ["const secret = process.env.SECRET_KEY; // Accessing secret without restrictions", "user.grantAccess('admin', 'allSecrets'); // Granting all users access to all secrets"], "secure_examples": ["const secret = process.env.SECRET_KEY; // Accessing secret with role-based checks", "if (user.hasRole('admin')) { user.grantAccess('admin', 'limitedSecrets'); } // Granting access based on roles"], "verification_steps": ["Review access control policies for secret management.", "Check that only authorized users have access to secret assets.", "Ensure that access rights are regularly reviewed and updated.", "Verify that access logs are maintained and monitored."], "common_mistakes": ["Granting broad access to secret assets without proper role checks.", "Failing to regularly review and update access permissions.", "Not implementing logging and monitoring for access to secret assets."], "related_cwe": ["CWE-284", "CWE-732"], "related_capec": ["CAPEC-153", "CAPEC-105"], "attack_flow": "An attacker may exploit excessive access permissions by gaining access to a user account with unnecessary privileges. Once inside, the attacker can retrieve secret assets and use them to compromise systems, escalate privileges, or exfiltrate sensitive data."}
{"chapter_id": "V13", "chapter_name": "Configuration", "section_id": "V13.3", "section_name": "Secret Management", "req_id": "V13.3.3", "req_description": "Verify that all cryptographic operations are performed using an isolated security module (such as a vault or hardware security module) to securely manage and protect key material from exposure outside of the security module.", "level": "3", "explanation": "This requirement emphasizes the importance of using dedicated security modules for cryptographic operations. Isolated security modules, such as hardware security modules (HSMs) or dedicated vaults, provide a controlled environment for managing cryptographic keys and operations, reducing the risk of key exposure and misuse. By ensuring that all cryptographic operations are conducted within these secure environments, organizations can significantly enhance their security posture against key theft and unauthorized access.", "threats_mitigated": ["Key exposure", "Cryptographic key theft", "Unauthorized cryptographic operations", "Man-in-the-middle attacks", "Data breaches due to weak key management"], "insecure_examples": [{"code": "String key = \"mySecretKey\"; // Hardcoded key in source code"}, {"code": "Cipher cipher = Cipher.getInstance(\"AES\");\n// Using a key stored in a database without encryption"}], "secure_examples": [{"code": "KeyStore keyStore = KeyStore.getInstance(\"PKCS11\");\n// Using a hardware security module for key management"}, {"code": "SecretKeySpec keySpec = new SecretKeySpec(vault.getKey(), \"AES\");\n// Retrieving key securely from a vault"}], "verification_steps": ["Check that cryptographic keys are stored in a secure module.", "Verify that all cryptographic operations are performed within the security module.", "Ensure that access to the security module is restricted and logged.", "Review code for hardcoded keys and insecure key management practices."], "common_mistakes": ["Hardcoding cryptographic keys in source code.", "Storing keys in unsecured locations such as configuration files or databases.", "Failing to use secure modules for cryptographic operations.", "Not implementing proper access controls to security modules."], "related_cwe": ["CWE-256: Unprotected Storage of Credentials", "CWE-321: Use of Hard-coded Cryptographic Key", "CWE-312: Cleartext Storage of Sensitive Information"], "related_capec": ["CAPEC-137: Key Management Attack", "CAPEC-154: Cryptographic Key Theft", "CAPEC-150: Key Recovery Attack"], "attack_flow": "An attacker may exploit vulnerabilities in key management by accessing hardcoded keys in source code or by exploiting insecure storage locations. Once the attacker obtains the cryptographic keys, they can perform unauthorized cryptographic operations, leading to data breaches, unauthorized access to sensitive information, or impersonation of legitimate users."}
{"chapter_id": "V13", "chapter_name": "Configuration", "section_id": "V13.3", "section_name": "Secret Management", "req_id": "V13.3.4", "req_description": "Verify that secrets are configured to expire and be rotated based on the application's documentation.", "level": "3", "explanation": "This requirement emphasizes the importance of managing secrets (such as API keys, passwords, and tokens) by ensuring they have a defined expiration period and are rotated regularly. This practice minimizes the risk of unauthorized access due to leaked or compromised secrets, as expired secrets cannot be used by attackers.", "threats_mitigated": ["Credential theft", "Unauthorized access", "Replay attacks", "Insider threats"], "insecure_examples": ["const apiKey = '12345'; // Hardcoded secret without expiration\nfunction accessApi() { /* access API */ }", "const dbPassword = process.env.DB_PASSWORD; // No rotation policy defined"], "secure_examples": ["const apiKey = getSecret('apiKey'); // Fetch secret from a secure vault with expiration policy\nfunction accessApi() { /* access API */ }", "const dbPassword = rotateSecret(process.env.DB_PASSWORD); // Implement a rotation mechanism for the database password"], "verification_steps": ["Check the application's documentation for secret management policies.", "Verify that secrets have defined expiration dates.", "Ensure that there is a mechanism in place for rotating secrets.", "Review code to confirm that secrets are not hardcoded.", "Check for logging of secrets to ensure they are not exposed."], "common_mistakes": ["Failing to set expiration dates for secrets.", "Not implementing a rotation policy for secrets.", "Hardcoding secrets in source code.", "Neglecting to update documentation regarding secret management."], "related_cwe": ["CWE-256: Unencrypted Storage of a Password", "CWE-312: Cleartext Storage of Sensitive Information", "CWE-798: Use of Hard-coded Credentials"], "related_capec": ["CAPEC-155: Credential Theft", "CAPEC-168: Token Theft", "CAPEC-114: Replay Attack"], "attack_flow": "An attacker may exploit a system by stealing a secret that has not expired or has not been rotated. They can use this secret to gain unauthorized access to sensitive resources or perform actions on behalf of a legitimate user until the secret is rotated or expires."}
{"chapter_id": "V13", "chapter_name": "Configuration", "section_id": "V13.4", "section_name": "Unintended Information Leakage", "req_id": "V13.4.1", "req_description": "Verify that the application is deployed either without any source control metadata, including the .git or .svn folders, or in a way that these folders are inaccessible both externally and to the application itself.", "level": "1", "explanation": "This requirement ensures that sensitive information related to the application's source code and version control history is not exposed to unauthorized users. Source control metadata can contain sensitive information such as commit history, user credentials, and configuration settings that should not be publicly accessible. Proper deployment practices should ensure that these folders are either removed or secured to prevent information leakage.", "threats_mitigated": ["Information Disclosure", "Unauthorized Access", "Data Leakage"], "insecure_examples": [{"code_snippet": "The application is deployed with the .git folder accessible at https://example.com/.git/"}, {"code_snippet": "The application server exposes the .svn directory, allowing users to browse source control history."}], "secure_examples": [{"code_snippet": "The application is deployed without the .git folder, ensuring no source control metadata is present."}, {"code_snippet": "The .svn directory is configured to be inaccessible from the web server."}], "verification_steps": ["Check the deployment directory for the presence of .git or .svn folders.", "Attempt to access the .git or .svn folders via a web browser.", "Review server configuration to ensure these folders are not publicly accessible.", "Conduct a security scan to identify any exposed source control metadata."], "common_mistakes": ["Leaving source control folders in the deployment package.", "Improperly configuring web server settings to allow access to sensitive directories.", "Failing to remove or secure sensitive files during the deployment process."], "related_cwe": ["CWE-200", "CWE-201", "CWE-22"], "related_capec": ["CAPEC-134", "CAPEC-144"], "attack_flow": "An attacker discovers that the application is deployed with accessible source control metadata. They access the .git or .svn folder and retrieve sensitive information such as source code, configuration files, or credentials. This information can be used to exploit vulnerabilities in the application or gain unauthorized access to systems."}
{"chapter_id": "V13", "chapter_name": "Configuration", "section_id": "V13.4", "section_name": "Unintended Information Leakage", "req_id": "V13.4.2", "req_description": "Verify that debug modes are disabled for all components in production environments to prevent exposure of debugging features and information leakage.", "level": 2, "explanation": "This requirement emphasizes the importance of disabling debug modes in production settings. Debug modes can expose sensitive information such as stack traces, database queries, and application configurations, which can be exploited by attackers to gain insights into the application's inner workings and potentially compromise its security.", "threats_mitigated": ["Information Disclosure", "Sensitive Data Exposure", "Unauthorized Access to Debugging Information"], "insecure_examples": [{"code": "if (debugMode) { console.log(userData); }"}, {"code": "app.use(express.errorHandler()); // Debugging enabled in production"}], "secure_examples": [{"code": "if (debugMode) { /* Do not log sensitive information */ }"}, {"code": "app.use(express.errorHandler()); // Ensure this is disabled in production"}], "verification_steps": ["Check application configuration files for debug mode settings.", "Review deployment scripts for any debug mode flags.", "Conduct a security audit of the production environment to ensure debug features are not enabled.", "Test the application in production to ensure no debug information is exposed."], "common_mistakes": ["Leaving debug mode enabled during deployment.", "Failing to review configuration files before production release.", "Not having a separate configuration for development and production environments."], "related_cwe": ["CWE-200", "CWE-203", "CWE-209"], "related_capec": ["CAPEC-137", "CAPEC-145"], "attack_flow": "An attacker identifies that debug mode is enabled in a production environment. They send requests to the application and receive detailed error messages that include stack traces and sensitive data. This information allows the attacker to understand the application structure and potentially exploit vulnerabilities, leading to unauthorized access or data breaches."}
{"chapter_id": "V13", "chapter_name": "Configuration", "section_id": "V13.4", "section_name": "Unintended Information Leakage", "req_id": "V13.4.3", "req_description": "Verify that web servers do not expose directory listings to clients unless explicitly intended.", "level": 2, "explanation": "This requirement ensures that web servers are configured to prevent the exposure of directory listings, which can reveal sensitive information about the structure and contents of the server's file system. When directory listings are enabled, attackers can easily discover files and directories that may contain sensitive data, leading to further exploitation.", "threats_mitigated": ["Information Disclosure", "Directory Traversal", "Unauthorized Access"], "insecure_examples": [{"code": "Directory listing is enabled on the web server, allowing users to view all files in a directory."}, {"code": "<Directory /var/www/html>\n    Options Indexes\n</Directory>"}], "secure_examples": [{"code": "Directory listing is disabled, preventing users from viewing files in a directory."}, {"code": "<Directory /var/www/html>\n    Options -Indexes\n</Directory>"}], "verification_steps": ["Check the web server configuration for directory listing settings.", "Attempt to access a directory without an index file to see if a listing is displayed.", "Review server documentation to confirm directory listing is disabled."], "common_mistakes": ["Leaving directory listing enabled during development or testing phases.", "Failing to review server configurations after deployment.", "Assuming that default settings are secure without verification."], "related_cwe": ["CWE-548: Exposure of Information Through Directory Listing", "CWE-200: Information Exposure"], "related_capec": ["CAPEC-124: Directory Traversal", "CAPEC-160: Directory Listing Attack"], "attack_flow": "An attacker discovers that directory listings are enabled on a web server. They navigate to a directory without an index file and are presented with a list of files and subdirectories. By analyzing this information, the attacker identifies sensitive files, such as configuration files or backups, which they can then attempt to download or exploit."}
{"chapter_id": "V13", "chapter_name": "Configuration", "section_id": "V13.4", "section_name": "Unintended Information Leakage", "req_id": "V13.4.4", "req_description": "Verify that using the HTTP TRACE method is not supported in production environments, to avoid potential information leakage.", "level": "2", "explanation": "The HTTP TRACE method is used for diagnostic purposes, allowing clients to see what is being received at the other end of the connection. However, if enabled in production, it can expose sensitive information such as headers, cookies, and other data that could be exploited by an attacker. Disabling this method helps to prevent unauthorized access to this information.", "threats_mitigated": ["Information Disclosure", "Cross-Site Tracing (XST)", "Session Hijacking"], "insecure_examples": [{"code_snippet": "HTTP/1.1 200 OK\nAllow: OPTIONS, TRACE\nContent-Type: message/http\n\nTRACE / HTTP/1.1\nHost: example.com\n"}], "secure_examples": [{"code_snippet": "HTTP/1.1 405 Method Not Allowed\nAllow: OPTIONS\n"}], "verification_steps": ["Check server configuration files for TRACE method support.", "Use tools like curl or Postman to send a TRACE request and verify the response.", "Review web server documentation to ensure TRACE is disabled."], "common_mistakes": ["Not reviewing server configurations after deployment.", "Assuming default settings disable TRACE without verification.", "Neglecting to test for TRACE support in staging environments."], "related_cwe": ["CWE-200", "CWE-201"], "related_capec": ["CAPEC-50", "CAPEC-139"], "attack_flow": "An attacker sends an HTTP TRACE request to the server. If the server responds with sensitive information, the attacker can use this information to craft further attacks, such as session hijacking or exploiting other vulnerabilities that rely on sensitive data."}
{"chapter_id": "V13", "chapter_name": "Configuration", "section_id": "V13.4", "section_name": "Unintended Information Leakage", "req_id": "V13.4.5", "req_description": "Verify that documentation (such as for internal APIs) and monitoring endpoints are not exposed unless explicitly intended.", "level": "2", "explanation": "This requirement emphasizes the importance of controlling access to sensitive documentation and monitoring endpoints. Internal APIs and documentation can contain sensitive information that, if exposed, can lead to security vulnerabilities. It is crucial to ensure that such resources are only accessible to authorized personnel and are not publicly available unless there is a specific intention to share them.", "threats_mitigated": ["Information Disclosure", "Unauthorized Access", "API Abuse", "Data Leakage"], "insecure_examples": [{"code": "GET /api/internal-docs\n// Exposes internal API documentation without authentication."}, {"code": "GET /monitoring/status\n// Monitoring endpoint is publicly accessible, revealing sensitive system information."}], "secure_examples": [{"code": "GET /api/internal-docs\n// Requires authentication and authorization to access internal API documentation."}, {"code": "GET /monitoring/status\n// Monitoring endpoint is secured and only accessible to authorized users."}], "verification_steps": ["Review API documentation access controls.", "Check for authentication mechanisms on monitoring endpoints.", "Ensure that no sensitive information is exposed in public documentation.", "Conduct a security review of the API and monitoring endpoints."], "common_mistakes": ["Failing to implement authentication for internal APIs.", "Leaving monitoring endpoints exposed to the public.", "Not reviewing documentation for sensitive information before deployment.", "Assuming that internal resources are safe without proper access controls."], "related_cwe": ["CWE-200", "CWE-201", "CWE-22", "CWE-284"], "related_capec": ["CAPEC-137", "CAPEC-135", "CAPEC-143"], "attack_flow": "An attacker discovers an exposed internal API or monitoring endpoint through reconnaissance. They then access the documentation or endpoint without authorization, potentially obtaining sensitive information about the system architecture, API functionality, or internal processes. This information can be leveraged to exploit vulnerabilities, escalate privileges, or conduct further attacks against the application."}
{"chapter_id": "V13", "chapter_name": "Configuration", "section_id": "V13.4", "section_name": "Unintended Information Leakage", "req_id": "V13.4.6", "req_description": "Verify that the application does not expose detailed version information of backend components.", "level": "3", "explanation": "This requirement ensures that applications do not disclose sensitive information about the versions of backend components, such as databases, frameworks, or libraries. Exposing this information can provide attackers with insights into potential vulnerabilities that may be present in those specific versions, enabling them to craft targeted attacks.", "threats_mitigated": ["Information Disclosure", "Version-specific Exploits", "Targeted Attacks"], "insecure_examples": [{"code_snippet": "HTTP/1.1 200 OK\r\nServer: Apache/2.4.41 (Ubuntu)\r\n"}, {"code_snippet": "<meta name=\"generator\" content=\"WordPress 5.8.1\" />"}], "secure_examples": [{"code_snippet": "HTTP/1.1 200 OK\r\nServer: MyCustomServer\r\n"}, {"code_snippet": "<meta name=\"generator\" content=\"MyApplication\" />"}], "verification_steps": ["Check HTTP response headers for version information.", "Review HTML source for meta tags revealing version details.", "Test for error messages that may disclose version information.", "Ensure server configurations do not expose version details."], "common_mistakes": ["Failing to configure server settings to hide version information.", "Leaving default application settings that expose version numbers.", "Not reviewing third-party libraries for version disclosure."], "related_cwe": ["CWE-200", "CWE-203", "CWE-326"], "related_capec": ["CAPEC-118", "CAPEC-139", "CAPEC-154"], "attack_flow": "An attacker discovers the version of a backend component through exposed headers or error messages. They then research known vulnerabilities for that specific version and exploit them to gain unauthorized access or control over the application."}
{"chapter_id": "V13", "chapter_name": "Configuration", "section_id": "V13.4", "section_name": "Unintended Information Leakage", "req_id": "V13.4.7", "req_description": "Verify that the web tier is configured to only serve files with specific file extensions to prevent unintentional information, configuration, and source code leakage.", "level": "3", "explanation": "This requirement emphasizes the importance of restricting the types of files that can be served by the web application. By limiting file extensions to only those that are necessary for the application to function, the risk of exposing sensitive files such as configuration files, source code, or other sensitive information is significantly reduced. Proper configuration ensures that only safe and expected content is delivered to users, thereby minimizing the attack surface.", "threats_mitigated": ["Information Disclosure", "Source Code Exposure", "Configuration File Leakage", "Unauthorized Access to Sensitive Files"], "insecure_examples": [{"code": "server { \n  location / {\n    root /var/www/html;\n  }\n}"}, {"code": "location / {\n  autoindex on;\n}"}], "secure_examples": [{"code": "server { \n  location / {\n    root /var/www/html;\n    location ~* \\.(html|css|js)$ {\n      allow all;\n      deny all;\n    }\n  }\n}"}, {"code": "location / {\n  autoindex off;\n  try_files $uri $uri/ =404;\n}"}], "verification_steps": ["Review the web server configuration files for allowed file extensions.", "Check for any misconfigured locations that may expose sensitive files.", "Test access to various file types to ensure only permitted extensions are served.", "Verify that directory listing is disabled."], "common_mistakes": ["Allowing overly broad file extensions.", "Failing to disable directory browsing.", "Not validating file types in upload functionality.", "Misconfiguring web server rules leading to unintended access."], "related_cwe": ["CWE-200", "CWE-22", "CWE-548"], "related_capec": ["CAPEC-28", "CAPEC-40", "CAPEC-135"], "attack_flow": "An attacker may exploit a misconfigured web server by attempting to access files with sensitive extensions (e.g., .env, .config, .php) that should not be served. If the server allows these file types, the attacker can download sensitive information, leading to a potential compromise of the application and its underlying infrastructure."}
{"chapter_id": "V14", "chapter_name": "Data Protection", "section_id": "V14.1", "section_name": "Data Protection Documentation", "req_id": "V14.1.1", "req_description": "Verify that all sensitive data created and processed by the application has been identified and classified into protection levels. This includes data that is only encoded and therefore easily decoded, such as Base64 strings or the plaintext payload inside a JWT. Protection levels need to take into account any data protection and privacy regulations and standards which the application is required to comply with.", "level": "2", "explanation": "This requirement emphasizes the importance of identifying and classifying sensitive data within an application. Sensitive data includes any information that, if disclosed, could lead to harm or privacy violations. The classification process should consider various protection levels based on the sensitivity of the data and the applicable legal and regulatory frameworks. This ensures that appropriate security controls are implemented to protect the data adequately.", "threats_mitigated": ["Data Breach", "Unauthorized Access", "Data Leakage", "Compliance Violations"], "insecure_examples": ["String sensitiveData = \"Base64EncodedData\"; // Sensitive data is not classified or protected properly", "String jwtPayload = \"{ 'user': 'admin', 'role': 'admin' }\"; // Plaintext JWT payload without classification"], "secure_examples": ["String sensitiveData = classifyData(\"Base64EncodedData\", ProtectionLevel.HIGH); // Properly classifying sensitive data", "String jwtPayload = classifyData(\"{ 'user': 'admin', 'role': 'admin' }\", ProtectionLevel.HIGH); // Classifying JWT payload as sensitive"], "verification_steps": ["Review the data processing flows to identify all instances of sensitive data.", "Check that sensitive data is classified according to established protection levels.", "Ensure that encoding methods (e.g., Base64) are recognized as insufficient for protection.", "Verify compliance with relevant data protection regulations and standards."], "common_mistakes": ["Failing to identify all sensitive data types.", "Assuming that encoded data does not require classification.", "Neglecting to update data classification as new data types are introduced.", "Not considering the legal implications of data classification."], "related_cwe": ["CWE-200", "CWE-22", "CWE-307"], "related_capec": ["CAPEC-137", "CAPEC-114"], "attack_flow": "An attacker may exploit the lack of proper classification by targeting sensitive data that has not been adequately protected. For instance, if sensitive data such as passwords or personal information is only encoded and not classified, an attacker could decode this data easily, leading to unauthorized access or data breaches. Additionally, failure to comply with regulations may result in legal consequences."}
{"chapter_id": "V14", "chapter_name": "Data Protection", "section_id": "V14.1", "section_name": "Data Protection Documentation", "req_id": "V14.1.2", "req_description": "Verify that all sensitive data protection levels have a documented set of protection requirements. This must include (but not be limited to) requirements related to general encryption, integrity verification, retention, how the data is to be logged, access controls around sensitive data in logs, database-level encryption, privacy and privacy-enhancing technologies to be used, and other confidentiality requirements.", "level": "2", "explanation": "This requirement emphasizes the necessity of having a comprehensive documentation that outlines the protection mechanisms for sensitive data. It ensures that all aspects of data protection are considered and formally recorded, which helps in maintaining compliance and guiding development practices. This documentation should cover various aspects, including encryption methods, data integrity checks, data retention policies, logging practices, access controls, and the use of privacy-enhancing technologies.", "threats_mitigated": ["Data breaches", "Unauthorized access to sensitive data", "Data tampering", "Data loss", "Insufficient data handling practices"], "insecure_examples": ["const sensitiveData = 'password123'; // Sensitive data stored in plaintext without any protection", "console.log(sensitiveData); // Logging sensitive data to console without any access controls"], "secure_examples": ["const sensitiveData = encrypt('password123'); // Sensitive data stored using encryption", "logger.info('User accessed sensitive data'); // Logging access events with appropriate access controls"], "verification_steps": ["Check for documentation outlining data protection requirements.", "Verify that encryption methods for sensitive data are documented.", "Ensure that integrity verification processes are included.", "Review data retention policies for compliance.", "Check access controls around sensitive data in logs.", "Confirm that database-level encryption is documented.", "Look for documentation on privacy-enhancing technologies."], "common_mistakes": ["Failing to document all protection mechanisms.", "Using vague language in documentation.", "Not updating documentation to reflect changes in data protection practices.", "Omitting critical aspects such as access controls and logging practices."], "related_cwe": ["CWE-200", "CWE-22", "CWE-276"], "related_capec": ["CAPEC-137", "CAPEC-145", "CAPEC-155"], "attack_flow": "An attacker may exploit the lack of documentation by identifying weaknesses in data protection practices. Without clear guidelines, developers might implement inadequate encryption or fail to enforce access controls, leading to unauthorized access or data breaches. Additionally, if sensitive data is logged without proper protection, attackers could gain insights into the data handling practices and exploit them."}
{"chapter_id": "V14", "chapter_name": "Data Protection", "section_id": "V14.2", "section_name": "General Data Protection", "req_id": "V14.2.1", "req_description": "Verify that sensitive data is only sent to the server in the HTTP message body or header fields, and that the URL and query string do not contain sensitive information, such as an API key or session token.", "level": "1", "explanation": "This requirement ensures that sensitive information is not exposed in URLs, which can be logged in various places (like server logs, browser history, etc.) and can be easily intercepted. It emphasizes the importance of keeping sensitive data within the HTTP message body or headers, where it is less likely to be exposed.", "threats_mitigated": ["Sensitive data exposure", "Man-in-the-middle attacks", "Information leakage through logs"], "insecure_examples": ["GET /api/user?api_key=12345&session_token=abcde", "GET /login?username=user&password=pass"], "secure_examples": ["POST /api/user HTTP/1.1\nContent-Type: application/json\n\n{\"api_key\":\"12345\",\"session_token\":\"abcde\"}", "POST /login HTTP/1.1\nContent-Type: application/x-www-form-urlencoded\n\nusername=user&password=pass"], "verification_steps": ["Review code for data transmission methods (GET vs POST).", "Check that sensitive data is included in the body or headers, not in the URL.", "Examine server logs to ensure no sensitive data is logged.", "Test API endpoints to confirm that sensitive data cannot be accessed via URL parameters."], "common_mistakes": ["Using GET requests to send sensitive data.", "Not validating or sanitizing input data before processing.", "Assuming that URL parameters are secure."], "related_cwe": ["CWE-200", "CWE-201", "CWE-22"], "related_capec": ["CAPEC-137", "CAPEC-145"], "attack_flow": "An attacker can intercept network traffic and capture URLs that contain sensitive data. If sensitive information such as API keys or session tokens is included in the URL, it can be easily extracted and used for unauthorized access to the system."}
{"chapter_id": "V14", "chapter_name": "Data Protection", "section_id": "V14.2", "section_name": "General Data Protection", "req_id": "V14.2.2", "req_description": "Verify that the application prevents sensitive data from being cached in server components, such as load balancers and application caches, or ensures that the data is securely purged after use.", "level": "2", "explanation": "This requirement ensures that sensitive data, such as personal information or credentials, is not inadvertently stored in temporary storage mechanisms like caches or load balancers. If sensitive data is cached, it can be exposed to unauthorized access, especially if the cache is not properly secured or purged. The application must implement measures to either prevent caching of sensitive data or ensure that any cached data is securely deleted after it is no longer needed.", "threats_mitigated": ["Data leakage", "Unauthorized access to sensitive data", "Cache poisoning attacks"], "insecure_examples": [{"code": "cache.set('user_data', sensitiveData); // Caching sensitive data without restrictions"}, {"code": "response.setHeader('Cache-Control', 'public, max-age=3600'); // Allowing sensitive data to be cached publicly"}], "secure_examples": [{"code": "cache.set('user_data', sensitiveData, { secure: true, ttl: 0 }); // Prevent caching of sensitive data"}, {"code": "response.setHeader('Cache-Control', 'no-store'); // Prevent caching of sensitive data"}], "verification_steps": ["Review caching mechanisms in the application.", "Check headers related to caching (e.g., Cache-Control, Pragma).", "Ensure sensitive data is not stored in caches.", "Verify that any cached sensitive data is purged securely after use."], "common_mistakes": ["Assuming that caching is safe for all types of data.", "Not setting appropriate cache headers for responses containing sensitive data.", "Failing to purge cached sensitive data after its use."], "related_cwe": ["CWE-200", "CWE-16"], "related_capec": ["CAPEC-137", "CAPEC-139"], "attack_flow": "An attacker could exploit the caching of sensitive data by accessing the cache storage directly or through a misconfigured load balancer. If sensitive data is cached without proper controls, the attacker could retrieve this data, leading to unauthorized access to personal information or credentials."}
{"chapter_id": "V14", "chapter_name": "Data Protection", "section_id": "V14.2", "section_name": "General Data Protection", "req_id": "V14.2.3", "req_description": "Verify that defined sensitive data is not sent to untrusted parties (e.g., user trackers) to prevent unwanted collection of data outside of the application's control.", "level": "2", "explanation": "This requirement emphasizes the importance of ensuring that sensitive data, such as personally identifiable information (PII), financial information, or health records, is not transmitted to third-party services that are not trusted. This includes avoiding sending data to analytics services, advertising networks, or any external service that could misuse or mishandle the data. Developers must implement controls to ensure that sensitive data is only sent to trusted and authorized entities.", "threats_mitigated": ["Data Leakage", "Privacy Violations", "Unauthorized Data Collection", "Malware and Tracking Exploits"], "insecure_examples": [{"code": "fetch('https://untrusted-tracker.com/api/data', { method: 'POST', body: JSON.stringify(userData) });"}, {"code": "const sensitiveData = { email: user.email, creditCard: user.cardNumber }; sendDataToUntrustedService(sensitiveData);"}], "secure_examples": [{"code": "if (isTrustedService('https://trusted-service.com')) { fetch('https://trusted-service.com/api/data', { method: 'POST', body: JSON.stringify(userData) }); }"}, {"code": "const safeData = { email: user.email }; sendDataToTrustedService(safeData);"}], "verification_steps": ["Review the data flow to identify all instances where sensitive data is sent.", "Ensure that data is only sent to services that have been vetted and approved.", "Check for any hardcoded URLs or endpoints that may point to untrusted services.", "Validate that sensitive data is not included in analytics or tracking scripts."], "common_mistakes": ["Failing to review third-party libraries for data handling practices.", "Hardcoding sensitive data in client-side code.", "Assuming that all external services are trustworthy without proper vetting."], "related_cwe": ["CWE-200", "CWE-201", "CWE-312"], "related_capec": ["CAPEC-112", "CAPEC-137"], "attack_flow": "An attacker could exploit this requirement by injecting malicious scripts or using browser extensions to capture sensitive data that is sent to untrusted third-party services. If sensitive data is transmitted without proper validation, it could be intercepted and misused, leading to identity theft or financial fraud."}
{"chapter_id": "V14", "chapter_name": "Data Protection", "section_id": "V14.2", "section_name": "General Data Protection", "req_id": "V14.2.4", "req_description": "Verify that controls around sensitive data related to encryption, integrity verification, retention, how the data is to be logged, access controls around sensitive data in logs, privacy and privacy-enhancing technologies, are implemented as defined in the documentation for the specific data's protection level.", "level": "2", "explanation": "This requirement emphasizes the need for comprehensive controls to protect sensitive data throughout its lifecycle. It mandates that organizations implement encryption for data at rest and in transit, ensure integrity verification mechanisms are in place, establish data retention policies, and enforce strict access controls for sensitive data in logs. Additionally, it highlights the importance of adhering to privacy regulations and employing privacy-enhancing technologies to safeguard user information.", "threats_mitigated": ["Data breaches", "Unauthorized access to sensitive data", "Data tampering", "Insider threats", "Compliance violations"], "insecure_examples": ["const sensitiveData = '1234-5678-9012-3456';\nconsole.log(sensitiveData); // Logging sensitive data without protection", "let userData = { username: 'user', password: 'password123' }; // Storing sensitive data in plain text"], "secure_examples": ["const sensitiveData = '1234-5678-9012-3456';\nconsole.log('Sensitive data is not logged'); // Avoid logging sensitive data", "let userData = { username: 'user', password: encrypt('password123') }; // Storing sensitive data securely"], "verification_steps": ["Review the data protection documentation for compliance with encryption standards.", "Check that sensitive data is encrypted both at rest and in transit.", "Verify that integrity verification mechanisms are implemented.", "Evaluate data retention policies to ensure compliance with legal requirements.", "Inspect access controls for logs containing sensitive data."], "common_mistakes": ["Failing to encrypt sensitive data both at rest and in transit.", "Not implementing integrity checks for sensitive data.", "Inadequate logging practices that expose sensitive information.", "Ignoring privacy regulations and best practices."], "related_cwe": ["CWE-200: Information Exposure", "CWE-276: Incorrect Default Permissions", "CWE-307: Improper Restriction of Excessive Authentication Attempts"], "related_capec": ["CAPEC-139: Data Manipulation", "CAPEC-156: Data Breach", "CAPEC-182: Logging Sensitive Information"], "attack_flow": "An attacker may exploit inadequate controls around sensitive data by intercepting unencrypted data during transmission or accessing logs that contain sensitive information. They could manipulate data if integrity checks are not in place, leading to unauthorized access or data breaches. By exploiting these weaknesses, attackers can compromise user privacy and gain unauthorized access to sensitive information."}
{"chapter_id": "V14", "chapter_name": "Data Protection", "section_id": "V14.2", "section_name": "General Data Protection", "req_id": "V14.2.5", "req_description": "Verify that caching mechanisms are configured to only cache responses which have the expected content type for that resource and do not contain sensitive, dynamic content. The web server should return a 404 or 302 response when a non-existent file is accessed rather than returning a different, valid file. This should prevent Web Cache Deception attacks.", "level": "3", "explanation": "This requirement emphasizes the importance of correctly configuring caching mechanisms to ensure that only appropriate responses are cached. By restricting caching to responses with expected content types and avoiding the caching of sensitive or dynamic content, applications can mitigate the risk of exposing sensitive information through cached responses. Additionally, proper handling of non-existent files helps prevent attackers from leveraging cached content to access unauthorized data.", "threats_mitigated": ["Web Cache Deception", "Sensitive Data Exposure", "Information Leakage"], "insecure_examples": [{"code_snippet": "response.setHeader('Cache-Control', 'public'); // Caches sensitive user data"}, {"code_snippet": "if (!fileExists(requestedFile)) { return getFile(validFile); } // Returns valid file instead of 404"}], "secure_examples": [{"code_snippet": "response.setHeader('Cache-Control', 'no-store'); // Prevents caching of sensitive data"}, {"code_snippet": "if (!fileExists(requestedFile)) { return response.sendStatus(404); } // Properly returns 404 for non-existent files"}], "verification_steps": ["Check that caching headers are set correctly for all responses.", "Ensure that sensitive data is not included in cached responses.", "Verify that the application returns 404 or 302 for non-existent files instead of valid content.", "Review the content types being cached to ensure they match expected types."], "common_mistakes": ["Caching sensitive data without proper restrictions.", "Returning valid files for non-existent resources instead of appropriate error codes.", "Failing to set appropriate cache control headers."], "related_cwe": ["CWE-16", "CWE-200", "CWE-117"], "related_capec": ["CAPEC-139", "CAPEC-138"], "attack_flow": "An attacker may attempt to access a non-existent resource and, if the application improperly returns a valid file instead of a 404 response, they could exploit the cache to retrieve sensitive information that was not intended to be exposed. This can lead to unauthorized access to sensitive data, as the attacker can manipulate the cache to serve malicious content or gain insights into the application's structure."}
{"chapter_id": "V14", "chapter_name": "Data Protection", "section_id": "V14.2", "section_name": "General Data Protection", "req_id": "V14.2.6", "req_description": "Verify that the application only returns the minimum required sensitive data for the application's functionality. For example, only returning some of the digits of a credit card number and not the full number. If the complete data is required, it should be masked in the user interface unless the user specifically views it.", "level": "3", "explanation": "This requirement ensures that applications do not expose more sensitive data than necessary, thereby reducing the risk of data leakage. By limiting the amount of sensitive information returned, the application minimizes the potential impact of data breaches and unauthorized access. Masking sensitive data in the user interface further protects it from being viewed by unauthorized users.", "threats_mitigated": ["Data leakage", "Unauthorized data access", "Information disclosure"], "insecure_examples": [{"code": "return user.credit_card_number;"}, {"code": "return user.ssn;"}], "secure_examples": [{"code": "return user.credit_card_number.substring(0, 4) + '****';"}, {"code": "return '***-**-' + user.ssn.substring(7);"}], "verification_steps": ["Review code to ensure sensitive data is not returned in full.", "Check that data returned is limited to the minimum necessary for functionality.", "Verify that sensitive data is masked in the user interface.", "Test for unauthorized access to sensitive data."], "common_mistakes": ["Returning full sensitive data without any masking.", "Failing to limit data returned based on user roles or permissions.", "Not implementing data masking in user interfaces."], "related_cwe": ["CWE-200", "CWE-209", "CWE-22"], "related_capec": ["CAPEC-137", "CAPEC-140"], "attack_flow": "An attacker may exploit this requirement by intercepting API responses or accessing user interfaces that display sensitive data. If the application returns full sensitive data (like credit card numbers or social security numbers), the attacker can use this information for identity theft, financial fraud, or other malicious activities."}
{"chapter_id": "V14", "chapter_name": "Data Protection", "section_id": "V14.2", "section_name": "General Data Protection", "req_id": "V14.2.7", "req_description": "Verify that sensitive information is subject to data retention classification, ensuring that outdated or unnecessary data is deleted automatically, on a defined schedule, or as the situation requires.", "level": "3", "explanation": "This requirement mandates that organizations implement a data retention policy that classifies sensitive information based on its necessity and relevance. It requires that data is not kept longer than necessary, which helps in minimizing the risk of data breaches and ensuring compliance with legal and regulatory obligations.", "threats_mitigated": ["Data breaches due to excessive data retention", "Unauthorized access to outdated sensitive information", "Compliance violations leading to legal penalties"], "insecure_examples": [{"code_snippet": "SELECT * FROM sensitive_data WHERE created_at < '2020-01-01'; -- Data not deleted"}, {"code_snippet": "INSERT INTO sensitive_data (data, created_at) VALUES ('sensitive_info', NOW()); -- No retention policy applied"}], "secure_examples": [{"code_snippet": "DELETE FROM sensitive_data WHERE created_at < DATE_SUB(NOW(), INTERVAL 1 YEAR); -- Data older than 1 year is deleted"}, {"code_snippet": "CREATE TRIGGER delete_old_data AFTER INSERT ON sensitive_data FOR EACH ROW BEGIN DELETE FROM sensitive_data WHERE created_at < DATE_SUB(NOW(), INTERVAL 1 YEAR); END;"}], "verification_steps": ["Review the data retention policy documentation.", "Check for automated processes that delete outdated sensitive data.", "Verify that data classification is applied to sensitive information.", "Assess compliance with legal and regulatory requirements regarding data retention."], "common_mistakes": ["Failing to classify sensitive data properly.", "Not implementing automated deletion processes.", "Retaining data longer than necessary due to lack of oversight."], "related_cwe": ["CWE-20", "CWE-22", "CWE-200"], "related_capec": ["CAPEC-138", "CAPEC-152"], "attack_flow": "An attacker may exploit the lack of a data retention policy by accessing outdated sensitive information that should have been deleted. This could lead to unauthorized access to personal data, which can be used for identity theft, fraud, or other malicious activities."}
{"chapter_id": "V14", "chapter_name": "Data Protection", "section_id": "V14.2", "section_name": "General Data Protection", "req_id": "V14.2.8", "req_description": "Verify that sensitive information is removed from the metadata of user-submitted files unless storage is consented to by the user.", "level": "3", "explanation": "This requirement mandates that any sensitive information contained within the metadata of files uploaded by users must be stripped away to protect user privacy. If the application intends to retain any of this metadata, explicit consent must be obtained from the user beforehand. This includes information such as author names, timestamps, and other personal identifiers that could be extracted from the file's metadata.", "threats_mitigated": ["Data leakage", "Privacy violations", "Unauthorized access to sensitive information"], "insecure_examples": ["file.save(user_uploaded_file); // Metadata is not sanitized", "user_file = request.files['file']; process_file(user_file); // Sensitive metadata retained"], "secure_examples": ["sanitized_file = sanitize_metadata(user_uploaded_file); file.save(sanitized_file); // Metadata sanitized before saving", "user_file = request.files['file']; sanitized_file = sanitize_metadata(user_file); process_file(sanitized_file); // Metadata removed"], "verification_steps": ["Check if the application sanitizes metadata from user-uploaded files.", "Review the code handling file uploads for any metadata storage.", "Ensure user consent is obtained before storing any sensitive metadata.", "Test with various file types to confirm metadata is consistently removed."], "common_mistakes": ["Assuming all metadata is non-sensitive and can be stored.", "Failing to implement a consistent metadata sanitization process.", "Not providing users with clear options regarding metadata storage."], "related_cwe": ["CWE-200", "CWE-201", "CWE-532"], "related_capec": ["CAPEC-137", "CAPEC-155"], "attack_flow": "An attacker uploads a file containing sensitive metadata. If the application fails to sanitize this metadata, the attacker can extract personal information about the user, leading to potential identity theft or targeted attacks. If consent was not obtained, this could also lead to legal repercussions for the application owner."}
{"chapter_id": "V14", "chapter_name": "Data Protection", "section_id": "V14.3", "section_name": "Client-side Data Protection", "req_id": "V14.3.1", "req_description": "Verify that authenticated data is cleared from client storage, such as the browser DOM, after the client or session is terminated. The 'Clear-Site-Data' HTTP response header field may be able to help with this but the client-side should also be able to clear up if the server connection is not available when the session is terminated.", "level": "1", "explanation": "This requirement emphasizes the importance of clearing sensitive data from client-side storage to prevent unauthorized access after a user session ends. This includes data stored in cookies, local storage, session storage, and the browser DOM. Proper implementation ensures that even if a user closes the browser or navigates away from the application, sensitive information is not left accessible.", "threats_mitigated": ["Session hijacking", "Cross-site scripting (XSS)", "Data leakage"], "insecure_examples": ["localStorage.setItem('userData', JSON.stringify(userData)); // Sensitive data stored without clearing", "sessionStorage.setItem('authToken', token); // Token not cleared on session termination"], "secure_examples": ["localStorage.removeItem('userData'); // Clear sensitive data on session end", "sessionStorage.clear(); // Clear all session storage on logout"], "verification_steps": ["Check if sensitive data is stored in local storage or session storage.", "Verify that data is cleared upon logout or session termination.", "Inspect HTTP response headers for 'Clear-Site-Data' usage.", "Test the application by terminating the session and checking for residual data."], "common_mistakes": ["Failing to clear data from local/session storage upon logout.", "Not implementing 'Clear-Site-Data' header in HTTP responses.", "Assuming data is automatically cleared when the browser is closed."], "related_cwe": ["CWE-200", "CWE-201", "CWE-22"], "related_capec": ["CAPEC-137", "CAPEC-151"], "attack_flow": "An attacker exploits this requirement by gaining access to a user's browser session. If sensitive data remains in local or session storage after logout, the attacker can retrieve this data and impersonate the user, leading to unauthorized actions or data breaches."}
{"chapter_id": "V14", "chapter_name": "Data Protection", "section_id": "V14.3", "section_name": "Client-side Data Protection", "req_id": "V14.3.2", "req_description": "Verify that the application sets sufficient anti-caching HTTP response header fields (i.e., Cache-Control: no-store) so that sensitive data is not cached in browsers.", "level": "2", "explanation": "This requirement ensures that sensitive data, such as personal information or authentication tokens, are not stored in the browser cache. By setting the appropriate HTTP response headers, the application instructs the browser not to cache the response, thereby reducing the risk of unauthorized access to sensitive information through cached data.", "threats_mitigated": ["Sensitive data exposure through browser cache", "Cross-site scripting (XSS) attacks leveraging cached data", "Unauthorized access to sensitive information"], "insecure_examples": [{"code": "HTTP/1.1 200 OK\nContent-Type: application/json\n\n{\"token\":\"abc123\"}"}, {"code": "HTTP/1.1 200 OK\nContent-Type: text/html\n\n<html><body>...</body></html>"}], "secure_examples": [{"code": "HTTP/1.1 200 OK\nContent-Type: application/json\nCache-Control: no-store\n\n{\"token\":\"abc123\"}"}, {"code": "HTTP/1.1 200 OK\nContent-Type: text/html\nCache-Control: no-store\n\n<html><body>...</body></html>"}], "verification_steps": ["Check the HTTP response headers for the presence of Cache-Control.", "Verify that Cache-Control is set to 'no-store' for responses containing sensitive data.", "Review the application code to ensure that anti-caching headers are consistently applied."], "common_mistakes": ["Failing to set Cache-Control headers on all endpoints that return sensitive data.", "Using improper values for Cache-Control, such as 'public' or 'max-age'.", "Assuming that sensitive data is automatically protected by default browser settings."], "related_cwe": ["CWE-200", "CWE-16", "CWE-524"], "related_capec": ["CAPEC-139", "CAPEC-137"], "attack_flow": "An attacker could exploit the absence of anti-caching headers by accessing a shared or public computer where the browser has cached sensitive data. If the attacker gains access to the browser, they can retrieve this cached data, leading to unauthorized access to sensitive information such as authentication tokens or personal details."}
{"chapter_id": "V14", "chapter_name": "Data Protection", "section_id": "V14.3", "section_name": "Client-side Data Protection", "req_id": "V14.3.3", "req_description": "Verify that data stored in browser storage (such as localStorage, sessionStorage, IndexedDB, or cookies) does not contain sensitive data, with the exception of session tokens.", "level": 2, "explanation": "This requirement emphasizes the importance of not storing sensitive information in client-side storage mechanisms. Sensitive data can include personally identifiable information (PII), authentication credentials, or any data that could compromise user privacy or security if accessed by unauthorized parties. The only exception to this rule is session tokens, which are necessary for maintaining user sessions in a secure manner.", "threats_mitigated": ["Data theft via XSS attacks", "Session hijacking", "Unauthorized access to sensitive information"], "insecure_examples": ["localStorage.setItem('userPassword', 'mySecretPassword');", "sessionStorage.setItem('userSSN', '123-45-6789');"], "secure_examples": ["sessionStorage.setItem('sessionToken', 'abc123xyz');", "localStorage.setItem('themePreference', 'darkMode');"], "verification_steps": ["Review all client-side storage implementations.", "Check for any sensitive data being stored in localStorage, sessionStorage, IndexedDB, or cookies.", "Ensure that only session tokens are stored in these storage mechanisms.", "Confirm that sensitive data is handled appropriately on the server-side."], "common_mistakes": ["Developers often store user credentials or sensitive information in localStorage.", "Failing to sanitize or validate data before storing it in client-side storage.", "Assuming that data stored in client-side storage is secure without proper encryption."], "related_cwe": ["CWE-200: Information Exposure", "CWE-201: Exposure of Sensitive Information to an Unauthorized Actor", "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"], "related_capec": ["CAPEC-137: Session Fixation", "CAPEC-138: Session Hijacking", "CAPEC-151: Cross-Site Scripting (XSS)"], "attack_flow": "An attacker may exploit vulnerabilities such as Cross-Site Scripting (XSS) to inject malicious scripts into a web application. If sensitive data is stored in client-side storage, the attacker can access this data through the injected script, leading to unauthorized access to user accounts or sensitive information. By ensuring that sensitive data is not stored in these storage mechanisms, the application reduces the risk of such attacks."}
{"chapter_id": "V15", "chapter_name": "Secure Coding and Architecture", "section_id": "V15.1", "section_name": "Secure Coding and Architecture Documentation", "req_id": "V15.1.1", "req_description": "Verify that application documentation defines risk based remediation time frames for 3rd party component versions with vulnerabilities and for updating libraries in general, to minimize the risk from these components.", "level": "1", "explanation": "This requirement emphasizes the importance of having clear documentation regarding how quickly vulnerabilities in third-party components should be addressed. It ensures that development teams have a defined timeline for remediation based on the severity of the vulnerabilities, which helps in managing risks associated with outdated or vulnerable libraries.", "threats_mitigated": ["Exploitation of known vulnerabilities in third-party components", "Supply chain attacks", "Data breaches due to outdated libraries"], "insecure_examples": [{"code_snippet": "// Documentation lacks any mention of remediation timelines\n// No defined process for updating libraries\n"}, {"code_snippet": "// Updating libraries is done sporadically without a schedule\n// No risk assessment is performed on third-party components\n"}], "secure_examples": [{"code_snippet": "// Documentation includes a clear timeline for remediation based on risk levels\n// Example: Critical vulnerabilities must be addressed within 1 week\n"}, {"code_snippet": "// Regular updates scheduled quarterly for all third-party libraries\n// Risk assessments conducted before any library update\n"}], "verification_steps": ["Review application documentation for remediation timelines.", "Check if timelines are based on the risk level of vulnerabilities.", "Ensure that there is a defined process for updating third-party components.", "Verify that the documentation is regularly updated and maintained."], "common_mistakes": ["Failing to document remediation timelines for vulnerabilities.", "Not prioritizing updates based on the severity of vulnerabilities.", "Neglecting to review and update documentation regularly."], "related_cwe": ["CWE-1104", "CWE-20", "CWE-22"], "related_capec": ["CAPEC-118", "CAPEC-174"], "attack_flow": "An attacker identifies a vulnerable third-party component in the application. If the documentation does not specify a timely remediation process, the attacker can exploit the vulnerability, potentially leading to unauthorized access, data leakage, or system compromise."}
{"chapter_id": "V15", "chapter_name": "Secure Coding and Architecture", "section_id": "V15.1", "section_name": "Secure Coding and Architecture Documentation", "req_id": "V15.1.2", "req_description": "Verify that an inventory catalog, such as software bill of materials (SBOM), is maintained of all third-party libraries in use, including verifying that components come from pre-defined, trusted, and continually maintained repositories.", "level": 2, "explanation": "This requirement emphasizes the importance of maintaining a comprehensive inventory of all third-party libraries used in the application. This inventory should include details about the source of each library, ensuring that they are obtained from trusted and secure repositories. Regular updates and reviews of this inventory help in identifying vulnerabilities and ensuring compliance with security policies.", "threats_mitigated": ["Use of vulnerable components", "Supply chain attacks", "Malicious code injection through third-party libraries"], "insecure_examples": [{"code": "import requests  # Using a third-party library without verification"}, {"code": "dependencies: [ 'http://untrusted-source.com/library.js' ]  # Including libraries from untrusted sources"}], "secure_examples": [{"code": "import requests  # Ensure requests library is from a trusted repository"}, {"code": "dependencies: [ 'https://trusted-repo.com/library.js' ]  # Including libraries from trusted sources"}], "verification_steps": ["Check the existence of an SBOM for the application.", "Verify that all listed libraries are from trusted sources.", "Ensure that the SBOM is regularly updated and reviewed.", "Confirm that there are processes in place for monitoring vulnerabilities in third-party libraries."], "common_mistakes": ["Failing to update the inventory after adding new libraries.", "Using libraries from unknown or unverified sources.", "Neglecting to review the SBOM regularly for vulnerabilities."], "related_cwe": ["CWE-1104", "CWE-1236", "CWE-400"], "related_capec": ["CAPEC-138", "CAPEC-156"], "attack_flow": "An attacker may exploit vulnerabilities in third-party libraries if they are not properly vetted. By using libraries from untrusted sources, the attacker can inject malicious code or exploit known vulnerabilities, leading to unauthorized access, data breaches, or system compromise."}
{"chapter_id": "V15", "chapter_name": "Secure Coding and Architecture", "section_id": "V15.1", "section_name": "Secure Coding and Architecture Documentation", "req_id": "V15.1.3", "req_description": "Verify that the application documentation identifies functionality which is time-consuming or resource-demanding. This must include how to prevent a loss of availability due to overusing this functionality and how to avoid a situation where building a response takes longer than the consumer's timeout. Potential defenses may include asynchronous processing, using queues, and limiting parallel processes per user and per application.", "level": "2", "explanation": "This requirement emphasizes the importance of documenting any application features that are resource-intensive or time-consuming. Proper documentation helps developers and operators understand the potential impact of these features on system performance and availability. It also guides them in implementing strategies to mitigate risks associated with excessive resource consumption, such as using asynchronous processing to handle requests without blocking, employing queues to manage workload, and restricting the number of concurrent processes to ensure system stability.", "threats_mitigated": ["Denial of Service (DoS)", "Resource Exhaustion", "Timeout-related vulnerabilities"], "insecure_examples": ["function processRequest(request) { /* long processing logic */ }", "app.post('/data', (req, res) => { heavyComputation(); res.send('done'); });"], "secure_examples": ["function processRequest(request) { asyncProcess(request); }", "app.post('/data', (req, res) => { queueRequest(req); res.send('request queued'); });"], "verification_steps": ["Check if documentation includes sections on resource-intensive functionalities.", "Ensure that mitigation strategies for resource management are documented.", "Review the application code to confirm that documented strategies are implemented."], "common_mistakes": ["Failing to document resource-intensive functionalities.", "Not implementing the documented mitigation strategies.", "Assuming default configurations are sufficient for handling resource demands."], "related_cwe": ["CWE-400", "CWE-770", "CWE-754"], "related_capec": ["CAPEC-137", "CAPEC-148"], "attack_flow": "An attacker may exploit resource-intensive functionalities by sending numerous requests or specially crafted inputs that trigger heavy processing. If the application does not properly manage these requests, it can lead to resource exhaustion, causing legitimate users to experience delays or denial of service. Proper documentation and adherence to mitigation strategies can help prevent such exploitation."}
{"chapter_id": "V15", "chapter_name": "Secure Coding and Architecture", "section_id": "V15.1", "section_name": "Secure Coding and Architecture Documentation", "req_id": "V15.1.4", "req_description": "Verify that application documentation highlights third-party libraries which are considered to be 'risky components'.", "level": "3", "explanation": "This requirement emphasizes the importance of maintaining clear documentation regarding third-party libraries used in the application. It requires developers to identify and document any libraries that may pose security risks, such as those with known vulnerabilities, poor maintenance records, or lack of community support. This transparency helps in assessing the risk associated with these components and aids in making informed decisions about their usage.", "threats_mitigated": ["Supply Chain Attacks", "Exploitation of Known Vulnerabilities", "Dependency Confusion", "Malicious Code Injection"], "insecure_examples": [{"code_snippet": "// Incomplete documentation of third-party libraries\n// No mention of potential risks\nimport riskyLibrary from 'risky-library';"}, {"code_snippet": "// Documentation does not specify versions or vulnerabilities\nconst library = require('old-library'); // Version with known vulnerabilities"}], "secure_examples": [{"code_snippet": "// Proper documentation highlighting risks\n// 'risky-library' has known vulnerabilities, use with caution\nimport riskyLibrary from 'risky-library'; // Documented in README.md"}, {"code_snippet": "// Documentation specifies safe versions and risks\nconst library = require('safe-library@1.2.3'); // No known vulnerabilities"}], "verification_steps": ["Review application documentation for third-party libraries.", "Check if risky components are identified and documented.", "Ensure documentation includes version numbers and known vulnerabilities.", "Verify that there are mitigation strategies for risky components."], "common_mistakes": ["Failing to document third-party libraries.", "Ignoring updates and vulnerabilities of used libraries.", "Using libraries without assessing their security posture.", "Not specifying the version of third-party components."], "related_cwe": ["CWE-1104", "CWE-937", "CWE-1236"], "related_capec": ["CAPEC-147", "CAPEC-152", "CAPEC-158"], "attack_flow": "An attacker identifies a vulnerable third-party library used in the application. If the library is not documented as risky, developers may unknowingly use it, leading to exploitation. The attacker can leverage known vulnerabilities to execute malicious code, gain unauthorized access, or manipulate application behavior."}
{"chapter_id": "V15", "chapter_name": "Secure Coding and Architecture", "section_id": "V15.1", "section_name": "Secure Coding and Architecture Documentation", "req_id": "V15.1.5", "req_description": "Verify that application documentation highlights parts of the application where 'dangerous functionality' is being used.", "level": "3", "explanation": "This requirement emphasizes the importance of documenting areas within the application that utilize potentially risky functionalities, such as direct database access, file uploads, or system commands. Proper documentation helps developers and security teams to be aware of these areas, ensuring that they are reviewed and secured appropriately.", "threats_mitigated": ["Unauthorized access", "Data leakage", "Code injection", "Privilege escalation"], "insecure_examples": ["// Insecure example: No documentation of dangerous functionality\nfunction executeCommand(command) {\n    // Executes a command without validation\n    system(command);\n}", "// Insecure example: File upload without highlighting risks\napp.post('/upload', (req, res) => {\n    const file = req.files.uploadedFile;\n    file.mv('/uploads/' + file.name);\n});"], "secure_examples": ["// Secure example: Documenting dangerous functionality\n// This function executes a command but requires validation\nfunction executeCommand(command) {\n    if (isValidCommand(command)) {\n        system(command);\n    } else {\n        throw new Error('Invalid command');\n    }\n}", "// Secure example: Documenting file upload risks\napp.post('/upload', (req, res) => {\n    const file = req.files.uploadedFile;\n    if (isValidFile(file)) {\n        file.mv('/uploads/' + file.name);\n    } else {\n        res.status(400).send('Invalid file type');\n    }\n});"], "verification_steps": ["Review application documentation for sections on dangerous functionalities.", "Check if all identified dangerous functionalities are clearly marked.", "Ensure that documentation includes potential risks and mitigation strategies.", "Verify that the documentation is kept up to date with the latest application changes."], "common_mistakes": ["Failing to document dangerous functionalities.", "Inadequate detail in documentation regarding risks.", "Assuming all team members are aware of risks without explicit documentation.", "Neglecting to update documentation after changes to the application."], "related_cwe": ["CWE-20", "CWE-74", "CWE-94", "CWE-77"], "related_capec": ["CAPEC-1", "CAPEC-2", "CAPEC-3"], "attack_flow": "An attacker identifies a part of the application that uses dangerous functionality but is not documented. They exploit this lack of awareness to execute unauthorized commands or access sensitive data, leading to potential data breaches or system compromise."}
{"chapter_id": "V15", "chapter_name": "Secure Coding and Architecture", "section_id": "V15.2", "section_name": "Security Architecture and Dependencies", "req_id": "V15.2.1", "req_description": "Verify that the application only contains components which have not breached the documented update and remediation time frames.", "level": "1", "explanation": "This requirement ensures that all components used in the application are up-to-date and have not exceeded the defined timelines for updates and patches. It aims to minimize vulnerabilities that could be exploited due to outdated components.", "threats_mitigated": ["Exploitation of known vulnerabilities in outdated libraries", "Supply chain attacks", "Denial of Service through unpatched components"], "insecure_examples": [{"code": "import outdated_library; // Using a library that has known vulnerabilities"}, {"code": "if (component.version < latest_version) { /* No update applied */ }"}], "secure_examples": [{"code": "import updated_library; // Ensure to use the latest secure version"}, {"code": "if (component.version >= latest_version) { /* Update applied */ }"}], "verification_steps": ["Review the component inventory for version information.", "Check the update and remediation timelines for each component.", "Verify that all components are within the acceptable update timeframe.", "Identify any components that require immediate updates or remediation."], "common_mistakes": ["Failing to regularly check for component updates", "Using components without understanding their update policies", "Ignoring security advisories related to third-party libraries"], "related_cwe": ["CWE-1104", "CWE-20", "CWE-22"], "related_capec": ["CAPEC-137", "CAPEC-146", "CAPEC-154"], "attack_flow": "An attacker identifies a component in the application that is outdated and has a known vulnerability. They exploit this vulnerability to gain unauthorized access, execute arbitrary code, or cause a denial of service, leading to potential data breaches or service disruptions."}
{"chapter_id": "V15", "chapter_name": "Secure Coding and Architecture", "section_id": "V15.2", "section_name": "Security Architecture and Dependencies", "req_id": "V15.2.2", "req_description": "Verify that the application has implemented defenses against loss of availability due to functionality which is time-consuming or resource-demanding, based on the documented security decisions and strategies for this.", "level": 2, "explanation": "This requirement emphasizes the importance of ensuring that applications are designed to handle time-consuming or resource-intensive operations in a way that does not compromise their availability. This includes implementing strategies such as rate limiting, resource quotas, and proper timeout handling to prevent denial of service (DoS) attacks and ensure that legitimate users can access the application without interruption.", "threats_mitigated": ["Denial of Service (DoS)", "Resource Exhaustion", "Performance Degradation"], "insecure_examples": [{"code_snippet": "while(true) { processRequest(); } // Infinite loop causing resource exhaustion"}, {"code_snippet": "public void heavyComputation() { Thread.sleep(10000); } // Long blocking operation without timeout"}], "secure_examples": [{"code_snippet": "if(requestCount < maxRequests) { processRequest(); } else { rejectRequest(); } // Implementing rate limiting"}, {"code_snippet": "public void heavyComputation() { Future<?> future = executorService.submit(() -> { /* computation */ }); future.get(5, TimeUnit.SECONDS); } // Using timeout to avoid long blocking"}], "verification_steps": ["Check for implementation of rate limiting on resource-intensive endpoints.", "Review code for proper timeout handling in long-running operations.", "Verify that resource quotas are enforced to prevent abuse.", "Ensure that there are fallback mechanisms in place for high-load scenarios."], "common_mistakes": ["Neglecting to implement rate limiting on APIs.", "Failing to handle timeouts properly, leading to indefinite blocking.", "Overlooking resource management, allowing for potential exhaustion.", "Not documenting security decisions related to resource management."], "related_cwe": ["CWE-400", "CWE-770", "CWE-754"], "related_capec": ["CAPEC-130", "CAPEC-131"], "attack_flow": "An attacker may exploit resource-intensive functionalities by sending a high volume of requests or triggering long-running processes, leading to resource exhaustion. If the application lacks proper defenses, it may become unresponsive, denying service to legitimate users. This can result in significant downtime and loss of availability."}
{"chapter_id": "V15", "chapter_name": "Secure Coding and Architecture", "section_id": "V15.2", "section_name": "Security Architecture and Dependencies", "req_id": "V15.2.3", "req_description": "Verify that the production environment only includes functionality that is required for the application to function, and does not expose extraneous functionality such as test code, sample snippets, and development functionality.", "level": 2, "explanation": "This requirement emphasizes the importance of minimizing the attack surface by ensuring that only necessary features and functionalities are present in the production environment. Any leftover test code, sample snippets, or development tools can provide attackers with insights into the application's inner workings, potentially leading to exploitation.", "threats_mitigated": ["Information Disclosure", "Unauthorized Access", "Code Injection", "Denial of Service"], "insecure_examples": [{"code": "app.listen(3000, () => { console.log('Server is running'); }); // Development mode enabled"}, {"code": "if (process.env.NODE_ENV !== 'production') { console.log('Debugging information'); }"}], "secure_examples": [{"code": "app.listen(3000); // Production mode only"}, {"code": "if (process.env.NODE_ENV === 'production') { /* No debugging information */ }"}], "verification_steps": ["Review the deployment configuration to ensure no development tools are included.", "Check for the presence of test code or sample snippets in the production environment.", "Conduct a security audit of the production environment to identify any unnecessary functionalities.", "Verify that logging and debugging features are disabled in production."], "common_mistakes": ["Leaving debug or test code in the production environment.", "Not properly configuring environment variables to disable development features.", "Failing to conduct a thorough review of the deployment process."], "related_cwe": ["CWE-552: Files or Directories Accessible to External Parties", "CWE-20: Improper Input Validation"], "related_capec": ["CAPEC-137: Exploiting Debugging Functionality", "CAPEC-162: Exploiting Configuration Errors"], "attack_flow": "An attacker may scan the production environment for unnecessary functionalities or exposed test code. If such code is found, they can exploit it to gain insights into the application, leading to potential unauthorized access or other attacks."}
{"chapter_id": "V15", "chapter_name": "Secure Coding and Architecture", "section_id": "V15.2", "section_name": "Security Architecture and Dependencies", "req_id": "V15.2.4", "req_description": "Verify that third-party components and all of their transitive dependencies are included from the expected repository, whether internally owned or an external source, and that there is no risk of a dependency confusion attack.", "level": 3, "explanation": "This requirement emphasizes the importance of ensuring that all third-party libraries and their dependencies are sourced from trusted and verified repositories. It aims to prevent dependency confusion attacks, where an attacker could introduce malicious packages that mimic legitimate ones, potentially compromising the application. Developers must validate the integrity and origin of these components to maintain application security.", "threats_mitigated": ["Dependency confusion attacks", "Supply chain attacks", "Malicious code injection via third-party libraries"], "insecure_examples": [{"code": "import requests; # using a package from an unverified source", "description": "This code imports a library without verifying its source."}, {"code": "npm install some-package; # package not from a trusted registry", "description": "This command installs a package without confirming its origin, which may lead to using a malicious version."}], "secure_examples": [{"code": "import requests; # ensure requests is installed from a verified repository", "description": "This code imports a library that has been verified to come from a trusted source."}, {"code": "npm install some-package --registry=https://trusted-registry.com; # specify a trusted source", "description": "This command installs a package explicitly from a trusted registry."}], "verification_steps": ["Check the source of all third-party components.", "Validate the integrity of packages using checksums or signatures.", "Ensure that all dependencies are documented and reviewed.", "Monitor for updates and vulnerabilities in third-party libraries."], "common_mistakes": ["Using third-party libraries without verifying their source.", "Neglecting to check for transitive dependencies.", "Failing to update libraries regularly or ignoring security advisories."], "related_cwe": ["CWE-1104", "CWE-494", "CWE-937"], "related_capec": ["CAPEC-40", "CAPEC-185"], "attack_flow": "An attacker can exploit this requirement by publishing a malicious package with the same name as a legitimate one in a public repository. If a developer inadvertently installs this malicious package due to a lack of verification, the attacker gains access to the application environment, potentially leading to data breaches or system compromise."}
{"chapter_id": "V15", "chapter_name": "Secure Coding and Architecture", "section_id": "V15.2", "section_name": "Security Architecture and Dependencies", "req_id": "V15.2.5", "req_description": "Verify that the application implements additional protections around parts of the application which are documented as containing 'dangerous functionality' or using third-party libraries considered to be 'risky components'. This could include techniques such as sandboxing, encapsulation, containerization or network level isolation to delay and deter attackers who compromise one part of an application from pivoting elsewhere in the application.", "level": "3", "explanation": "This requirement emphasizes the need for additional security measures around components that are known to be vulnerable or risky. By implementing techniques like sandboxing, encapsulation, or containerization, developers can create isolated environments that limit the potential damage from an attacker who gains access to these components. This isolation helps to ensure that even if one part of the application is compromised, the attacker cannot easily access or control other parts of the application.", "threats_mitigated": ["Unauthorized access to sensitive data", "Privilege escalation", "Cross-component attacks", "Data leakage", "Malware injection"], "insecure_examples": [{"code": "const riskyComponent = require('risky-library'); riskyComponent.executeDangerousFunction();"}, {"code": "app.use('/dangerous-endpoint', riskyMiddleware);"}], "secure_examples": [{"code": "const secureSandbox = createSandbox(); secureSandbox.execute(() => riskyComponent.executeDangerousFunction());"}, {"code": "app.use('/dangerous-endpoint', secureMiddleware);"}], "verification_steps": ["Identify components with dangerous functionality.", "Review the architecture for isolation techniques implemented.", "Check for the use of containerization or sandboxing.", "Ensure network-level isolation is configured correctly.", "Test the application to verify that compromised components do not lead to further exploitation."], "common_mistakes": ["Failing to document risky components within the application.", "Not implementing isolation techniques for third-party libraries.", "Assuming that all components are secure without verification.", "Neglecting to regularly update and patch risky components."], "related_cwe": ["CWE-77: Command Injection", "CWE-287: Improper Authentication", "CWE-20: Improper Input Validation", "CWE-250: Execution with Unnecessary Privileges"], "related_capec": ["CAPEC-1: Command Injection", "CAPEC-2: SQL Injection", "CAPEC-100: Exploiting Software Vulnerabilities"], "attack_flow": "An attacker identifies a vulnerable component within the application that is not properly isolated. They exploit this vulnerability to gain access to the component and then attempt to pivot to other parts of the application. If proper protections such as sandboxing or encapsulation are not in place, the attacker can escalate privileges and access sensitive data or functionality elsewhere in the application."}
{"chapter_id": "V15", "chapter_name": "Secure Coding and Architecture", "section_id": "V15.3", "section_name": "Defensive Coding", "req_id": "V15.3.1", "req_description": "Verify that the application only returns the required subset of fields from a data object. For example, it should not return an entire data object, as some individual fields should not be accessible to users.", "level": 1, "explanation": "This requirement emphasizes the importance of limiting the data returned by the application to only what is necessary for the user. By doing so, it minimizes the risk of exposing sensitive information that could be misused by unauthorized users. Developers should implement mechanisms to filter out unnecessary fields based on the user's permissions and the context of the request.", "threats_mitigated": ["Data exposure", "Information leakage", "Unauthorized data access"], "insecure_examples": ["return userData; // returns entire user object including sensitive fields like password and SSN", "response.send(userProfile); // sends full profile data without filtering"], "secure_examples": ["return { name: userData.name, email: userData.email }; // returns only necessary fields", "response.send({ name: userProfile.name, role: userProfile.role }); // filters out sensitive information"], "verification_steps": ["Review the API response structure to ensure only required fields are included.", "Check for any user roles or permissions that dictate which fields should be returned.", "Test the application with different user roles to confirm that sensitive data is not exposed.", "Ensure that field filtering logic is implemented and functioning as intended."], "common_mistakes": ["Returning entire objects without filtering fields.", "Failing to consider user roles when determining which fields to return.", "Neglecting to review changes in data models that may introduce new sensitive fields."], "related_cwe": ["CWE-200: Information Exposure", "CWE-209: Information Exposure Through an Error Message"], "related_capec": ["CAPEC-137: Data Manipulation", "CAPEC-157: Data Exposure via API"], "attack_flow": "An attacker exploits this requirement by crafting a request that retrieves the entire data object. If the application does not properly filter the response, the attacker can access sensitive information such as passwords, personal identification numbers, or other confidential data, leading to further attacks such as identity theft or account takeover."}
{"chapter_id": "V15", "chapter_name": "Secure Coding and Architecture", "section_id": "V15.3", "section_name": "Defensive Coding", "req_id": "V15.3.2", "req_description": "Verify that where the application backend makes calls to external URLs, it is configured to not follow redirects unless it is intended functionality.", "level": 2, "explanation": "This requirement emphasizes the need for applications to control how they handle HTTP redirects when making requests to external URLs. By not following redirects automatically, the application can avoid potential security risks such as open redirects, which can lead to phishing attacks or the exposure of sensitive data through unintended destinations.", "threats_mitigated": ["Open Redirects", "Phishing Attacks", "Data Leakage", "Malicious Redirects"], "insecure_examples": [{"code": "HttpClient client = new HttpClient();\nclient.get(\"http://example.com/external?redirect=true\");"}, {"code": "URL url = new URL(\"http://example.com\");\nHttpURLConnection conn = (HttpURLConnection) url.openConnection();\nconn.setInstanceFollowRedirects(true);\nconn.connect();"}], "secure_examples": [{"code": "HttpClient client = new HttpClient();\nclient.get(\"http://example.com/external?redirect=true\", false);"}, {"code": "URL url = new URL(\"http://example.com\");\nHttpURLConnection conn = (HttpURLConnection) url.openConnection();\nconn.setInstanceFollowRedirects(false);\nconn.connect();"}], "verification_steps": ["Review the code where external URL calls are made.", "Ensure that the configuration for following redirects is explicitly set to false.", "Check that any external URLs are validated and controlled.", "Test the application to confirm that it does not follow redirects unless specified."], "common_mistakes": ["Assuming that redirect following is safe without validation.", "Hardcoding external URLs without checks.", "Not reviewing third-party libraries that may follow redirects automatically."], "related_cwe": ["CWE-601", "CWE-917"], "related_capec": ["CAPEC-156", "CAPEC-117"], "attack_flow": "An attacker crafts a malicious URL that redirects to a harmful site. If the application follows redirects automatically, it may lead the user to the attacker's site, potentially leading to credential theft or malware installation."}
{"chapter_id": "V15", "chapter_name": "Secure Coding and Architecture", "section_id": "V15.3", "section_name": "Defensive Coding", "req_id": "V15.3.3", "req_description": "Verify that the application has countermeasures to protect against mass assignment attacks by limiting allowed fields per controller and action, e.g., it is not possible to insert or update a field value when it was not intended to be part of that action.", "level": "2", "explanation": "This requirement emphasizes the importance of validating and restricting the fields that can be updated or inserted in an application. Mass assignment attacks occur when an attacker is able to modify fields that should not be exposed to them by manipulating input data. By implementing strict controls over which fields are allowed for each action, developers can prevent unauthorized modifications and ensure that only intended data is processed.", "threats_mitigated": ["Mass Assignment", "Unauthorized Data Modification", "Data Leakage"], "insecure_examples": [{"code": "user.update(params)", "description": "This code directly uses user input for updating a user object without validating the fields."}, {"code": "Product.create(params)", "description": "This code allows all parameters from user input to be used for creating a product, potentially allowing unauthorized fields."}], "secure_examples": [{"code": "user.update(params.permit(:name, :email))", "description": "This code explicitly permits only the 'name' and 'email' fields for updating a user object."}, {"code": "Product.create(params.require(:product).permit(:title, :price))", "description": "This code ensures only 'title' and 'price' fields are allowed for creating a product."}], "verification_steps": ["Review the controller actions to ensure only allowed fields are specified.", "Check for the use of strong parameters or similar mechanisms to restrict input fields.", "Test the application by attempting to submit additional fields not permitted by the controller."], "common_mistakes": ["Not validating input fields at the controller level.", "Using generic parameter handling that accepts all input without filtering.", "Failing to update documentation regarding allowed fields after changes."], "related_cwe": ["CWE-117: Improper Output Encoding or Escaping", "CWE-20: Improper Input Validation"], "related_capec": ["CAPEC-137: Mass Assignment", "CAPEC-162: Parameter Injection"], "attack_flow": "An attacker identifies a controller action that allows mass assignment. They then craft a request that includes additional fields not intended for that action, such as 'isAdmin' or 'userRole'. If the application does not restrict these fields, the attacker can modify sensitive attributes, potentially gaining unauthorized access or privileges."}
{"chapter_id": "V15", "chapter_name": "Secure Coding and Architecture", "section_id": "V15.3", "section_name": "Defensive Coding", "req_id": "V15.3.4", "req_description": "Verify that all proxying and middleware components transfer the user's original IP address correctly using trusted data fields that cannot be manipulated by the end user, and the application and web server use this correct value for logging and security decisions such as rate limiting, taking into account that even the original IP address may not be reliable due to dynamic IPs, VPNs, or corporate firewalls.", "level": "2", "explanation": "This requirement emphasizes the importance of accurately capturing and utilizing the user's original IP address for security purposes. It highlights the need to ensure that the IP address is sourced from trusted headers and not directly from user inputs, which could be forged. Proper handling of the IP address is crucial for effective logging, rate limiting, and other security mechanisms. Additionally, it acknowledges the limitations of IP addresses as reliable identifiers due to factors like dynamic IP assignments and the use of VPNs.", "threats_mitigated": ["IP Spoofing", "Denial of Service (DoS) attacks", "Misuse of rate limiting", "Bypassing security controls"], "insecure_examples": ["request.getHeader('X-Forwarded-For')", "request.getRemoteAddr()"], "secure_examples": ["String originalIp = request.getHeader('X-Real-IP') != null ? request.getHeader('X-Real-IP') : request.getRemoteAddr();", "if (isTrustedProxy(request.getHeader('X-Forwarded-For'))) { originalIp = request.getHeader('X-Forwarded-For'); }"], "verification_steps": ["Check that the application uses trusted headers for IP retrieval.", "Ensure that there is validation to confirm the integrity of the IP address.", "Review logging mechanisms to verify that the correct IP address is logged.", "Test rate limiting to ensure it operates based on the original IP address."], "common_mistakes": ["Relying solely on user-supplied headers without validation.", "Failing to account for multiple IP addresses in forwarded headers.", "Not implementing checks for trusted proxies."], "related_cwe": ["CWE-20", "CWE-74", "CWE-200"], "related_capec": ["CAPEC-104", "CAPEC-110"], "attack_flow": "An attacker could spoof their IP address by manipulating HTTP headers, such as 'X-Forwarded-For', to bypass security measures like rate limiting. If the application does not validate these headers against a list of trusted proxies, the attacker could flood the application with requests, leading to a Denial of Service. Additionally, if logging is based on the manipulated IP address, it could mislead incident response efforts."}
{"chapter_id": "V15", "chapter_name": "Secure Coding and Architecture", "section_id": "V15.3", "section_name": "Defensive Coding", "req_id": "V15.3.5", "req_description": "Verify that the application explicitly ensures that variables are of the correct type and performs strict equality and comparator operations. This is to avoid type juggling or type confusion vulnerabilities caused by the application code making an assumption about a variable type.", "level": "2", "explanation": "This requirement emphasizes the importance of type safety in programming. Type juggling occurs when a programming language automatically converts one data type to another, which can lead to unexpected behavior and security vulnerabilities. By enforcing strict type checks and using strict equality (===) instead of loose equality (==), developers can prevent unintended type coercion and ensure that comparisons are made between compatible types.", "threats_mitigated": ["Type Juggling Attacks", "Type Confusion Vulnerabilities", "Injection Attacks"], "insecure_examples": ["if (userInput == expectedValue) { /* do something */ }", "let result = someFunction(userInput); if (result == true) { /* do something */ }"], "secure_examples": ["if (userInput === expectedValue) { /* do something */ }", "let result = someFunction(userInput); if (result === true) { /* do something */ }"], "verification_steps": ["Review code for strict equality checks (===) instead of loose equality (==).", "Ensure that type declarations are used where applicable (e.g., TypeScript).", "Check for explicit type conversions before comparisons.", "Look for any use of dynamic typing that could lead to type confusion."], "common_mistakes": ["Using loose equality checks (==) which allows type coercion.", "Assuming a variable type based on its value without explicit checks.", "Not utilizing type annotations in languages that support them."], "related_cwe": ["CWE-697: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')", "CWE-20: Improper Input Validation", "CWE-129: Improper Validation of Array Index"], "related_capec": ["CAPEC-135: Type Confusion", "CAPEC-118: Type Juggling"], "attack_flow": "An attacker may exploit type juggling vulnerabilities by crafting input that, when coerced into a different type, alters the logic of the application. For example, if a comparison is made using loose equality, an attacker could input a value that is coerced into a type that bypasses security checks, leading to unauthorized access or data manipulation."}
{"chapter_id": "V15", "chapter_name": "Secure Coding and Architecture", "section_id": "V15.3", "section_name": "Defensive Coding", "req_id": "V15.3.6", "req_description": "Verify that JavaScript code is written in a way that prevents prototype pollution, for example, by using Set() or Map() instead of object literals.", "level": "2", "explanation": "Prototype pollution is a vulnerability that allows an attacker to modify an object's prototype, potentially leading to unexpected behavior or security issues. This requirement emphasizes the importance of using data structures like Set or Map, which do not expose the prototype chain, thereby reducing the risk of such attacks. By avoiding object literals for dynamic properties, developers can prevent unauthorized modifications to the prototype.", "threats_mitigated": ["Prototype Pollution", "Denial of Service", "Arbitrary Code Execution"], "insecure_examples": [{"code": "const obj = {}; obj['__proto__'] = { isAdmin: true };"}, {"code": "const user = {}; user['name'] = 'John'; user['__proto__'] = {}; // Vulnerable to prototype pollution"}], "secure_examples": [{"code": "const safeMap = new Map(); safeMap.set('name', 'John');"}, {"code": "const safeSet = new Set(); safeSet.add('user');"}], "verification_steps": ["Review code for usage of object literals that allow dynamic property assignment.", "Check for the use of Set() or Map() in place of object literals.", "Look for any instances where '__proto__' or similar properties are being assigned.", "Ensure that libraries or frameworks used do not allow prototype pollution."], "common_mistakes": ["Using object literals for dynamic data without validation.", "Failing to sanitize input that may affect object properties.", "Not understanding the implications of prototype chain manipulation."], "related_cwe": ["CWE-1321", "CWE-22", "CWE-20"], "related_capec": ["CAPEC-96", "CAPEC-137"], "attack_flow": "An attacker can exploit prototype pollution by injecting properties into an object's prototype, which can lead to manipulation of application logic, unauthorized access, or execution of arbitrary code. This can occur through user input that is not properly validated, allowing the attacker to alter the behavior of the application and potentially gain elevated privileges or cause a denial of service."}
{"chapter_id": "V15", "chapter_name": "Secure Coding and Architecture", "section_id": "V15.3", "section_name": "Defensive Coding", "req_id": "V15.3.7", "req_description": "Verify that the application has defenses against HTTP parameter pollution attacks, particularly if the application framework makes no distinction about the source of request parameters (query string, body parameters, cookies, or header fields).", "level": 2, "explanation": "HTTP parameter pollution (HPP) attacks occur when an attacker sends multiple parameters with the same name in an HTTP request. If the application does not properly handle these parameters, it may lead to unexpected behavior, such as overriding legitimate parameters or executing unintended actions. This requirement emphasizes the need for applications to implement validation and sanitization mechanisms to ensure that only expected parameters are processed, regardless of their source.", "threats_mitigated": ["Parameter manipulation", "Session fixation", "Injection attacks", "Data leakage"], "insecure_examples": ["GET /api/resource?id=123&id=456 HTTP/1.1", "POST /api/resource HTTP/1.1\nContent-Type: application/x-www-form-urlencoded\n\nid=123&id=456"], "secure_examples": ["GET /api/resource?id=123 HTTP/1.1", "POST /api/resource HTTP/1.1\nContent-Type: application/x-www-form-urlencoded\n\nid=123"], "verification_steps": ["Review the applicationâ€™s handling of request parameters.", "Check if the application distinguishes between different sources of parameters.", "Test for multiple parameters with the same name and observe application behavior.", "Ensure that validation and sanitization are applied to all incoming parameters."], "common_mistakes": ["Assuming that the framework will automatically handle parameter conflicts.", "Not validating or sanitizing input parameters from different sources.", "Failing to test for HPP scenarios during application testing."], "related_cwe": ["CWE-20: Improper Input Validation", "CWE-61: Improper Restriction of Interaction Frequency", "CWE-74: Injection"], "related_capec": ["CAPEC-157: HTTP Parameter Pollution", "CAPEC-164: HTTP Request Smuggling"], "attack_flow": "An attacker crafts a request with multiple parameters of the same name, such as 'id'. If the application does not properly handle these parameters, it may process the last parameter value, which could be malicious. This can lead to unauthorized access, data manipulation, or other unintended actions, exploiting the application's lack of proper validation."}
{"chapter_id": "V15", "chapter_name": "Secure Coding and Architecture", "section_id": "V15.4", "section_name": "Safe Concurrency", "req_id": "V15.4.1", "req_description": "Verify that shared objects in multi-threaded code (such as caches, files, or in-memory objects accessed by multiple threads) are accessed safely by using thread-safe types and synchronization mechanisms like locks or semaphores to avoid race conditions and data corruption.", "level": 3, "explanation": "This requirement emphasizes the importance of ensuring that shared resources in a multi-threaded environment are accessed in a controlled manner. Without proper synchronization, multiple threads may attempt to read and write to the same object simultaneously, leading to unpredictable behavior, data corruption, and application crashes. Developers should use thread-safe data structures and synchronization primitives to manage access to shared resources effectively.", "threats_mitigated": ["Race Conditions", "Data Corruption", "Deadlocks", "Application Crashes"], "insecure_examples": [{"code": "List<Integer> sharedList = new ArrayList<>();\n\nvoid addToList(int value) {\n    sharedList.add(value);\n}"}, {"code": "public int getValue() {\n    return sharedCounter;\n}\n\npublic void increment() {\n    sharedCounter++;\n}"}], "secure_examples": [{"code": "List<Integer> sharedList = Collections.synchronizedList(new ArrayList<>());\n\nsynchronized(sharedList) {\n    sharedList.add(value);\n}"}, {"code": "private final ReentrantLock lock = new ReentrantLock();\n\npublic int getValue() {\n    lock.lock();\n    try {\n        return sharedCounter;\n    } finally {\n        lock.unlock();\n    }\n}\n\npublic void increment() {\n    lock.lock();\n    try {\n        sharedCounter++;\n    } finally {\n        lock.unlock();\n    }\n}"}], "verification_steps": ["Check for the use of thread-safe data structures.", "Ensure that synchronization mechanisms (locks, semaphores) are correctly implemented.", "Review code for potential race conditions in shared resource access.", "Verify that critical sections are properly defined and protected."], "common_mistakes": ["Using non-thread-safe collections in a multi-threaded environment.", "Neglecting to synchronize access to shared resources.", "Improperly implementing locks, leading to deadlocks or race conditions.", "Assuming that read operations do not require synchronization."], "related_cwe": ["CWE-362", "CWE-664", "CWE-367"], "related_capec": ["CAPEC-104", "CAPEC-118", "CAPEC-137"], "attack_flow": "An attacker may exploit a race condition by manipulating the timing of thread execution to access shared resources simultaneously. This can lead to inconsistent states, where the application behaves unexpectedly, potentially allowing the attacker to gain unauthorized access to sensitive data or execute arbitrary code."}
{"chapter_id": "V15", "chapter_name": "Secure Coding and Architecture", "section_id": "V15.4", "section_name": "Safe Concurrency", "req_id": "V15.4.2", "req_description": "Verify that checks on a resource's state, such as its existence or permissions, and the actions that depend on them are performed as a single atomic operation to prevent time-of-check to time-of-use (TOCTOU) race conditions. For example, checking if a file exists before opening it, or verifying a userâ€™s access before granting it.", "level": "3", "explanation": "This requirement emphasizes the importance of ensuring that checks on the state of resources (like files or user permissions) are done in a way that prevents race conditions. A TOCTOU race condition occurs when the state of a resource changes between the time it is checked and the time it is used. By performing these checks and actions atomically, you can ensure that the resource's state remains consistent and secure throughout the operation.", "threats_mitigated": ["Unauthorized access", "Data corruption", "Privilege escalation", "Denial of service"], "insecure_examples": [{"code": "if (fileExists(filePath)) {\n    openFile(filePath);\n}"}, {"code": "if (userHasAccess(userId)) {\n    grantAccess(userId);\n}"}], "secure_examples": [{"code": "if (fileExistsAtomic(filePath)) {\n    openFile(filePath);\n}"}, {"code": "if (userHasAccessAtomic(userId)) {\n    grantAccess(userId);\n}"}], "verification_steps": ["Review code for resource state checks and their corresponding actions.", "Ensure that checks and actions are executed in a single atomic operation.", "Look for potential race conditions in multi-threaded or asynchronous contexts.", "Check for the use of appropriate synchronization mechanisms."], "common_mistakes": ["Performing checks and actions in separate statements, allowing for state changes in between.", "Neglecting to consider multi-threading issues when accessing shared resources.", "Using non-atomic operations for critical checks."], "related_cwe": ["CWE-367", "CWE-362", "CWE-20", "CWE-284"], "related_capec": ["CAPEC-145", "CAPEC-146"], "attack_flow": "An attacker can exploit a TOCTOU race condition by manipulating the resource state between the check and the use. For instance, if a file existence check is performed and the attacker deletes or modifies the file before it is opened, the application may behave unexpectedly, leading to unauthorized access or data corruption."}
{"chapter_id": "V15", "chapter_name": "Secure Coding and Architecture", "section_id": "V15.4", "section_name": "Safe Concurrency", "req_id": "V15.4.3", "req_description": "Verify that locks are used consistently to avoid threads getting stuck, whether by waiting on each other or retrying endlessly, and that locking logic stays within the code responsible for managing the resource to ensure locks cannot be inadvertently or maliciously modified by external classes or code.", "level": "3", "explanation": "This requirement emphasizes the importance of consistent lock usage in multi-threaded applications to prevent deadlocks and ensure that threads do not interfere with each other. It requires that locking mechanisms are encapsulated within the resource management code to prevent external interference, which could lead to unpredictable behavior and security vulnerabilities.", "threats_mitigated": ["Deadlocks", "Race conditions", "Resource starvation", "Denial of Service (DoS) due to thread contention"], "insecure_examples": [{"code": "public void unsafeMethod() {\n    synchronized(lock1) {\n        synchronized(lock2) {\n            // critical section\n        }\n    }\n}", "description": "This code can lead to deadlocks if multiple threads try to lock lock1 and lock2 in a different order."}, {"code": "public void anotherUnsafeMethod() {\n    lock1.lock();\n    // do something\n    lock2.lock(); // potential for deadlock if another thread has lock2\n    // critical section\n    lock2.unlock();\n    lock1.unlock();\n}", "description": "This code does not ensure that locks are released in a consistent order, leading to potential deadlocks."}], "secure_examples": [{"code": "public void safeMethod() {\n    synchronized(this) {\n        // critical section\n    }\n}", "description": "Using a single lock (this) ensures that only one thread can access the critical section at a time, preventing deadlocks."}, {"code": "public void anotherSafeMethod() {\n    synchronized(lock1) {\n        // do something\n        synchronized(lock2) {\n            // critical section\n        }\n    }\n}", "description": "This ensures that the locks are acquired in a consistent order, preventing deadlocks."}], "verification_steps": ["Review code for consistent lock usage patterns.", "Check that all locks are released in the same order they are acquired.", "Ensure that locking logic is encapsulated within the resource management code.", "Look for potential deadlock scenarios in multi-threaded code.", "Verify that no external classes can modify locking behavior."], "common_mistakes": ["Acquiring locks in inconsistent order across different threads.", "Failing to release locks in all code paths, especially in exception handling.", "Using global locks unnecessarily, leading to contention and performance issues.", "Not encapsulating locking logic within the resource management code."], "related_cwe": ["CWE-833", "CWE-667", "CWE-664", "CWE-362"], "related_capec": ["CAPEC-143", "CAPEC-146", "CAPEC-147"], "attack_flow": "An attacker may exploit inconsistent lock usage by creating multiple threads that acquire locks in different orders, leading to a deadlock situation. This can cause the application to hang indefinitely, resulting in denial of service. Additionally, if locking logic is exposed or modified by external code, it can lead to race conditions where the attacker can manipulate shared resources, causing unpredictable behavior or data corruption."}
{"chapter_id": "V15", "chapter_name": "Secure Coding and Architecture", "section_id": "V15.4", "section_name": "Safe Concurrency", "req_id": "V15.4.4", "req_description": "Verify that resource allocation policies prevent thread starvation by ensuring fair access to resources, such as by leveraging thread pools, allowing lower-priority threads to proceed within a reasonable timeframe.", "level": "3", "explanation": "This requirement emphasizes the importance of implementing resource allocation strategies that ensure all threads have fair access to necessary resources. Thread starvation occurs when one or more threads are perpetually denied access to resources due to improper scheduling or allocation policies. By using thread pools and prioritizing access based on fairness, applications can maintain performance and responsiveness, especially in multi-threaded environments.", "threats_mitigated": ["Thread starvation", "Denial of service (DoS) due to resource exhaustion", "Performance degradation"], "insecure_examples": [{"code": "public void process() {\n    while (true) {\n        // high-priority thread hogging resources\n    }\n}"}, {"code": "public void allocateResources() {\n    // No thread pool, direct allocation leading to starvation\n}"}], "secure_examples": [{"code": "public void process() {\n    ExecutorService executor = Executors.newFixedThreadPool(10);\n    // Submit tasks ensuring fair access\n}"}, {"code": "public void allocateResources() {\n    // Using a thread pool to manage resource allocation\n    ExecutorService executor = Executors.newCachedThreadPool();\n}"}], "verification_steps": ["Review thread allocation policies and ensure they utilize thread pools.", "Check for mechanisms that allow lower-priority threads to access resources.", "Test the application under load to identify any signs of thread starvation.", "Analyze thread scheduling and resource allocation logs for fairness."], "common_mistakes": ["Using a single-threaded model for high-load applications.", "Failing to implement a fair scheduling algorithm.", "Neglecting to test for thread starvation under various load conditions."], "related_cwe": ["CWE-665", "CWE-682"], "related_capec": ["CAPEC-139", "CAPEC-162"], "attack_flow": "An attacker may exploit thread starvation by creating a large number of high-priority threads that monopolize resources, preventing lower-priority threads from executing. This can lead to application unresponsiveness or crashes, effectively causing a denial of service."}
{"chapter_id": "V16", "chapter_name": "Security Logging and Error Handling", "section_id": "V16.1", "section_name": "Security Logging Documentation", "req_id": "V16.1.1", "req_description": "Verify that an inventory exists documenting the logging performed at each layer of the application's technology stack, what events are being logged, log formats, where that logging is stored, how it is used, how access to it is controlled, and for how long logs are kept.", "level": "2", "explanation": "This requirement emphasizes the importance of maintaining a comprehensive inventory of logging activities across all layers of the application. It ensures that developers and security teams have visibility into what is being logged, the format of the logs, the storage mechanisms, access controls, and retention policies. This documentation is crucial for effective monitoring, incident response, and compliance with regulatory requirements.", "threats_mitigated": ["Unauthorized access to sensitive logs", "Data breaches due to insufficient logging", "Inability to detect and respond to security incidents", "Loss of forensic evidence"], "insecure_examples": ["console.log('User logged in'); // No details on storage or access control", "app.use(morgan('dev')); // Default logging with no inventory or control"], "secure_examples": ["logger.info('User logged in', { userId: user.id, timestamp: new Date() }); // Detailed logging with access control documentation", "app.use(morgan('combined', { stream: accessLogStream })); // Custom logging with defined storage and access control"], "verification_steps": ["Check for the existence of a logging inventory document.", "Verify that the inventory includes details on log events, formats, and storage locations.", "Ensure that access controls for logs are documented and implemented.", "Review log retention policies to confirm compliance with regulations."], "common_mistakes": ["Failing to document all logging activities.", "Using default logging configurations without customization.", "Neglecting to enforce access controls on log files.", "Not regularly reviewing or updating the logging inventory."], "related_cwe": ["CWE-778: Insufficient Logging", "CWE-532: Insertion of Sensitive Information into Log Files", "CWE-200: Information Exposure"], "related_capec": ["CAPEC-137: Log Injection", "CAPEC-154: Log File Manipulation", "CAPEC-158: Log File Analysis"], "attack_flow": "An attacker may exploit insufficient logging by performing actions that generate no logs or by accessing logs without proper controls. If logging is not documented, the application may fail to capture critical events, making it difficult to detect unauthorized access or data breaches. This lack of visibility can lead to prolonged exposure and increased damage from attacks."}
{"chapter_id": "V16", "chapter_name": "Security Logging and Error Handling", "section_id": "V16.2", "section_name": "General Logging", "req_id": "V16.2.1", "req_description": "Verify that each log entry includes necessary metadata (such as when, where, who, what) that would allow for a detailed investigation of the timeline when an event happens.", "level": "2", "explanation": "This requirement emphasizes the importance of including comprehensive metadata in log entries. This metadata should capture critical details about the event, including the timestamp (when), the source (where), the user or system involved (who), and the nature of the event (what). This information is vital for forensic analysis and incident response, enabling teams to reconstruct events and understand the context of security incidents.", "threats_mitigated": ["Insufficient logging leading to undetected security breaches", "Difficulty in forensic investigations", "Inability to track user actions and system changes"], "insecure_examples": ["logger.info('User logged in');", "logger.error('An error occurred');"], "secure_examples": ["logger.info('User logged in', { timestamp: new Date(), userId: user.id, ipAddress: req.ip });", "logger.error('An error occurred', { timestamp: new Date(), errorDetails: error.message, userId: user.id });"], "verification_steps": ["Check that all log entries include a timestamp.", "Verify that the source of the log entry is recorded.", "Ensure that user identification is included in the logs.", "Confirm that the nature of the event is clearly described in the logs."], "common_mistakes": ["Failing to include timestamps in log entries.", "Not logging user identifiers, making it hard to trace actions back to users.", "Using vague descriptions for logged events."], "related_cwe": ["CWE-778: Insufficient Logging", "CWE-117: Improper Output Neutralization for Logs"], "related_capec": ["CAPEC-159: Log Injection", "CAPEC-124: Log Forging"], "attack_flow": "An attacker may exploit insufficient logging by performing malicious actions without being detected. If logs do not capture essential metadata, it becomes challenging for security teams to identify the timeline and context of the attack, allowing the attacker to operate undetected and potentially escalate their attack or exfiltrate data."}
{"chapter_id": "V16", "chapter_name": "Security Logging and Error Handling", "section_id": "V16.2", "section_name": "General Logging", "req_id": "V16.2.2", "req_description": "Verify that time sources for all logging components are synchronized, and that timestamps in security event metadata use UTC or include an explicit time zone offset. UTC is recommended to ensure consistency across distributed systems and to prevent confusion during daylight saving time transitions.", "level": "2", "explanation": "This requirement emphasizes the importance of having a consistent and reliable time reference for all logging activities. By synchronizing time sources and using UTC, organizations can ensure that logs from different systems can be accurately correlated and analyzed. This is crucial for incident response, forensic analysis, and compliance with regulations that require precise logging.", "threats_mitigated": ["Log tampering", "Confusion during incident response", "Inaccurate forensic analysis", "Misalignment during security audits"], "insecure_examples": [{"code": "logger.info(\"User logged in at: \" + new Date()); // Local time used"}, {"code": "logger.error(\"Transaction failed at: \" + System.currentTimeMillis()); // No timezone information"}], "secure_examples": [{"code": "logger.info(\"User logged in at: \" + ZonedDateTime.now(ZoneOffset.UTC)); // UTC time used"}, {"code": "logger.error(\"Transaction failed at: \" + Instant.now().atZone(ZoneId.of(\"UTC\"))); // Explicit UTC timezone"}], "verification_steps": ["Check that all logging components use a synchronized time source.", "Verify that timestamps in logs are recorded in UTC or include a time zone offset.", "Review the configuration of logging libraries to ensure they are set to use UTC.", "Test logging functionality across distributed systems to ensure consistent timestamping."], "common_mistakes": ["Using local server time instead of UTC.", "Failing to synchronize time across distributed systems.", "Not including timezone information in logs.", "Assuming all systems will have the same time settings."], "related_cwe": ["CWE-117: Improper Output Neutralization for Logs", "CWE-200: Information Exposure", "CWE-284: Improper Access Control"], "related_capec": ["CAPEC-122: Log Injection", "CAPEC-137: Time-based Attacks"], "attack_flow": "An attacker could exploit inconsistent timestamps in logs to create confusion during incident response, potentially leading to misinterpretation of events. For instance, if logs from different systems do not align in time, it may be difficult to determine the sequence of events, allowing the attacker to obfuscate their actions and evade detection."}
{"chapter_id": "V16", "chapter_name": "Security Logging and Error Handling", "section_id": "V16.2", "section_name": "General Logging", "req_id": "V16.2.3", "req_description": "Verify that the application only stores or broadcasts logs to the files and services that are documented in the log inventory.", "level": "2", "explanation": "This requirement ensures that logging practices are controlled and documented. By maintaining a log inventory, organizations can ensure that sensitive information is not inadvertently logged or sent to unauthorized locations. It helps in maintaining compliance and in protecting sensitive data from exposure.", "threats_mitigated": ["Information Disclosure", "Data Breach", "Log Injection", "Unauthorized Access to Logs"], "insecure_examples": ["logger.info('User login attempt: ' + userInput); // logs sensitive user input without validation", "logToExternalService(logData); // sends logs to an unapproved external service"], "secure_examples": ["logger.info('User login attempt'); // logs general information, not sensitive data", "logToApprovedService(logData); // sends logs only to an approved service as per inventory"], "verification_steps": ["Review the log inventory documentation.", "Check the logging configuration files for compliance with the log inventory.", "Verify that no sensitive information is logged.", "Ensure that logs are only sent to approved destinations."], "common_mistakes": ["Logging sensitive information such as passwords or personal data.", "Failing to update the log inventory when new logging destinations are added.", "Not reviewing logs for compliance with the documented inventory."], "related_cwe": ["CWE-532: Information Exposure Through Log Files", "CWE-200: Information Exposure"], "related_capec": ["CAPEC-137: Log Injection", "CAPEC-154: Log File Manipulation"], "attack_flow": "An attacker may exploit this requirement by injecting malicious input that gets logged, leading to sensitive information exposure. If logs are sent to an unauthorized service, the attacker can gain access to sensitive logs, which may contain credentials or other sensitive data, facilitating further attacks."}
{"chapter_id": "V16", "chapter_name": "Security Logging and Error Handling", "section_id": "V16.2", "section_name": "General Logging", "req_id": "V16.2.4", "req_description": "Verify that logs can be read and correlated by the log processor that is in use, preferably by using a common logging format.", "level": 2, "explanation": "This requirement emphasizes the importance of using a standardized logging format that can be easily processed by various log management tools. By ensuring that logs are structured and consistent, organizations can improve their ability to analyze logs for security events, detect anomalies, and correlate events across different systems.", "threats_mitigated": ["Inadequate log analysis leading to missed security incidents", "Difficulty in correlating events across systems", "Inefficient incident response due to poorly formatted logs"], "insecure_examples": ["logger.log('User login failed: ' + userId);", "logger.log('Error occurred: ' + errorMessage);"], "secure_examples": ["logger.log({ event: 'UserLoginFailed', userId: userId, timestamp: new Date().toISOString() });", "logger.log({ event: 'ErrorOccurred', message: errorMessage, timestamp: new Date().toISOString() });"], "verification_steps": ["Check that logs are structured in a consistent format (e.g., JSON, XML).", "Verify that timestamps are included in logs and are in a standard format.", "Ensure that relevant contextual information (e.g., user IDs, session IDs) is included in logs.", "Test the log processor to confirm it can parse and analyze the logs correctly."], "common_mistakes": ["Using plain text logs without structure.", "Failing to include necessary contextual information.", "Not standardizing log formats across different components of the application."], "related_cwe": ["CWE-117: Improper Output Neutralization for Logs", "CWE-778: Insufficient Logging"], "related_capec": ["CAPEC-156: Log Injection", "CAPEC-135: Log Forging"], "attack_flow": "An attacker may exploit poorly formatted logs by injecting misleading information or omitting critical details, making it difficult for security teams to detect and respond to incidents. For example, if logs do not include user IDs or timestamps, it can hinder the ability to correlate events and identify malicious activities."}
{"chapter_id": "V16", "chapter_name": "Security Logging and Error Handling", "section_id": "V16.2", "section_name": "General Logging", "req_id": "V16.2.5", "req_description": "Verify that when logging sensitive data, the application enforces logging based on the data's protection level. For example, it may not be allowed to log certain data, such as credentials or payment details. Other data, such as session tokens, may only be logged by being hashed or masked, either in full or partially.", "level": 2, "explanation": "This requirement emphasizes the importance of handling sensitive information responsibly when logging. It mandates that developers categorize data based on its sensitivity and apply appropriate logging practices to prevent unauthorized access or exposure of sensitive information. For instance, credentials should never be logged in plaintext, while session tokens should be hashed or masked to protect them from being easily exploited if logs are accessed by unauthorized individuals.", "threats_mitigated": ["Data exposure", "Unauthorized access", "Credential theft", "Session hijacking"], "insecure_examples": ["logger.info('User login attempt with credentials: ' + user.getCredentials());", "logger.debug('Payment details: ' + payment.getDetails());"], "secure_examples": ["logger.info('User login attempt with credentials: ' + maskCredentials(user.getCredentials()));", "logger.debug('Payment details: ' + maskPaymentDetails(payment.getDetails()));"], "verification_steps": ["Review logging configuration to ensure sensitive data is not logged in plaintext.", "Check that sensitive data is either masked or hashed before logging.", "Ensure that logging practices are documented and align with data protection policies.", "Conduct a code review to identify any instances of sensitive data being logged improperly."], "common_mistakes": ["Logging sensitive data without any form of protection.", "Failing to implement masking or hashing for session tokens.", "Assuming that logging at a lower level (e.g., debug) is safe for sensitive data."], "related_cwe": ["CWE-532: Insertion of Sensitive Information into Log File", "CWE-200: Information Exposure"], "related_capec": ["CAPEC-125: Log Injection", "CAPEC-131: Credential Dumping"], "attack_flow": "An attacker may exploit improper logging practices by gaining access to log files that contain sensitive information. If sensitive data such as credentials or payment details are logged in plaintext, the attacker can easily read and misuse this information. Even if session tokens are logged without protection, an attacker could hijack a user's session by obtaining these tokens from the logs."}
{"chapter_id": "V16", "chapter_name": "Security Logging and Error Handling", "section_id": "V16.3", "section_name": "Security Events", "req_id": "V16.3.1", "req_description": "Verify that all authentication operations are logged, including successful and unsuccessful attempts. Additional metadata, such as the type of authentication or factors used, should also be collected.", "level": 2, "explanation": "This requirement emphasizes the importance of logging all authentication activities to ensure that both successful and failed attempts are recorded. This logging should include relevant metadata, such as the method of authentication (e.g., password, multi-factor authentication) and any factors used (e.g., device information, IP address). This information is crucial for auditing, monitoring, and incident response.", "threats_mitigated": ["Brute force attacks", "Credential stuffing", "Account takeover", "Unauthorized access attempts"], "insecure_examples": ["if (authSuccess) { /* no logging */ } else { /* no logging */ }", "logger.info('User attempted to log in');"], "secure_examples": ["logger.info('User login attempt', { userId: username, success: authSuccess, method: 'password', ipAddress: request.ip });", "logger.error('Failed login attempt', { userId: username, method: 'MFA', ipAddress: request.ip });"], "verification_steps": ["Check that logs are generated for both successful and unsuccessful authentication attempts.", "Verify that logs include relevant metadata (e.g., user ID, authentication method, IP address).", "Ensure that logs are stored securely and are not tampered with.", "Review log retention policies to confirm compliance with organizational standards."], "common_mistakes": ["Failing to log unsuccessful login attempts.", "Not including sufficient metadata in the logs.", "Logging sensitive information (e.g., passwords) instead of relevant metadata.", "Not securing log files against unauthorized access."], "related_cwe": ["CWE-778: Insufficient Logging", "CWE-532: Insertion of Sensitive Information into Log File"], "related_capec": ["CAPEC-148: Brute Force Login", "CAPEC-155: Account Lockout Attack"], "attack_flow": "An attacker may attempt to gain unauthorized access by repeatedly trying different credentials (brute force attack). If authentication attempts are not logged, the attacker can continue without detection. By logging these attempts, security teams can identify patterns of abuse, trigger alerts, and take necessary actions to secure the account."}
{"chapter_id": "V16", "chapter_name": "Security Logging and Error Handling", "section_id": "V16.3", "section_name": "Security Events", "req_id": "V16.3.2", "req_description": "Verify that failed authorization attempts are logged. For L3, this must include logging all authorization decisions, including logging when sensitive data is accessed (without logging the sensitive data itself).", "level": 2, "explanation": "This requirement emphasizes the importance of logging failed authorization attempts to help detect potential security breaches. It mandates that all authorization decisions be logged, especially when sensitive data is accessed, ensuring that security teams can audit and respond to unauthorized access attempts effectively. However, sensitive data itself must not be logged to prevent exposure of that data in logs.", "threats_mitigated": ["Unauthorized access attempts", "Brute force attacks", "Insider threats", "Data exfiltration"], "insecure_examples": ["if (!user.hasAccess()) { /* No logging */ }", "logger.log('User attempted to access sensitive data'); // Sensitive data logged"], "secure_examples": ["if (!user.hasAccess()) { logger.log('Failed authorization attempt for user: ' + user.getId()); }", "logger.log('User attempted to access sensitive data without logging the data itself');"], "verification_steps": ["Check that failed authorization attempts are logged.", "Verify that logs include relevant information such as user ID and timestamp.", "Ensure that sensitive data is not included in the logs.", "Review logs for completeness of authorization decision logging."], "common_mistakes": ["Failing to log failed authorization attempts.", "Logging sensitive data directly instead of logging access attempts.", "Not including sufficient context in logs (e.g., user IDs, timestamps)."], "related_cwe": ["CWE-778: Insufficient Logging", "CWE-532: Insertion of Sensitive Information into Log File"], "related_capec": ["CAPEC-139: Brute Force Attack", "CAPEC-157: Credential Stuffing"], "attack_flow": "An attacker may attempt to gain unauthorized access by guessing credentials. If failed attempts are not logged, the attacker can continue without detection. However, if logging is implemented, each failed attempt is recorded, allowing security teams to notice patterns, potentially block the attacker, and investigate the source of the attempts."}
{"chapter_id": "V16", "chapter_name": "Security Logging and Error Handling", "section_id": "V16.3", "section_name": "Security Events", "req_id": "V16.3.3", "req_description": "Verify that the application logs the security events that are defined in the documentation and also logs attempts to bypass the security controls, such as input validation, business logic, and anti-automation.", "level": 2, "explanation": "This requirement emphasizes the importance of logging security-related events in an application. It mandates that developers implement logging for specific security events, as outlined in the application's security documentation. Additionally, it requires logging of any attempts to bypass security controls, which can provide insights into potential vulnerabilities and attack vectors. Proper logging helps in monitoring, auditing, and responding to security incidents effectively.", "threats_mitigated": ["Unauthorized access attempts", "Bypass of security controls", "Data breaches", "Denial of Service (DoS) attacks", "Injection attacks"], "insecure_examples": [{"code": "if (userInput == 'admin') {\n    // No logging of access attempt\n    grantAccess();\n}"}, {"code": "function validateInput(input) {\n    // No logging of validation failure\n    return input == expectedValue;\n}"}], "secure_examples": [{"code": "if (userInput == 'admin') {\n    logEvent('Access attempt by user: ' + userInput);\n    grantAccess();\n}"}, {"code": "function validateInput(input) {\n    if (input != expectedValue) {\n        logEvent('Validation failed for input: ' + input);\n        return false;\n    }\n    return true;\n}"}], "verification_steps": ["Review the logging configuration to ensure security events are defined.", "Check that logs are generated for all defined security events.", "Verify that attempts to bypass security controls are logged.", "Ensure logs include sufficient detail for forensic analysis.", "Confirm that logs are protected from unauthorized access and tampering."], "common_mistakes": ["Failing to log all relevant security events.", "Not logging attempts to bypass security controls.", "Insufficient detail in logs to understand the context of events.", "Ignoring log retention policies and not securing logs properly."], "related_cwe": ["CWE-778: Insufficient Logging", "CWE-117: Improper Output Neutralization for Logs", "CWE-200: Information Exposure"], "related_capec": ["CAPEC-132: Log Injection", "CAPEC-144: Bypass Authentication Mechanism", "CAPEC-148: Bypass Security Controls"], "attack_flow": "An attacker may attempt to exploit vulnerabilities in the application by bypassing security controls, such as input validation. If these attempts are not logged, the application may not have visibility into the attack, allowing the attacker to continue their malicious activities undetected. Logging these events can help security teams identify and respond to attacks in a timely manner."}
{"chapter_id": "V16", "chapter_name": "Security Logging and Error Handling", "section_id": "V16.3", "section_name": "Security Events", "req_id": "V16.3.4", "req_description": "Verify that the application logs unexpected errors and security control failures such as backend TLS failures.", "level": "2", "explanation": "This requirement emphasizes the importance of logging unexpected errors and failures in security controls. Proper logging helps in identifying issues and potential security breaches by providing a record of events that can be analyzed later. It is crucial for maintaining the integrity of the application and for forensic analysis in the event of a security incident.", "threats_mitigated": ["Unauthorized access", "Data breaches", "Denial of Service (DoS)", "Man-in-the-Middle (MitM) attacks"], "insecure_examples": ["logger.error('An unexpected error occurred');", "logger.info('TLS connection established');"], "secure_examples": ["logger.error('Unexpected error: ' + error.message + ' at ' + new Date().toISOString());", "logger.error('TLS failure: ' + tlsErrorDetails + ' at ' + new Date().toISOString());"], "verification_steps": ["Check that the application has logging enabled for unexpected errors.", "Verify that security control failures are logged appropriately.", "Review logs to ensure they contain relevant details such as timestamps and error messages.", "Ensure logs are stored securely and are not accessible to unauthorized users."], "common_mistakes": ["Failing to log security-related events.", "Logging sensitive information in error messages.", "Not including sufficient context in logs for troubleshooting.", "Neglecting to monitor logs for anomalies."], "related_cwe": ["CWE-778: Insufficient Logging", "CWE-117: Improper Output Neutralization for Logs"], "related_capec": ["CAPEC-118: Log Injection", "CAPEC-156: Log File Manipulation"], "attack_flow": "An attacker may exploit a lack of logging by performing actions that trigger unexpected errors or security failures without detection. If these events are not logged, the attacker can operate undetected, potentially leading to further exploitation of the application or access to sensitive data."}
{"chapter_id": "V16", "chapter_name": "Security Logging and Error Handling", "section_id": "V16.4", "section_name": "Log Protection", "req_id": "V16.4.1", "req_description": "Verify that all logging components appropriately encode data to prevent log injection.", "level": "2", "explanation": "This requirement mandates that any data being logged should be properly encoded to avoid the risk of log injection attacks. Log injection occurs when an attacker is able to manipulate log files by injecting malicious content, which can lead to misleading logs, denial of service, or even further attacks if logs are parsed or analyzed improperly. Proper encoding ensures that special characters in the log data do not interfere with the log format or structure.", "threats_mitigated": ["Log Injection", "Denial of Service via log manipulation", "Information Disclosure through misleading logs"], "insecure_examples": [{"code": "logger.info('User input: ' + userInput);"}, {"code": "logger.error('Error occurred: ' + errorMessage);"}], "secure_examples": [{"code": "logger.info('User input: ' + encodeForLog(userInput));"}, {"code": "logger.error('Error occurred: ' + encodeForLog(errorMessage));"}], "verification_steps": ["Review logging code for proper encoding mechanisms.", "Check that all user inputs are sanitized before logging.", "Ensure that logging libraries or frameworks used have built-in protections against log injection.", "Test logging output to verify that special characters are correctly encoded."], "common_mistakes": ["Failing to sanitize user input before logging.", "Using string concatenation for log messages without encoding.", "Neglecting to review third-party logging libraries for security features."], "related_cwe": ["CWE-117: Improper Output Encoding or Escaping", "CWE-20: Improper Input Validation"], "related_capec": ["CAPEC-153: Log Injection", "CAPEC-154: Log Forging"], "attack_flow": "An attacker submits specially crafted input that includes control characters or log formatting characters. If the application logs this input without proper encoding, the attacker can manipulate the log output. This can lead to confusion in log analysis, hiding their tracks, or even triggering alerts based on misleading log entries."}
{"chapter_id": "V16", "chapter_name": "Security Logging and Error Handling", "section_id": "V16.4", "section_name": "Log Protection", "req_id": "V16.4.2", "req_description": "Verify that logs are protected from unauthorized access and cannot be modified.", "level": 2, "explanation": "This requirement ensures that logs, which may contain sensitive information about application behavior and user actions, are secured against unauthorized access and tampering. Proper log protection helps maintain the integrity and confidentiality of log data, which is crucial for incident response and forensic investigations.", "threats_mitigated": ["Unauthorized access to sensitive log data", "Log tampering", "Data leakage through logs"], "insecure_examples": [{"code": "log_file = open('/var/log/app.log', 'a'); log_file.write('User logged in'); log_file.close()"}, {"code": "chmod 777 /var/log/app.log"}], "secure_examples": [{"code": "log_file = open('/var/log/app.log', 'a'); log_file.write('User logged in'); log_file.close()", "note": "Ensure proper file permissions are set to restrict access."}, {"code": "chmod 640 /var/log/app.log"}], "verification_steps": ["Check file permissions on log files to ensure they are restricted to authorized users.", "Verify that logs are stored in a secure location.", "Ensure that log files are not writable by unauthorized users.", "Review access controls and audit logs for any unauthorized access attempts."], "common_mistakes": ["Setting overly permissive file permissions on log files.", "Failing to rotate logs regularly, leading to excessive log file sizes.", "Not implementing proper access controls for log files."], "related_cwe": ["CWE-732", "CWE-276", "CWE-22"], "related_capec": ["CAPEC-143", "CAPEC-153"], "attack_flow": "An attacker gains unauthorized access to the server where logs are stored. They exploit weak file permissions to read sensitive log data, which may contain user credentials or application vulnerabilities. If the attacker can also modify logs, they could erase traces of their activities, making it difficult for the security team to detect and respond to the breach."}
{"chapter_id": "V16", "chapter_name": "Security Logging and Error Handling", "section_id": "V16.4", "section_name": "Log Protection", "req_id": "V16.4.3", "req_description": "Verify that logs are securely transmitted to a logically separate system for analysis, detection, alerting, and escalation. The aim is to ensure that if the application is breached, the logs are not compromised.", "level": 2, "explanation": "This requirement emphasizes the importance of securely transmitting logs to a separate system, which helps in maintaining the integrity and confidentiality of the logs. If logs are compromised during transmission, attackers can erase their tracks or manipulate log data. Secure transmission methods, such as TLS, should be employed to protect the logs from interception or tampering.", "threats_mitigated": ["Log tampering", "Data interception during transmission", "Unauthorized access to log data"], "insecure_examples": ["logger.info('User logged in'); // Logs sent over HTTP without encryption", "File log.write('Error occurred'); // Logs written to a local file without secure transmission"], "secure_examples": ["logger.info('User logged in'); // Logs sent over HTTPS to a secure logging server", "secureLogTransport.send('Error occurred', 'https://secure-log-server'); // Using secure transport for log transmission"], "verification_steps": ["Check that logs are transmitted using secure protocols (e.g., HTTPS, TLS).", "Verify that logs are sent to a separate logging server.", "Ensure that access controls are in place on the logging server.", "Review configurations to confirm that logs are not stored locally without encryption."], "common_mistakes": ["Using unencrypted channels for log transmission.", "Storing logs on the same server as the application.", "Neglecting to implement access controls on log files."], "related_cwe": ["CWE-532: Information Exposure Through Log Files", "CWE-319: Cleartext Transmission of Sensitive Information"], "related_capec": ["CAPEC-137: Log Injection", "CAPEC-159: Log Forging"], "attack_flow": "An attacker gains access to the application and tries to exploit vulnerabilities. If logs are transmitted insecurely, the attacker can intercept the logs during transmission, allowing them to erase or modify log entries, thereby covering their tracks and making it difficult for security teams to detect the breach."}
{"chapter_id": "V16", "chapter_name": "Security Logging and Error Handling", "section_id": "V16.5", "section_name": "Error Handling", "req_id": "V16.5.1", "req_description": "Verify that a generic message is returned to the consumer when an unexpected or security-sensitive error occurs, ensuring no exposure of sensitive internal system data such as stack traces, queries, secret keys, and tokens.", "level": 2, "explanation": "This requirement mandates that applications should not disclose detailed error information to users, particularly in production environments. Instead, a generic error message should be displayed to prevent attackers from gaining insights into the application's internals, which could be exploited for further attacks. This includes suppressing stack traces, database queries, and any sensitive information that could aid an attacker.", "threats_mitigated": ["Information Disclosure", "Stack Trace Exposure", "Injection Attacks", "Credential Theft"], "insecure_examples": [{"code": "throw new Exception('Database connection failed: ' . $e->getMessage());"}, {"code": "return json_encode(['error' => 'Invalid input: ' . $input]);"}], "secure_examples": [{"code": "throw new Exception('An unexpected error occurred. Please try again later.');"}, {"code": "return json_encode(['error' => 'Invalid input.']);"}], "verification_steps": ["Review error handling code to ensure generic messages are returned.", "Check logs to confirm that sensitive information is not logged.", "Test the application to trigger errors and verify the response messages.", "Ensure that no stack traces or detailed error messages are exposed in the user interface."], "common_mistakes": ["Returning detailed error messages that include stack traces or SQL queries.", "Logging sensitive information without proper controls.", "Failing to sanitize error messages before displaying them to the user."], "related_cwe": ["CWE-209", "CWE-200", "CWE-117"], "related_capec": ["CAPEC-137", "CAPEC-155"], "attack_flow": "An attacker triggers an error in the application, which results in a detailed error message being displayed or logged. This message may contain sensitive information such as stack traces or database queries, which the attacker can use to understand the application's architecture and identify potential vulnerabilities for exploitation."}
{"chapter_id": "V16", "chapter_name": "Security Logging and Error Handling", "section_id": "V16.5", "section_name": "Error Handling", "req_id": "V16.5.2", "req_description": "Verify that the application continues to operate securely when external resource access fails, for example, by using patterns such as circuit breakers or graceful degradation.", "level": 2, "explanation": "This requirement emphasizes the importance of maintaining application security and functionality in the event of failures when accessing external resources, such as databases, APIs, or third-party services. Implementing patterns like circuit breakers can prevent cascading failures, while graceful degradation ensures that core functionalities remain available even when certain features are compromised.", "threats_mitigated": ["Denial of Service (DoS)", "Data Leakage", "Security Misconfiguration"], "insecure_examples": [{"code": "fetchData() {\n  const response = externalService.call();\n  return response.data;\n}"}, {"code": "function getUserData() {\n  const data = api.getUser();\n  if (!data) {\n    throw new Error('Failed to fetch user data');\n  }\n  return data;\n}"}], "secure_examples": [{"code": "fetchData() {\n  try {\n    const response = externalService.call();\n    return response.data;\n  } catch (error) {\n    // Handle error gracefully\n    return defaultData;\n  }\n}"}, {"code": "function getUserData() {\n  try {\n    const data = api.getUser();\n    return data;\n  } catch (error) {\n    // Fallback to cached data or default\n    return cachedData;\n  }\n}"}], "verification_steps": ["Review error handling code for external resource access.", "Check for implementation of circuit breakers or fallback mechanisms.", "Test application behavior during external resource failures.", "Ensure that sensitive information is not exposed in error messages."], "common_mistakes": ["Failing to handle exceptions when accessing external resources.", "Not implementing fallback mechanisms for critical services.", "Exposing sensitive information in error messages."], "related_cwe": ["CWE-754: Improper Check for Unusual or Exceptional Conditions", "CWE-703: Improper Check or Handling of Exceptional Conditions"], "related_capec": ["CAPEC-139: Exploiting Error Handling Mechanisms", "CAPEC-147: Denial of Service via Resource Exhaustion"], "attack_flow": "An attacker may exploit the application's failure to handle external resource access securely by causing the external service to become unavailable. This could lead to a denial of service, where the application crashes or becomes unresponsive. If error messages reveal sensitive information, the attacker may gain insights into the application's architecture or vulnerabilities, potentially leading to further exploits."}
{"chapter_id": "V16", "chapter_name": "Security Logging and Error Handling", "section_id": "V16.5", "section_name": "Error Handling", "req_id": "V16.5.3", "req_description": "Verify that the application fails gracefully and securely, including when an exception occurs, preventing fail-open conditions such as processing a transaction despite errors resulting from validation logic.", "level": "2", "explanation": "This requirement emphasizes the importance of handling errors in a way that does not expose sensitive information or allow the application to continue operating in an erroneous state. It mandates that applications should not proceed with operations if there are validation errors, ensuring that the integrity of transactions and user data is maintained.", "threats_mitigated": ["Data corruption", "Unauthorized access", "Denial of service", "Information leakage"], "insecure_examples": [{"code": "if (transaction.isValid()) {\n    processTransaction(transaction);\n} else {\n    // Log error but continue processing\n    logError(transaction.getErrors());\n}"}, {"code": "try {\n    performSensitiveOperation();\n} catch (Exception e) {\n    // Ignore exception and continue\n}"}], "secure_examples": [{"code": "if (transaction.isValid()) {\n    processTransaction(transaction);\n} else {\n    logError(transaction.getErrors());\n    throw new ValidationException(\"Transaction is invalid.\");\n}"}, {"code": "try {\n    performSensitiveOperation();\n} catch (Exception e) {\n    logError(e);\n    throw new OperationFailedException(\"Operation failed due to an error.\");\n}"}], "verification_steps": ["Review error handling logic in the application.", "Ensure that exceptions are logged appropriately without exposing sensitive information.", "Check that the application does not continue processing transactions when validation errors occur.", "Test the application to confirm that it fails gracefully under error conditions."], "common_mistakes": ["Failing to log errors properly, leading to loss of critical debugging information.", "Allowing the application to continue processing despite validation errors.", "Exposing sensitive information in error messages returned to users."], "related_cwe": ["CWE-390", "CWE-754", "CWE-775"], "related_capec": ["CAPEC-137", "CAPEC-138"], "attack_flow": "An attacker may exploit this requirement by intentionally submitting invalid data to the application. If the application fails to handle this gracefully and continues processing transactions, the attacker could manipulate the system into performing unauthorized actions or corrupting data, leading to potential data breaches or financial loss."}
{"chapter_id": "V16", "chapter_name": "Security Logging and Error Handling", "section_id": "V16.5", "section_name": "Error Handling", "req_id": "V16.5.4", "req_description": "Verify that a 'last resort' error handler is defined which will catch all unhandled exceptions. This is both to avoid losing error details that must go to log files and to ensure that an error does not take down the entire application process, leading to a loss of availability.", "level": 3, "explanation": "A last resort error handler is a critical component in an application's error management strategy. It ensures that any unhandled exceptions are caught and processed properly, preventing the application from crashing and allowing for logging of error details for further investigation. This handler should provide a fallback mechanism that logs error information and returns a user-friendly message without exposing sensitive information.", "threats_mitigated": ["Application crashes", "Denial of Service (DoS)", "Information leakage through error messages"], "insecure_examples": ["try {\n    // code that may throw an exception\n} catch (Exception e) {\n    // no catch-all handler\n}", "public void processRequest() {\n    // missing global error handler\n}"], "secure_examples": ["public void processRequest() {\n    try {\n        // code that may throw an exception\n    } catch (Exception e) {\n        logError(e);\n        showFriendlyErrorMessage();\n    }\n}", "setErrorHandler(new LastResortErrorHandler());"], "verification_steps": ["Check if a global error handler is implemented.", "Verify that the error handler logs all unhandled exceptions.", "Ensure that the error handler does not expose sensitive information to users.", "Test the application to trigger unhandled exceptions and verify the error handling behavior."], "common_mistakes": ["Failing to implement a global error handler.", "Logging sensitive information in error messages.", "Not providing user-friendly error messages.", "Ignoring unhandled exceptions."], "related_cwe": ["CWE-390", "CWE-754", "CWE-209"], "related_capec": ["CAPEC-137", "CAPEC-155"], "attack_flow": "An attacker may trigger an unhandled exception by sending unexpected input to the application. If the application lacks a last resort error handler, this could lead to a crash, denying service to legitimate users. Additionally, if error details are not logged, the attacker may exploit the vulnerability further without detection."}
{"chapter_id": "V17", "chapter_name": "WebRTC", "section_id": "V17.1", "section_name": "TURN Server", "req_id": "V17.1.1", "req_description": "Verify that the Traversal Using Relays around NAT (TURN) service only allows access to IP addresses that are not reserved for special purposes (e.g., internal networks, broadcast, loopback). Note that this applies to both IPv4 and IPv6 addresses.", "level": "2", "explanation": "This requirement ensures that the TURN server does not expose itself to internal or reserved IP addresses which could lead to unauthorized access or misuse. By restricting access to only valid public IP addresses, the server minimizes the risk of attacks that exploit internal network vulnerabilities.", "threats_mitigated": ["Unauthorized access to TURN services", "Information disclosure through internal IP exposure", "Denial of Service (DoS) attacks from misconfigured internal networks"], "insecure_examples": ["if (isReservedIP(clientIP)) { denyAccess(); }", "allowAccess(clientIP); // No check for reserved IPs"], "secure_examples": ["if (!isReservedIP(clientIP)) { allowAccess(clientIP); }", "denyAccess(); // Explicitly deny access if IP is reserved"], "verification_steps": ["Review the TURN server configuration for IP access controls.", "Check the implementation of IP validation logic.", "Conduct penetration testing to verify that reserved IP addresses are blocked."], "common_mistakes": ["Failing to check both IPv4 and IPv6 reserved IPs.", "Implementing IP checks in a way that can be easily bypassed.", "Not updating the list of reserved IPs as standards evolve."], "related_cwe": ["CWE-20: Improper Input Validation", "CWE-200: Information Exposure", "CWE-284: Improper Access Control"], "related_capec": ["CAPEC-6: IP Spoofing", "CAPEC-31: Network Packet Injection", "CAPEC-133: Exploiting Misconfigured Network Services"], "attack_flow": "An attacker could send requests to the TURN server from a reserved IP address. If the server does not properly validate the source IP, the attacker could gain unauthorized access to the TURN service, allowing them to relay traffic or intercept communications, leading to potential data breaches or service disruptions."}
{"chapter_id": "V17", "chapter_name": "WebRTC", "section_id": "V17.1", "section_name": "TURN Server", "req_id": "V17.1.2", "req_description": "Verify that the Traversal Using Relays around NAT (TURN) service is not susceptible to resource exhaustion when legitimate users attempt to open a large number of ports on the TURN server.", "level": "3", "explanation": "This requirement ensures that the TURN server can handle multiple simultaneous connections from legitimate users without becoming overwhelmed. Resource exhaustion can occur if too many ports are opened, leading to denial of service for legitimate users. Proper limits and monitoring should be in place to prevent abuse.", "threats_mitigated": ["Denial of Service (DoS)", "Resource exhaustion attacks", "Service disruption"], "insecure_examples": [{"code": "while (true) { openPort(); } // No limit on the number of ports opened"}, {"code": "for (int i = 0; i < Integer.MAX_VALUE; i++) { openPort(); } // Attempting to open an infinite number of ports"}], "secure_examples": [{"code": "for (int i = 0; i < MAX_PORTS; i++) { openPort(); } // Limit the number of ports opened"}, {"code": "if (currentOpenPorts < MAX_ALLOWED_PORTS) { openPort(); } // Check current usage before opening a new port"}], "verification_steps": ["Review the TURN server configuration for port limits.", "Test the server with multiple simultaneous connection requests.", "Monitor server resource usage during high load scenarios.", "Check for logging of connection attempts and resource usage."], "common_mistakes": ["Failing to implement limits on the number of concurrent connections.", "Not monitoring server resource usage effectively.", "Ignoring potential abuse scenarios from legitimate users."], "related_cwe": ["CWE-400", "CWE-770"], "related_capec": ["CAPEC-118", "CAPEC-137"], "attack_flow": "An attacker may exploit this requirement by sending a large number of connection requests to the TURN server, attempting to open multiple ports. If the server does not have limits in place, it may exhaust its resources, leading to denial of service for legitimate users. This could result in the server becoming unresponsive or crashing, thereby disrupting service."}
{"chapter_id": "V17", "chapter_name": "WebRTC", "section_id": "V17.2", "section_name": "Media", "req_id": "V17.2.1", "req_description": "Verify that the key for the Datagram Transport Layer Security (DTLS) certificate is managed and protected based on the documented policy for management of cryptographic keys.", "level": "2", "explanation": "This requirement emphasizes the importance of securely managing the cryptographic keys used in DTLS, which is essential for establishing secure communications in WebRTC applications. Proper key management includes generating, storing, using, and destroying keys in accordance with established policies to prevent unauthorized access and ensure data integrity and confidentiality.", "threats_mitigated": ["Man-in-the-middle attacks", "Eavesdropping", "Data tampering", "Key compromise"], "insecure_examples": [{"code": "const dtlsKey = 'my-insecure-key'; // Hardcoded key in source code"}, {"code": "let dtlsKey = getKeyFromInsecureStorage(); // Key retrieved from an insecure location"}], "secure_examples": [{"code": "const dtlsKey = getKeyFromSecureStorage(); // Key retrieved from a secure vault"}, {"code": "const dtlsKey = generateKey(); // Key generated dynamically using a secure algorithm"}], "verification_steps": ["Check that cryptographic keys are not hardcoded in the source code.", "Verify that keys are stored in a secure key management system.", "Ensure that key rotation policies are in place and followed.", "Review access controls to ensure only authorized personnel can access the keys.", "Confirm that keys are destroyed securely when no longer needed."], "common_mistakes": ["Hardcoding keys in the application code.", "Using weak or outdated cryptographic algorithms.", "Failing to implement key rotation and expiration policies.", "Storing keys in plaintext or insecure locations."], "related_cwe": ["CWE-321: Use of Hard-coded Cryptographic Key", "CWE-312: Cleartext Storage of Sensitive Information", "CWE-330: Use of Insufficiently Random Values"], "related_capec": ["CAPEC-100: Key Recovery Attack", "CAPEC-105: Cryptographic Key Compromise"], "attack_flow": "An attacker may exploit weaknesses in the management of DTLS keys by gaining access to hardcoded or poorly protected keys. Once the key is compromised, the attacker can decrypt sensitive communications, impersonate legitimate users, or manipulate data in transit, leading to unauthorized access and data breaches."}
{"chapter_id": "V17", "chapter_name": "WebRTC", "section_id": "V17.2", "section_name": "Media", "req_id": "V17.2.2", "req_description": "Verify that the media server is configured to use and support approved Datagram Transport Layer Security (DTLS) cipher suites and a secure protection profile for the DTLS Extension for establishing keys for the Secure Real-time Transport Protocol (DTLS-SRTP).", "level": "2", "explanation": "This requirement ensures that the media server implements strong encryption protocols to protect media streams during transmission. DTLS is a protocol that provides the same security guarantees as TLS but is designed for datagram-based applications. By using approved cipher suites and secure protection profiles, the media server can prevent eavesdropping, tampering, and man-in-the-middle attacks on the media streams.", "threats_mitigated": ["Eavesdropping", "Man-in-the-Middle Attacks", "Data Tampering"], "insecure_examples": [{"code_snippet": "mediaServer.setDTLSConfig({ cipherSuites: ['NULL', 'RC4'] });"}, {"code_snippet": "mediaServer.enableSRTP(false);"}], "secure_examples": [{"code_snippet": "mediaServer.setDTLSConfig({ cipherSuites: ['TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256', 'TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384'] });"}, {"code_snippet": "mediaServer.enableSRTP(true);"}], "verification_steps": ["Check the media server configuration for DTLS cipher suites.", "Ensure only approved cipher suites are enabled.", "Verify that DTLS-SRTP is enabled in the media server settings.", "Conduct a security assessment to test for vulnerabilities in the media stream."], "common_mistakes": ["Using weak or deprecated cipher suites.", "Not enabling DTLS-SRTP, leaving media streams unprotected.", "Failing to regularly update cipher suites as new vulnerabilities are discovered."], "related_cwe": ["CWE-319", "CWE-326", "CWE-295"], "related_capec": ["CAPEC-32", "CAPEC-66"], "attack_flow": "An attacker can intercept the media stream if the DTLS configuration is weak or misconfigured. By exploiting vulnerabilities in the cipher suites, the attacker can decrypt the media data, allowing them to eavesdrop on conversations or manipulate the media stream, leading to potential data breaches or unauthorized access."}
{"chapter_id": "V17", "chapter_name": "WebRTC", "section_id": "V17.2", "section_name": "Media", "req_id": "V17.2.3", "req_description": "Verify that Secure Real-time Transport Protocol (SRTP) authentication is checked at the media server to prevent Real-time Transport Protocol (RTP) injection attacks from leading to either a Denial of Service condition or audio or video media insertion into media streams.", "level": "2", "explanation": "This requirement emphasizes the importance of ensuring that the media server implements proper authentication checks for SRTP. Without these checks, an attacker could inject malicious RTP packets into the media stream, potentially disrupting service (Denial of Service) or inserting unauthorized audio or video content into the stream, which can lead to privacy violations or misinformation.", "threats_mitigated": ["RTP injection attacks", "Denial of Service (DoS)", "Unauthorized media insertion"], "insecure_examples": [{"code": "rtpStream.setAuthentication(false);"}, {"code": "mediaServer.allowAllRTPPackets();"}], "secure_examples": [{"code": "rtpStream.setAuthentication(true);"}, {"code": "mediaServer.verifyRTPPacketIntegrity();"}], "verification_steps": ["Check that SRTP authentication is enabled on the media server.", "Review the media server configuration for proper RTP packet validation.", "Test the media server with various RTP packet scenarios to ensure it rejects unauthorized packets.", "Conduct penetration testing to simulate RTP injection attacks."], "common_mistakes": ["Failing to enable SRTP authentication.", "Using default configurations that do not validate RTP packets.", "Assuming that media streams are secure without implementing additional checks."], "related_cwe": ["CWE-20: Improper Input Validation", "CWE-284: Improper Access Control", "CWE-400: Uncontrolled Resource Consumption"], "related_capec": ["CAPEC-135: RTP Injection Attack", "CAPEC-146: Media Stream Manipulation"], "attack_flow": "An attacker sends crafted RTP packets to the media server without proper authentication checks. If the server accepts these packets, the attacker can inject unwanted media into the stream or exhaust server resources, leading to service disruption. This can result in unauthorized content being broadcasted or a complete denial of service for legitimate users."}
{"chapter_id": "V17", "chapter_name": "WebRTC", "section_id": "V17.2", "section_name": "Media", "req_id": "V17.2.4", "req_description": "Verify that the media server is able to continue processing incoming media traffic when encountering malformed Secure Real-time Transport Protocol (SRTP) packets.", "level": "2", "explanation": "This requirement ensures that the media server can handle malformed SRTP packets gracefully without disrupting the overall media streaming service. It is critical for maintaining service availability and ensuring that legitimate media traffic can continue uninterrupted even when faced with potentially malicious or erroneous packets.", "threats_mitigated": ["Denial of Service (DoS)", "Service disruption due to malformed packets", "Exploitation of media server vulnerabilities"], "insecure_examples": [{"code": "if (isMalformedSRTP(packet)) { throw new Exception('Malformed packet'); }"}, {"code": "mediaServer.process(packet);"}], "secure_examples": [{"code": "if (isMalformedSRTP(packet)) { logWarning('Malformed packet received, continuing processing.'); } else { mediaServer.process(packet); }"}, {"code": "try { mediaServer.process(packet); } catch (MalformedPacketException e) { logWarning('Ignoring malformed packet.'); }"}], "verification_steps": ["Review the media server's handling of SRTP packets.", "Check logs for any warnings or errors related to malformed packets.", "Test the media server with crafted malformed SRTP packets to observe behavior.", "Ensure that legitimate media traffic is processed without interruption."], "common_mistakes": ["Throwing exceptions or terminating processes on encountering malformed packets.", "Failing to log or handle errors gracefully.", "Not testing the media server against malformed packet scenarios."], "related_cwe": ["CWE-20", "CWE-399"], "related_capec": ["CAPEC-151", "CAPEC-163"], "attack_flow": "An attacker sends malformed SRTP packets to the media server. If the server does not handle these packets correctly, it may crash or stop processing legitimate media traffic, leading to a denial of service. By ensuring proper handling of such packets, the server can log the incidents and continue functioning normally."}
{"chapter_id": "V17", "chapter_name": "WebRTC", "section_id": "V17.2", "section_name": "Media", "req_id": "V17.2.5", "req_description": "Verify that the media server is able to continue processing incoming media traffic during a flood of Secure Real-time Transport Protocol (SRTP) packets from legitimate users.", "level": 3, "explanation": "This requirement ensures that the media server can handle a high volume of incoming SRTP packets without degrading performance or losing legitimate media streams. It is crucial for maintaining service availability and ensuring a smooth user experience, especially during peak usage times or under attack scenarios.", "threats_mitigated": ["Denial of Service (DoS) attacks", "Flooding attacks", "Service degradation due to high traffic"], "insecure_examples": ["if (incomingPackets > MAX_PACKETS) { dropPackets(); }", "mediaServer.process(incomingPacket); // No rate limiting or flood protection"], "secure_examples": ["if (incomingPackets <= MAX_PACKETS) { mediaServer.process(incomingPacket); } else { throttleTraffic(); }", "mediaServer.process(incomingPacket); // Implemented rate limiting and flood protection"], "verification_steps": ["Review the media server configuration for traffic handling capabilities.", "Test the server with simulated flood traffic to ensure it maintains performance.", "Check logs for any dropped packets during high traffic scenarios.", "Evaluate the implementation of rate limiting and flood protection mechanisms."], "common_mistakes": ["Failing to implement rate limiting on incoming SRTP packets.", "Not testing the media server under load conditions.", "Assuming that legitimate traffic will not flood the server."], "related_cwe": ["CWE-400: Uncontrolled Resource Consumption", "CWE-770: Allocation of Resources Without Limits"], "related_capec": ["CAPEC-153: Flooding Attack", "CAPEC-132: Resource Exhaustion Attack"], "attack_flow": "An attacker sends a large volume of SRTP packets to the media server, overwhelming its capacity. If the server does not have proper flood protection, it may start dropping legitimate packets, leading to service disruption for users. This can result in degraded audio/video quality or complete service outages."}
{"chapter_id": "V17", "chapter_name": "WebRTC", "section_id": "V17.2", "section_name": "Media", "req_id": "V17.2.6", "req_description": "Verify that the media server is not susceptible to the 'ClientHello' Race Condition vulnerability in Datagram Transport Layer Security (DTLS) by checking if the media server is publicly known to be vulnerable or by performing the race condition test.", "level": "3", "explanation": "This requirement emphasizes the need to ensure that the media server used in WebRTC applications is not vulnerable to the ClientHello race condition, which can allow an attacker to exploit the DTLS handshake process. By verifying the server's vulnerability status, developers can prevent potential attacks that could compromise the integrity and confidentiality of media streams.", "threats_mitigated": ["Denial of Service (DoS)", "Man-in-the-Middle (MitM) attacks", "Data leakage during media transmission"], "insecure_examples": [{"code": "if (isVulnerable(mediaServer)) { /* No action taken */ }"}, {"code": "performDTLSTest(mediaServer); // Not checking results"}], "secure_examples": [{"code": "if (!isVulnerable(mediaServer)) { /* Proceed with secure connection */ }"}, {"code": "if (performDTLSTest(mediaServer)) { alert('Vulnerable!'); }"}], "verification_steps": ["Check the media server's documentation for known vulnerabilities.", "Conduct a race condition test on the media server.", "Review security advisories related to the media server.", "Ensure that the server's DTLS implementation is up-to-date."], "common_mistakes": ["Assuming that all media servers are secure without verification.", "Neglecting to perform security tests on the media server.", "Failing to monitor for updates regarding vulnerabilities."], "related_cwe": ["CWE-20: Improper Input Validation", "CWE-295: Improper Certificate Validation", "CWE-754: Improper Checking for Uniqueness"], "related_capec": ["CAPEC-171: Man-in-the-Middle Attack", "CAPEC-134: Denial of Service via Resource Exhaustion", "CAPEC-148: Exploiting Race Conditions"], "attack_flow": "An attacker can exploit the ClientHello race condition by sending multiple ClientHello messages to the media server, attempting to manipulate the DTLS handshake process. If the server is vulnerable, it may accept a malicious handshake, allowing the attacker to intercept or modify media streams, leading to data leakage or service disruption."}
{"chapter_id": "V17", "chapter_name": "WebRTC", "section_id": "V17.2", "section_name": "Media", "req_id": "V17.2.7", "req_description": "Verify that any audio or video recording mechanisms associated with the media server are able to continue processing incoming media traffic during a flood of Secure Real-time Transport Protocol (SRTP) packets from legitimate users.", "level": 3, "explanation": "This requirement ensures that the media server can handle high volumes of legitimate traffic without being overwhelmed. It is crucial for maintaining service availability and ensuring that legitimate users can continue to communicate without interruption, even in scenarios where they may be sending a high volume of SRTP packets.", "threats_mitigated": ["Denial of Service (DoS)", "Service Disruption", "Resource Exhaustion"], "insecure_examples": [{"code": "if (srtpFloodDetected) { stopRecording(); }"}, {"code": "mediaServer.setProcessingEnabled(false);"}], "secure_examples": [{"code": "if (!srtpFloodDetected) { continueRecording(); } else { manageFlood(); }"}, {"code": "mediaServer.setProcessingEnabled(true);"}], "verification_steps": ["Review the media server configuration to ensure it can handle high SRTP traffic.", "Test the server under simulated flood conditions to verify it continues processing.", "Check logs for any interruptions in recording during high traffic scenarios."], "common_mistakes": ["Assuming that legitimate SRTP traffic will not flood the server.", "Not implementing rate limiting or traffic management for SRTP packets.", "Failing to test the server under load conditions."], "related_cwe": ["CWE-400", "CWE-770"], "related_capec": ["CAPEC-137", "CAPEC-152"], "attack_flow": "An attacker may exploit this requirement by flooding the media server with a high volume of legitimate SRTP packets. If the server is not capable of managing this flood, it may stop processing incoming media, resulting in service disruption for all users. This could lead to a Denial of Service condition, where legitimate users are unable to communicate effectively."}
{"chapter_id": "V17", "chapter_name": "WebRTC", "section_id": "V17.2", "section_name": "Media", "req_id": "V17.2.8", "req_description": "Verify that the Datagram Transport Layer Security (DTLS) certificate is checked against the Session Description Protocol (SDP) fingerprint attribute, terminating the media stream if the check fails, to ensure the authenticity of the media stream.", "level": "3", "explanation": "This requirement emphasizes the importance of validating the DTLS certificate used in WebRTC communications against the SDP fingerprint. The SDP fingerprint is a hash of the certificate that is exchanged during the signaling process. By verifying this fingerprint, the application can ensure that the media stream is being established with a legitimate peer and not an attacker. If the verification fails, the media stream should be terminated to prevent potential eavesdropping or man-in-the-middle attacks.", "threats_mitigated": ["Man-in-the-Middle (MitM) attacks", "Eavesdropping", "Impersonation of legitimate peers"], "insecure_examples": ["if (dtlsCertificate != expectedCertificate) { /* do nothing */ }", "startMediaStream();"], "secure_examples": ["if (dtlsCertificate == expectedCertificate) { startMediaStream(); } else { terminateMediaStream(); }", "checkSDPFingerprint(dtlsCertificate, sdpFingerprint);"], "verification_steps": ["Ensure that the DTLS certificate is being validated against the SDP fingerprint.", "Check that the media stream is terminated if the validation fails.", "Review the signaling process to confirm that the SDP fingerprint is securely exchanged."], "common_mistakes": ["Failing to validate the DTLS certificate against the SDP fingerprint.", "Not terminating the media stream upon validation failure.", "Assuming that the DTLS handshake is sufficient without additional checks."], "related_cwe": ["CWE-295: Improper Certificate Validation", "CWE-300: Channel Accessible by Non-Endpoint"], "related_capec": ["CAPEC-151: Man-in-the-Middle Attack", "CAPEC-139: Eavesdropping on a Communication Channel"], "attack_flow": "An attacker intercepts the signaling messages and provides a fraudulent SDP fingerprint that matches a malicious DTLS certificate. If the application does not verify the DTLS certificate against the SDP fingerprint, it may establish a media stream with the attacker, allowing them to eavesdrop or manipulate the communication."}
{"chapter_id": "V17", "chapter_name": "WebRTC", "section_id": "V17.3", "section_name": "Signaling", "req_id": "V17.3.1", "req_description": "Verify that the signaling server is able to continue processing legitimate incoming signaling messages during a flood attack. This should be achieved by implementing rate limiting at the signaling level.", "level": 2, "explanation": "This requirement emphasizes the importance of protecting the signaling server from denial-of-service (DoS) attacks caused by excessive signaling messages. By implementing rate limiting, the server can distinguish between legitimate traffic and malicious flood attempts, ensuring that valid users can still communicate even under attack.", "threats_mitigated": ["Denial of Service (DoS)", "Distributed Denial of Service (DDoS)", "Resource exhaustion"], "insecure_examples": [{"code": "while (true) { sendSignalingMessage(); } // No rate limiting"}, {"code": "function handleMessage(msg) { process(msg); } // Accepts all messages without validation"}], "secure_examples": [{"code": "function handleMessage(msg) { if (isValid(msg) && !isRateLimited()) { process(msg); } }"}, {"code": "const rateLimit = createRateLimiter(100); // Limit to 100 messages per minute"}], "verification_steps": ["Check if rate limiting is implemented on the signaling server.", "Test the server's response under normal traffic conditions.", "Simulate a flood attack and verify that legitimate messages are still processed.", "Review server logs for any dropped messages during high traffic."], "common_mistakes": ["Failing to implement any form of rate limiting.", "Setting rate limits too high, allowing flood attacks to succeed.", "Not distinguishing between legitimate and malicious traffic."], "related_cwe": ["CWE-770: Allocation of Resources Without Limits", "CWE-400: Uncontrolled Resource Consumption"], "related_capec": ["CAPEC-139: Flooding Attack", "CAPEC-137: Denial of Service via Resource Exhaustion"], "attack_flow": "An attacker sends a large volume of signaling messages to the server, overwhelming it and causing legitimate messages to be dropped. Without rate limiting, the server cannot differentiate between normal and malicious traffic, leading to denial of service for legitimate users."}
{"chapter_id": "V17", "chapter_name": "WebRTC", "section_id": "V17.3", "section_name": "Signaling", "req_id": "V17.3.2", "req_description": "Verify that the signaling server is able to continue processing legitimate signaling messages when encountering malformed signaling message that could cause a denial of service condition. This could include implementing input validation, safely handling integer overflows, preventing buffer overflows, and employing other robust error-handling techniques.", "level": "2", "explanation": "This requirement ensures that the signaling server can handle unexpected or malformed input without crashing or becoming unresponsive. By implementing proper input validation and error handling, the server can differentiate between valid and invalid messages and maintain its operational integrity even when faced with potentially harmful inputs.", "threats_mitigated": ["Denial of Service (DoS)", "Buffer Overflow Attacks", "Integer Overflow Attacks", "Input Validation Attacks"], "insecure_examples": [{"code": "if (message == null) { return; } processMessage(message);", "description": "This code does not validate the structure or content of the message, allowing malformed messages to be processed."}, {"code": "int value = Integer.parseInt(input); // No error handling", "description": "This code does not handle potential integer overflow or invalid input, which could lead to application crashes."}], "secure_examples": [{"code": "if (isValidMessage(message)) { processMessage(message); } else { logError(\"Invalid message received\"); }", "description": "This code checks if the message is valid before processing it, preventing malformed messages from causing issues."}, {"code": "try { int value = Integer.parseInt(input); } catch (NumberFormatException | ArithmeticException e) { handleError(e); }", "description": "This code safely handles potential exceptions when parsing integers, preventing crashes."}], "verification_steps": ["Review input validation mechanisms for signaling messages.", "Check for proper error handling in the signaling server code.", "Test the server with various malformed messages to ensure it remains operational.", "Verify that logs capture invalid message attempts without exposing sensitive information."], "common_mistakes": ["Failing to validate the structure and content of incoming messages.", "Not implementing sufficient error handling for unexpected inputs.", "Assuming that all input will be well-formed and neglecting edge cases.", "Ignoring potential overflow conditions when processing numerical data."], "related_cwe": ["CWE-20", "CWE-119", "CWE-190", "CWE-399"], "related_capec": ["CAPEC-50", "CAPEC-104", "CAPEC-111"], "attack_flow": "An attacker sends a malformed signaling message to the server. If the server lacks proper validation, it may attempt to process the message, leading to unexpected behavior such as crashes or resource exhaustion. This can render the service unavailable to legitimate users, achieving a denial of service condition."}
